
<!--WRITEIT_POST_NAME=Extending / Creating Combine Publishers the Right Way-->
<!--WRITEIT_POST_HTML_NAME=extending-creating-combine-publishers-the-right-way-->

<!--Add here the additional properties that you want each page to possess.-->
<!--These properties can be used to change content in the template page or in the page itself as shown here.-->
<!--Properties must start with 'WRITEIT_POST'.-->
<!--Writeit provides and injects WRITEIT_POST_NAME and WRITEIT_POST_HTML_NAME by default.-->

<!--WRITEIT_POST_SHORT_DESCRIPTION=In this article, I'll show you how to properly extend existing publishers and how to wrap them when creating your own custom publishers.-->

<!--DateFormat example: 2020-04-12T14:00:00+02:00-->
<!--WRITEIT_POST_SITEMAP_DATE_LAST_MOD=4-->
<!--WRITEIT_POST_SITEMAP_DATE=4-->

<title>$WRITEIT_POST_NAME</title>
<div class="col-md-12 blog-post"> 
<div class="post-title"> 
  <h1>$WRITEIT_POST_NAME</h1> 
</div> 
<div class="post-info"> 
DateHere
</div>
<p>I've been playing around with <b>Combine</b> for a while now and had some trouble navigating all the new protocols and types, especially when it came to extensions. In this article, I'll show you how to properly extend existing publishers and how to wrap them when creating your own custom publishers.</p>
<div class="sponsor-article-ad-auto hidden"></div>
<h2>The Easy Case: Extending Basic Output Publishers</h2>
<p>One of my favorite uses of Combine is how easily composable everything is. There's no need to create custom classes unless you really need to keep track of an external object:</p>
<pre>
<code>let publisher = CurrentValueSubject&lt;Int, Never>(0)</code>
<code></code>
<code>let evenSquaredPublisher = publisher.filter {</code>
<code>    $0 % 2 == 0</code>
<code>}.map {</code>
<code>    $0 * $0</code>
<code>}</code>
<code></code>
<code>let cancellable = evenSquaredPublisher.sink { print($0) }</code>
</pre>
<p>Since all articles require a non-sense example, our example is going to be a publisher that streams the squared of even numbers. As you can see, it's trivial to develop this functionality, but what if we wanted to do this more than once around our code?</p>
<p>Surprisingly, due to limitations on the constrained extensions API, it took me a while to figure out the right way to abstract this under a function. My first idea, and what I think some people out there are doing, is to extend <code>AnyPublisher</code> and constrain it to the <code>Int</code> output used by the example:</p>
<pre>
<code>extension AnyPublisher where Output == Int {</code>
<code>    func evenSquared() -> AnyPublisher&lt;Output, Failure> {</code>
<code>        return filter {</code>
<code>            $0 % 2 == 0</code>
<code>        }.map {</code>
<code>            $0 * $0</code>
<code>        }.eraseToAnyPublisher()</code>
<code>    }</code>
<code>}</code>
</pre>
<p>This however is not the right approach, because you'll now have to erase everyone who wants to use this method, and that's not why <code>AnyPublisher</code> exists:</p>
<pre>
<code>let evenSquaredPublisher = publisher.eraseToAnyPublisher().evenSquared()</code>
</pre>
<p>To extend publishers correctly in this case, we need to extend the main <code>Publisher</code> protocol:</p>
<pre>
<code>extension Publisher where Output == Int {</code>
<code>    func evenSquared() -> AnyPublisher&lt;Output, Failure> {</code>
<code>        return filter {</code>
<code>            $0 % 2 == 0</code>
<code>        }.map {</code>
<code>            $0 * $0</code>
<code>        }.eraseToAnyPublisher()</code>
<code>    }</code>
<code>}</code>
<code></code>
<code>let evenSquaredPublisher = publisher.evenSquared()</code>
</pre>
<p>This is better, but we're still not done. Luckily for us (or not, as you'll see below), every one of these Combine operators return an actual concrete <code>Publisher</code> implementation, so with some help of the compiler we can return the correct result of the operation instead of <code>AnyPublisher</code>:</p>
<pre>
<code>extension Publisher where Output == Int {</code>
<code>    func evenSquared() -> Publishers.Map&lt;Publishers.Filter&lt;Self>, Output> {</code>
<code>        return filter {</code>
<code>            $0 % 2 == 0</code>
<code>        }.map {</code>
<code>            $0 * $0</code>
<code>        }</code>
<code>    }</code>
<code>}</code>
</pre>
<p>The signature of methods might let a little large because of this, but as far as I know, this is the correct way of approaching this problem, and you can make it better in this case with an alias:</p>
<pre>
<code>typealias EvenSquaredPublisher&lt;P: Publisher, T> = Publishers.Map&lt;Publishers.Filter&lt;P>, T></code>
<code>extension Publisher where Output == Int {</code>
<code>    func evenSquared() -> EvenSquaredPublisher&lt;Self, Output> {</code>
<code>        return filter {</code>
<code>            $0 % 2 == 0</code>
<code>        }.map {</code>
<code>            $0 * $0</code>
<code>        }</code>
<code>    }</code>
<code>}</code>
</pre>
<p>So far this seems like nothing special, but don't worry, this is going to get weird pretty soon.</p>
<h2>The Hardcore Case: Extending Publishers With Generic Outputs</h2>
<p>There's one additional case I would like to show you, which is what prompted me to write this article. <b>What if the output itself contains generics?</b></p>
<pre>
<code>enum Condition&lt;T> {</code>
<code>    case satisfied(T)</code>
<code>    case unsatisfied</code>
<code>}</code>
<code></code>
<code>let publisher = CurrentValueSubject&lt;Condition&lt;Int>, Never>(.satisfied(1))</code>
<code>let publisherB = CurrentValueSubject&lt;Condition&lt;Int>, Never>(.satisfied(2))</code>
<code></code>
<code>let combinedConditions = publisher.combineLatest(publisherB).map { tuple in</code>
<code>    guard case .satisfied(let pA) = tuple.0, case .satisfied(let pB) = tuple.1 else {</code>
<code>        return .unsatisfied</code>
<code>    }</code>
<code>    return .satisfied((pA, pB))</code>
<code>}</code>
</pre>
<p>In this example, we're merging the contents of two conditions into a single condition that contains both publisher's values. But because the result here is <code>Condition&lt;T></code>, we can't use the constrained extension syntax anymore:</p>
<pre>
<code>extension Publisher where Output == Condition</code>
<code>// Reference to generic type 'Condition' requires arguments in &lt;...></code>
</pre>
<p>I personally find it really weird that this is not possible to do, and perhaps a point of improvement with Swift in the future. Still, there's a way you can achieve this. in <i>this</i> case, the correct approach is to instead constrain <b>the method itself</b>:</p>
<pre>
<code>extension Publisher {</code>
<code>    func combineCondition&lt;A, B, P: Publisher>(</code>
<code>        _ publisher: P</code>
<code>    ) -> Publishers.Map&lt;Publishers.CombineLatest&lt;Self, P>, Condition<(A, B)>></code>
<code>    where Output == Condition&lt;A>, P.Output == Condition&lt;B>, Failure == P.Failure {</code>
<code>        return combineLatest(publisher).map { tuple in</code>
<code>            guard case .satisfied(let pA) = tuple.0, case .satisfied(let pB) = tuple.1 else {</code>
<code>                return .unsatisfied</code>
<code>            }</code>
<code>            return .satisfied((pA, pB))</code>
<code>        }</code>
<code>    }</code>
<code>}</code>
</pre>
<p>As promised, things got weird pretty fast. Besides constraining the initial publisher's output to match the desired <code>Condition</code> type through an unconstrained generic <code>A</code> type in the method's signature, we also need to make sure that the merging publisher's <code>Failure</code> type matches the one that triggered the operation. That's a really big method!</p>
<p>To wrap it up, let me show you how to achieve the same thing when a custom type is used instead. In this case, we can do the same thing in the class's initializer:</p>
<pre>
<code>final class CombinedConditionPublisher&lt;A, B, F: Error>: Publisher {</code>
<code></code>
<code>    typealias Output = Condition<(A, B)></code>
<code>    typealias Failure = F</code>
<code></code>
<code>    let combined: AnyPublisher&lt;Condition&lt;(A, B)>, F></code>
<code></code>
<code>    init&lt;PA: Publisher, PB: Publisher>(</code>
<code>        _ a: PA,</code>
<code>        _ b: PB,</code>
<code>        receiveValue: @escaping ((Condition<(A, B)>) -> Void)</code>
<code>    )</code>
<code>    where PA.Failure == F, PB.Failure == F, PA.Output == Condition&lt;A>, PB.Output == Condition&lt;B></code>
<code>    {</code>
<code>        combined = a.combineLatest(b).map { tuple in</code>
<code>            guard case .satisfied(let pA) = tuple.0, case .satisfied(let pB) = tuple.1 else {</code>
<code>                return .unsatisfied</code>
<code>            }</code>
<code>            return .satisfied((pA, pB))</code>
<code>        }.eraseToAnyPublisher()</code>
<code>    }</code>
<code></code>
<code>    func receive&lt;S>(subscriber: S) where S : Subscriber, Failure == S.Failure, Output == S.Input {</code>
<code>        combined.receive(subscriber: subscriber)</code>
<code>    }</code>
<code>}</code>
<code></code>
<code>extension Publisher {</code>
<code>    func combineCondition&lt;A, B, P: Publisher>(</code>
<code>        _ publisher: P</code>
<code>    ) -> CombinedConditionPublisher&lt;A, B, Failure></code>
<code>    where Output == Condition&lt;A>, P.Output == Condition&lt;B>, Failure == P.Failure {</code>
<code>        return CombinedConditionPublisher(self, publisher)</code>
<code>    }</code>
<code>}</code>
</pre>
<p>This case is a little more complex though, because we now need to use <code>AnyPublisher</code> to cover the fact that we cannot constrain <code>PA</code> and <code>PB</code> in the class's main definition. Still, the functionality will be the same.</p>
<div class="sponsor-article-ad-auto hidden"></div>
<p>While it's unfortunate that the signatures are enormous, things will look perfect in the call site. As mentioned before, as weird as it looks, this seems to be exactly how Combine implements some of its operators.</p>
<pre>
<code>let publisher = CurrentValueSubject&lt;Condition&lt;Int>, Never>(.satisfied(1))</code>
<code>let publisherB = CurrentValueSubject&lt;Condition&lt;Int>, Never>(.satisfied(2))</code>
<code></code>
<code>let combined = publisher.combineCondition(publisherB)</code>
</pre>
</div>
