<!DOCTYPE html>
<html lang="en">

  <head>

    <script src="https://use.fontawesome.com/afd448ce82.js"></script>
    
    <!-- Meta Tag -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    
    <!-- SEO -->
    <meta name="author" content="Bruno Rocha">
    <meta name="keywords" content="iOS, Xcode, Swift, Articles, Tutorials, OBJ-C, Objective-C, Apple">
    <meta name="description" content="SwiftRocks is a blog about how Swift works and general iOS tips and tricks.">
    <meta name="title" content="SwiftRocks - How Swift Works & iOS Tips and Tricks">
    <meta name="url" content="https://swiftrocks.com/index">
    <meta name="image" content="https://swiftrocks.com/images/thumbs/index.png">
    <meta name="copyright" content="Bruno Rocha">
    <meta name="robots" content="index,follow">

    <meta property="og:title" content="SwiftRocks - How Swift Works & iOS Tips and Tricks"/>
    <meta property="og:image" content="https://swiftrocks.com/images/thumbs/index.png"/>
    <meta property="og:description" content="SwiftRocks is a blog about how Swift works and general iOS tips and tricks."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://swiftrocks.com/index"/>

    <meta name="twitter:card" content="summary_large_image"/>
    <meta name="twitter:image" content="https://swiftrocks.com/images/thumbs/index.png"/>
    <meta name="twitter:image:alt" content="SwiftRocks.com logo"/>
    <meta name="twitter:title" content="SwiftRocks - How Swift Works & iOS Tips and Tricks"/>
    <meta name="twitter:description" content="SwiftRocks is a blog about how Swift works and general iOS tips and tricks."/>
    <meta name="twitter:site" content="@rockbruno_"/>
    
    <!-- Favicon -->
    <link rel="shortcut icon" href="images/favicon/favicon-2.ico">
    <link rel="mask-icon" href="images/favicon/favicon-2.ico">
    <link rel="apple-touch-icon" href="images/favicon/apple-touch-icon.png">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:light,lightitalic,regular,regularitalic,medium,mediumitalic,bold,bolditalic,black,blackitalic">
    
  <!-- Bootstrap CSS Plugins --> 
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
  <!-- Prism CSS Stylesheet --> 
  <link rel="stylesheet" type="text/css" href="css/prism3.css"> 
  <!-- Main CSS Stylesheet --> 
  <link rel="stylesheet" type="text/css" href="css/style40.css"> 
  <link rel="stylesheet" type="text/css" href="css/sponsor2.css">
    
    <!-- HTML5 shiv and Respond.js support IE8 or Older for HTML5 elements and media queries -->
    <!--[if lt IE 9]>
	   <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
	   <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->

  <script type="application/ld+json">
  {
"@context": "https://schema.org",
"@type": "BlogPosting",
"mainEntityOfPage": {
  "@type": "WebPage",
  "@id": "https://swiftrocks.com/useful-obscure-foundation-types-in-swift"
},
"image": [
  "https://swiftrocks.com/images/bg/swiftrockssocial.png"
],
"datePublished": "2019-06-26T18:00:00+00:00",
"dateModified": "2020-10-18T18:00:00+02:00",
"author": {
  "@type": "Person",
  "name": "Bruno Rocha"
},
 "publisher": {
  "@type": "Organization",
  "name": "SwiftRocks",
  "logo": {
    "@type": "ImageObject",
    "url": "https://swiftrocks.com/images/bg/swiftrockssocial.png"
  }
},
"headline": "Useful (and obscure!) Foundation types in Swift",
    "abstract": "The <code>Foundation</code> provides you a lot of the bread-and-butter needed for your daily iOS development, ranging from structures like <code>Data</code> all the way to complete APIs like <code>URLSession</code>. But as it turns out, we only use a fraction of what <code>Foundation</code> offers."
}
  </script>
    

  </head>

 <body>
      
    
    
     
    
    
  <div id="main"> 
<!-- Blog Header --> 
      <div class="blog-header-container" style="width: 100%">
         <div style="display: flex; justify-content: center;"><a href="https://swiftrocks.com">
           <img id="logo" alt="SwiftRocks" src="images/bg/swiftrockswithtextdarkmode2.png" style="margin-top: 32px; margin-left: 16px; margin-right: 16px; max-width: calc(100% - 32px); width: auto; height: auto;"> 
         </a></div>
         <div style="margin-top: 15px; display: flex; justify-content: center;">
           <p class="blog-header-text">A blog about <b style="color: white;">how Swift works</b> and <b style="color: white;">iOS tricks</b>, by <a href="https://twitter.com/rockbruno_">Bruno Rocha</a>.</p>
         </div>
          <div class="blog-header-button-container">
          <div class="blog-header-button">
               <a href="https://twitter.com/rockbruno_" target="_blank" style="display: flex;">
                  <i class="fa fa-twitter"></i>
                  <div class="blog-header-button-follow-shape"></div>
                  <div class="blog-header-button-follow">4762<div class="blog-header-button-follow-verbose"> followers</div>!</div>
               </a>
          </div>
          <div class="blog-header-button">
               <a href="rss.xml" target="_blank">
                  <i class="fa fa-rss"></i>
               </a>
          </div>
          <div class="blog-header-button">
               <a href="mailto:bruno@swiftrocks.com" target="_blank">
                  <i class="fa fa-envelope"></i>
               </a>
          </div>
          <div class="blog-header-button">
               <a href="https://github.com/rockbruno" target="_blank">
                  <i class="fa fa-github"></i>
               </a>
          </div>
          <div class="blog-header-button">
               <a href="sponsor-advertise-at-swiftrocks" target="_blank">
                  <div class="blog-header-button-sponsor">Sponsor</div>
               </a>
          </div>
         </div>
     </div>
         <!-- Blog Post (Right Sidebar) Start --> 
   <div class="container"> 
                 <div class="col-xs-12">
                    <div class="page-body">
                    	<div class="row">

 <!-- Mailchimp -->
  <div id="mc_embed_signup">
  <div style="display:flex; justify-content: center;">
  <p style="font-weight: 100; font-size: 16px; text-align: center;">Articles about advanced Swift development in excruciating detail, for free!</p>
  </div>
  <form action="https://swiftrocks.us17.list-manage.com/subscribe/post?u=d6bdd39e59b8d9b8f2b8d4852&amp;id=c447bac594" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" style="padding: 0;" novalidate>
      <div id="mc_embed_signup_scroll">
    
    <input type="email" value="" name="EMAIL" class="email" id="mce-EMAIL" placeholder="Your email address" required>
      <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->
      <div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_d6bdd39e59b8d9b8f2b8d4852_c447bac594" tabindex="-1" value=""></div>
      <div class="clear"><input type="submit" value="Notify me of new posts" name="subscribe" id="mc-embedded-subscribe" class="button"></div>
      </div>
  </form>
  </div>
  <!-- Mailchimp End -->

                            <div class="content-page" id="WRITEIT_DYNAMIC_CONTENT">
 
  
  <!--WRITEIT_POST_NAME=Useful (and obscure!) Foundation types in Swift--> 
  <!--WRITEIT_POST_HTML_NAME=useful-obscure-foundation-types-in-swift--> 
  <!--WRITEIT_POST_SITEMAP_DATE_LAST_MOD=2020-10-18T18:00:00+02:00--> 
  <!--WRITEIT_POST_SITEMAP_DATE=2019-06-26T18:00:00+00:00--> 
  <!--Add here the additional properties that you want each page to possess.--> 
  <!--These properties can be used to change content in the template page or in the page itself as shown here.--> 
  <!--Properties must start with 'WRITEIT_POST'.--> 
  <!--Writeit provides and injects WRITEIT_POST_NAME and WRITEIT_POST_HTML_NAME by default.--> 
  <!--WRITEIT_POST_SHORT_DESCRIPTION=The <code>Foundation</code> provides you a lot of the bread-and-butter needed for your daily iOS development, ranging from structures like <code>Data</code> all the way to complete APIs like <code>URLSession</code>. But as it turns out, we only use a fraction of what <code>Foundation</code> offers.--> 
  <title>Useful (and obscure!) Foundation types in Swift</title>  
 

<div class="blog-post"> 
 <div class="post-title-index">  
  <h1>Useful (and obscure!) Foundation types in Swift</h1>
 </div> 
 <div class="post-info"> 
  <div class="category category-ios">
   iOS
  </div> 
  <div class="post-info-text">
   Published on 26 Jun 2019 
  </div> 
 </div>   
 <p>The <code>Foundation</code> provides you a lot of the bread-and-butter needed for your daily iOS development, ranging from structures like <code>Data</code> all the way to complete APIs like <code>URLSession</code>. But as it turns out, we only use a fraction of what <code>Foundation</code> offers.</p>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>There's a bunch of Foundation types that are <b>so situational</b> that people doubt they even existed in the first place! In fact, they are so rarely mentioned as solutions to daily problems that developers may end up coding things that may <i>already</i> exist in these SDKs. But they do exist -- and although some of them are really old, most of these types are still very useful. Let's take a look at some of them!</p>
 <h2>NSScanner</h2>
 <p><code>NSScanner</code> can progressively extract numbers and strings from a base string, similarly to how <code>scanf</code> works in C:</p>
 <pre>
<code>public func extractIntsFrom(string: String) -&gt; [Int] {</code>
<code>    var result: [Int] = []</code>
<code>    let scanner = Scanner(string: string)</code>
<code>    // Jump over everything that isn't a number</code>
<code>    scanner.charactersToBeSkipped = CharacterSet.decimalDigits.inverted</code>
<code>    var pointer: Int = 0</code>
<code>    while scanner.isAtEnd == false {</code>
<code>        if scanner.scanInt(&amp;pointer) {</code>
<code>            result.append(pointer)</code>
<code>        }</code>
<code>    }</code>
<code>    return result</code>
<code>}</code>
<code></code>
<code>let string = "1M very L337 700"</code>
<code>let ints = extractIntsFrom(string: string)</code>
<code>// [1, 337, 700]</code>
</pre>
 <p>The scanner API has many variations like <code>scanString</code>, <code>scanDouble</code> and <code>scanHexInt</code>, and can be configured to scan at specific locations in a string or to take case sensitivity in consideration. This is a more direct and performant solution for searching occurrences of a string when you're looking for specific patterns such as something that resembles a number instead of a concrete match.</p>
 <p>You might notice that this API requires pointers which is an unfortunate side-effect of this being an old Obj-C API, but you can always abstract these types under extensions to make it look better for you and your colleagues.</p>
 <h2>NSCountedSet</h2>
 <p>There are many problems in programming that requires you to keep track of the quantity of a certain element, like the classic anagram interview problem:</p>
 <pre>
<code>func isAnagram(_ first: String, _ second: String) -&gt; Bool {</code>
<code>    guard first.count == second.count else {</code>
<code>        return false</code>
<code>    }</code>
<code>    var dict = [Character: Int]()</code>
<code>    for character in first {</code>
<code>        firstDict[character, default: 0] += 1</code>
<code>    }</code>
<code>    for character in second {</code>
<code>        dict[character, default: 0] -= 1</code>
<code>        if dict[character] == 0 {</code>
<code>            dict[character] = nil</code>
<code>        }</code>
<code>    }</code>
<code>    return dict.isEmpty</code>
<code>}</code>
</pre>
 <p>This is easy to solve with dictionaries with <code>Int</code> values, but we don't need to, because that's exactly what <code>NSCountedSet</code> does.</p>
 <pre>
<code>func isAnagram(_ first: String, _ second: String) -&gt; Bool {</code>
<code>    guard first.count == second.count else {</code>
<code>        return false</code>
<code>    }</code>
<code>    let countedSet = NSCountedSet(array: Array(first))</code>
<code>    for character in second {</code>
<code>        countedSet.remove(c)</code>
<code>    }</code>
<code>    return countedSet.count == 0</code>
<code>}</code>
</pre>
 <p>Elements can be repeatedly added to the set with <code>countedSet.add(element)</code> and have their counts inspected with <code>countedSet.count(element)</code>. If the count reaches zero, the element is removed from the set. However, just like a regular <code>Set</code> in Swift, you can only add one of each element to the set, which is great to avoid duplication.</p>
 <h2>NSCache</h2>
 <p><code>NSCache</code> is a collection type that works similarly to a dictionary, but it has two important key differences. First, it <b>does not</b> copy the key objects that are put into it, and second, it <b>automatically removes entries</b> from itself it the system is running out of memory.</p>
 <p>The actual policies for removing entries are cryptic, but if you have objects that expensive to create, usage of <code>NSCache</code> can be a very system friendly alternative to regular dictionary caches. Here's how it can be used for caching <code>UIImages</code>:</p>
 <pre>
<code>final class ImageDownloader {</code>
<code>    let client: HTTPClient</code>
<code>    let cache = NSCache&lt;NSString, NSData&gt;()</code>
<code></code>
<code>    init(client: HTTPClient) {</code>
<code>        self.client = client</code>
<code>    }</code>
<code></code>
<code>    func load(imageUrl: URL, intoImageView imageView: UIImageView) {</code>
<code>       let key = imageUrl.absoluteString as NSString</code>
<code>        func apply(data: NSData) {</code>
<code>            let image = UIImage(data: data as Data)</code>
<code>            imageView.image = image</code>
<code>        }</code>
<code>        if let cachedData = cache.object(forKey: key) {</code>
<code>            apply(data: cachedData)</code>
<code>            return</code>
<code>        } else {</code>
<code>            client.data(from: imageUrl) { data in</code>
<code>                cache.setObject(data as NSData, forKey: key)</code>
<code>                apply(data: data as NSData)</code>
<code>            }</code>
<code>        }</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>In this case, we can use <code>NSCache</code> as a very simple way of not having to download the same images over and over.</p>
 <h2>NSOrderedSet</h2>
 <p>Sets are great for keeping track of elements when duplication doesn't matter, but because set access is O(1), there's no guarantee that they will be ordered when you do so. As the name implies, <code>NSOrderedSet</code> works like a regular <code>Set</code> with the exception that the elements are <b>ordered</b>.</p>
 <pre>
<code>let set = NSMutableOrderedSet()</code>
<code>set.add(1)</code>
<code>set.add(4)</code>
<code>set.add(1)</code>
<code>set.add(1)</code>
<code>set.add(1)</code>
<code>set.add(6)</code>
<code>set.add(4)</code>
<code>set.add(6)</code>
<code>for a in set {</code>
<code>    print(a)</code>
<code>    // 1, 4, 6</code>
<code>}</code>
</pre>
 <p>Because this is an old type you'll notice that there's no generics in it -- all operations are based on the <code>Any</code> type. This isn't very Swifty, so you'll probably want to wrap it in a Swift type:</p>
 <pre>
<code>class OrderedSet&lt;T: Hashable&gt;: Sequence {</code>
<code>    private let _set = NSMutableOrderedSet()</code>
<code>    init() {}</code>
<code></code>
<code>    func makeIterator() -&gt; NSFastEnumerationIterator {</code>
<code>        return _set.makeIterator()</code>
<code>    }</code>
<code></code>
<code>    func add(_ element: T) {</code>
<code>        _set.add(element)</code>
<code>    }</code>
<code></code>
<code>    func remove(_ element: T) {</code>
<code>        _set.remove(element)</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>Like <code>NSCountedSet</code>, <code>NSOrderedSet</code> is a great tool when you want to have array-like functionality without allowing duplicate elements in it.</p>
 <h2>NSByteCountFormatter</h2>
 <p>There are tons of obscure formatters in Foundation, but <code>ByteCountFormatter</code> is one I specifically like. It formats byte counts into human readable file size formats, which is useful if your app downloads content as you don't need to calculate these values manually.</p>
 <pre>
<code>let bytes = 1024 * 1024</code>
<code>let formatter = ByteCountFormatter()</code>
<code>formatter.allowsNonnumericFormatting = false // Uses '0' instead of 'Zero'</code>
<code>formatter.countStyle = .file</code>
<code>let string = formatter.string(fromByteCount: Int64(bytes))</code>
<code>// 1 MB</code>
</pre>
 <h2>NSDataDetector</h2>
 <p><code>NSDataDetector</code> is similar to <code>NSScanner</code>, with the difference that it extracts <b>contextual</b> data from strings like phone numbers, addresses and links.</p>
 <pre>
<code>let string = "I write for https://swiftrocks.com and my phone is 555-111-111."</code>
<code>let range = NSRange(0..&lt;string.count)</code>
<code></code>
<code>let types: NSTextCheckingResult.CheckingType = [.link, .phoneNumber]</code>
<code>let dataDetector = try NSDataDetector(types: types.rawValue)</code>
<code>dataDetector.enumerateMatches(in: string, options: [], range: range) { (match, _, _) in</code>
<code>    guard let match = match else { return }</code>
<code>    switch match.resultType {</code>
<code>    case .link:</code>
<code>        print(match.url!)</code>
<code>        // https://swiftrocks.com</code>
<code>    case .phoneNumber:</code>
<code>        print(match.phoneNumber!)</code>
<code>        // "555-111-111"</code>
<code>    default:</code>
<code>        return</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>The downside is that it relies on Foundation's regex API, once again, because it's old. This is again not very Swifty, but <code>NSDataDetector</code> is still a very solid type if you need to extract such information.</p>
 <h2>CFBinaryHeap</h2>
 <p>The Swift Standard Library has a notorious lack of data structures (which the new Swift Algorithms package is trying to improve!), but you can find Tree and Heap implementations in Foundation in the shape of <code>CFTree</code> and <code>CFBinaryHeap</code>. Heaps are a very efficient way to implement priority queue structures, and since they're very extensive to code, <code>CFBinaryHeap</code> can save you some time.</p>
 <p>I'm adding it to the list because it's obscure and cool, but I have to say that it's unfortunately very hard to use. <code>CFBinaryHeap</code> is a C CoreFoundation class that isn't bridged to Foundation, so you won't be able to use without managing tons of pointers. Your best bet would be to write or use a wrapper like <a href="https://github.com/matthewcheok/MCBinaryHeap">MCBinaryHeap</a>.</p>
 <pre>
<code>let array = [8,3,5,4,1]</code>
<code>let heap = MCBinaryHeap(array: array)</code>
<code>heap?.popMinimumObject() // 1</code>
<code>heap?.popMinimumObject() // 3</code>
<code>heap?.popMinimumObject() // 4</code>
<code>heap?.popMinimumObject() // 5</code>
<code>heap?.popMinimumObject() // 8</code>
</pre>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>Priority queues are popular in graph searching problems and can be used to bring efficiency to anything where you need to keep track of the smallest or largest elements in an unordered array. It might take a while for you to find a use-case for priority queues or graph algorithms in general, but once you do, you'll realize that anything else would have been a giant performance issue. One example where I have personally applied graph algorithms in Swift is to resolve the dependencies of our app's dependency injection system for features.</p>
 <p>There are tons of useful types in Foundation and UIKit that we don't hear much of, but knowing them can help you prevent writing unnecessary code. Have fun with these types!</p>
 <h2>References and Good reads</h2>
 <a href="https://developer.apple.com/documentation/foundation/nsscanner">NSScanner</a>
 <br>
 <a href="https://developer.apple.com/documentation/foundation/nscountedset">NSCountedSet</a>
 <br>
 <a href="https://developer.apple.com/documentation/foundation/nsorderedset">NSOrderedSet</a>
 <br>
 <a href="https://developer.apple.com/documentation/foundation/nsbytecountformatter">NSByteCountFormatter</a>
 <br>
 <a href="https://developer.apple.com/documentation/foundation/nsorderedset">NSDataDetector</a>
 <br>
 <a href="https://developer.apple.com/documentation/foundation/nscache">NSCache</a>
 <br>
 <a href="https://developer.apple.com/documentation/corefoundation/cfbinaryheap">CFBinaryHeap</a>
 <br>
</div></div>
                              
   

    <div class="blog-post" style="margin-top: 16px;">
      <div class="footer-text">
        <p>Thanks for reading! If you want to see more Swift / iOS content like this, follow me on <a href="https://twitter.com/rockbruno_">Twitter!</a></p>
        <div class="footer-share">
        <a href="https://twitter.com/intent/tweet?via=rockbruno_&hashtags=swiftrocks,ios,swiftlang&url=https%3A%2F%2Fswiftrocks.com%2Fhow-actors-work-internally-in-swift&text=How Actors Work Internally in Swift" target="_blank" class="share" style="font-size: 18px;"><i class="fa fa-twitter"></i>‏‏‎ ‎‏‏‎ ‎‏‏‎ ‎Share this page on Twitter</a>
        </div>
      </div>
    <!-- Mailchimp -->
  <div id="mc_embed_signup" style="border-top: 1px solid black; padding-top: 32px;">
  <div style="display:flex; justify-content: center; text-align: center;">
  <p style="font-weight: 100; font-size: 16px;">Articles about advanced Swift development in excruciating detail, for free!</p>
  </div>
  <form action="https://swiftrocks.us17.list-manage.com/subscribe/post?u=d6bdd39e59b8d9b8f2b8d4852&amp;id=c447bac594" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" style="padding: 0;" novalidate>
      <div id="mc_embed_signup_scroll">
    
    <input type="email" value="" name="EMAIL" class="email" id="mce-EMAIL" placeholder="Your email address" required>
      <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->
      <div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_d6bdd39e59b8d9b8f2b8d4852_c447bac594" tabindex="-1" value=""></div>
      <div class="clear"><input type="submit" value="Notify me of new posts" name="subscribe" id="mc-embedded-subscribe" class="button"></div>
      </div>
  </form>
  </div>
  <!-- Mailchimp End -->
    <div class="copyright">
    <text>Copyright © 2016-2021 SwiftRocks.</text>
    <text><a href="https://swiftrocks.com">Index</a> | <a href="sponsor-advertise-at-swiftrocks">Sponsor</a></text>
    </div>

    </div>

                         </div>

</div>
                        
                           
                         </div>
                     
                     
                  </div>
                  <!-- Blog Post (Right Sidebar) End -->
                
            </div>
         </div>
      </div>
    
    
    <!-- All Javascript Plugins  -->
  <script type="text/javascript" src="js/jquery.min.js"></script> 
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM" crossorigin="anonymous"></script>
  <script type="text/javascript" src="js/prism3.js"></script> 
    <!-- Main Javascript File  -->
    <script type="text/javascript" src="js/scripts11.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-130406165-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-130406165-1');
</script>

   </body>
 </html>
