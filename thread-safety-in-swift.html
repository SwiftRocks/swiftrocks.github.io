<!DOCTYPE html>
<html lang="en">

  <head>

    <script src="https://use.fontawesome.com/afd448ce82.js"></script>
    
    <!-- Meta Tag -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    
    <!-- SEO -->
    <meta name="author" content="Bruno Rocha">
    <meta name="keywords" content="iOS, Xcode, Swift, Articles, Tutorials, OBJ-C, Objective-C, Apple">
    <meta name="description" content="Concurrency is the entry point for the most complicated and bizarre bugs a programmer will ever experience. In this article, I'll share my favorite methods of ensuring thread safety, as well as analyzing the performance of the different mechanisms.">
    <meta name="title" content="Thread Safety in Swift">
    <meta name="url" content="https://swiftrocks.com/thread-safety-in-swift">
    <meta name="image" content="https://swiftrocks.com/images/thumbs/thumb.jpg?4">
    <meta name="copyright" content="Bruno Rocha">
    <meta name="robots" content="index,follow">

    <meta property="og:title" content="Thread Safety in Swift"/>
    <meta property="og:image" content="https://swiftrocks.com/images/thumbs/thumb.jpg?4"/>
    <meta property="og:description" content="Concurrency is the entry point for the most complicated and bizarre bugs a programmer will ever experience. In this article, I'll share my favorite methods of ensuring thread safety, as well as analyzing the performance of the different mechanisms."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://swiftrocks.com/thread-safety-in-swift"/>

    <meta name="twitter:card" content="summary_large_image"/>
    <meta name="twitter:image" content="https://swiftrocks.com/images/thumbs/thumb.jpg?4"/>
    <meta name="twitter:image:alt" content="Page Thumbnail"/>
    <meta name="twitter:title" content="Thread Safety in Swift"/>
    <meta name="twitter:description" content="Concurrency is the entry point for the most complicated and bizarre bugs a programmer will ever experience. In this article, I'll share my favorite methods of ensuring thread safety, as well as analyzing the performance of the different mechanisms."/>
    <meta name="twitter:site" content="@rockbruno_"/>
    
    <!-- Favicon -->
    <link rel="shortcut icon" href="images/favicon/favicon-2.ico">
    <link rel="mask-icon" href="images/favicon/favicon-2.ico">
    <link rel="apple-touch-icon" href="images/favicon/apple-touch-icon.png">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:light,lightitalic,regular,regularitalic,medium,mediumitalic,bold,bolditalic,black,blackitalic">
    
    

  <!-- Bootstrap CSS Plugins --> 
  <link rel="stylesheet" type="text/css" href="css/bootstrap.css">
  <!-- Prism CSS Stylesheet --> 
  <link rel="stylesheet" type="text/css" href="css/prism3.css"> 
  <!-- Main CSS Stylesheet --> 
  <link rel="stylesheet" type="text/css" href="css/style43.css"> 
  <link rel="stylesheet" type="text/css" href="css/sponsor2.css">
    
    <!-- HTML5 shiv and Respond.js support IE8 or Older for HTML5 elements and media queries -->
    <!--[if lt IE 9]>
	   <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
	   <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->

  <script type="application/ld+json">
  {
"@context": "https://schema.org",
"@type": "BlogPosting",
"mainEntityOfPage": {
  "@type": "WebPage",
  "@id": "https://swiftrocks.com/thread-safety-in-swift"
},
"image": [
  "https://swiftrocks.com.com/images/logo/logo.png"
],
"datePublished": "2021-05-11T14:00:00+02:00",
"dateModified": "2022-07-19T14:35:00+02:00",
"author": {
  "@type": "Person",
  "name": "Bruno Rocha"
},
 "publisher": {
  "@type": "Organization",
  "name": "SwiftRocks",
  "logo": {
    "@type": "ImageObject",
    "url": "https://swiftrocks.com.com/images/logo/logo.png"
  }
},
"headline": "Thread Safety in Swift",
    "abstract": "Concurrency is the entry point for the most complicated and bizarre bugs a programmer will ever experience. In this article, I'll share my favorite methods of ensuring thread safety, as well as analyzing the performance of the different mechanisms."
}
  </script>
    

  </head>

 <body>
      
    
    
     
    
    
  <div id="main"> 
<!-- Blog Header --> 
         <!-- Blog Post (Right Sidebar) Start --> 
   <div class="container"> 
                 <div class="col-xs-12">
                    <div class="page-body">
                    	<div class="row">
         <div><a href="https://swiftrocks.com">
           <img id="logo" alt="SwiftRocks" src="images/bg/logo.png" style="margin-top: 32px; max-width: 100%; width: auto; height: auto;"> 
         </a></div>
                            <div class="content-page" id="WRITEIT_DYNAMIC_CONTENT">
 
  
  <!--WRITEIT_POST_NAME=Thread Safety in Swift--> 
  <!--WRITEIT_POST_HTML_NAME=thread-safety-in-swift--> 
  <!--Add here the additional properties that you want each page to possess.--> 
  <!--These properties can be used to change content in the template page or in the page itself as shown here.--> 
  <!--Properties must start with 'WRITEIT_POST'.--> 
  <!--Writeit provides and injects WRITEIT_POST_NAME and WRITEIT_POST_HTML_NAME by default.--> 
  <!--WRITEIT_POST_SHORT_DESCRIPTION=Concurrency is the entry point for the most complicated and bizarre bugs a programmer will ever experience. In this article, I'll share my favorite methods of ensuring thread safety, as well as analyzing the performance of the different mechanisms.--> 
  <!--DateFormat example: 2020-04-12T14:00:00+02:00--> 
  <!--WRITEIT_POST_SITEMAP_DATE_LAST_MOD=2022-07-19T14:35:00+02:00--> 
  <!--WRITEIT_POST_SITEMAP_DATE=2021-05-11T14:00:00+02:00--> 
  <title>Thread Safety in Swift</title>  
 

<div class="blog-post"> 
 <div class="post-title-index">  
  <h1>Thread Safety in Swift</h1>
 </div> 
 <div class="post-info"> 
  <div class="category category-swift">
   Swift
  </div> 
  <div class="post-info-text">
   Published on 11 May 2021 
  </div> 
 </div>  
 <div class="post-image"> 
  <img src="https://i.imgur.com/2PDjXPQ.png" alt="Lock times"> 
 </div> 
 <p>Concurrency is the entry point for the most complicated and bizarre bugs a programmer will ever experience. Because we at the application level have no real control over the threads and the hardware, there's no perfect way of creating unit tests that guarantee your systems will behave correctly when used by multiple threads at the same time.</p>
 <p>You can, however, make some very educated guesses. In this article, we'll take a look at what thread safety is, which tools iOS provides to help us achieve it, and how they compare in terms of performance.</p>
 <h2>What is Thread Safety?</h2>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>I personally define thread safety as a system's ability to ensure "correctness" when multiple threads attempt to use it at the same time. Look at a specific class you have that contains logic that can be accessed by background threads and ask yourself: Is it possible for <b>any</b> two lines of code in this class to run in parallel? If so, would that be fine or would that be <i>really</i> bad?</p>
 <p>One thing I've noticed is that while developers generally don't have trouble understanding the concept of thread safety, a lot of people have trouble applying it in practice. Consider the following example of a class that stores a person's full name:</p>
 <pre>
<code>final class Name {</code>
<code></code>
<code>    private(set) var firstName: String = ""</code>
<code>    private(set) var lastName: String  = ""</code>
<code></code>
<code>    func setFullName(firstName: String, lastName: String) {</code>
<code>        self.firstName = firstName</code>
<code>        self.lastName = lastName</code>
<code>    }</code>
<code>}</code>
 </pre>
 <p>Try asking yourself the same question as before. What would happen if two threads called <code>setFullName</code> at the same time?</code> Would that work fine or would that be really bad?</p>
 <p>The answer is the latter. Because we're not synchronizing the threads' access to this class's state, you could have the following scenario happen:</p>
 <blockquote>
     <p>Thread 1: Call <code>setFullName("Bruno", "Rocha")</code></p>
     <p>Thread 2: Call <code>setFullName("Onurb", "Ahcor")</code></p>
     <p>Thread 1: Sets <code>firstName</code> to "Bruno"</p>
     <p>Thread 2: Sets <code>firstName</code> to "Onurb"</p>
     <p>Thread 2 <b>(Again)</b>: Sets <code>lastName</code> to "Ahcor"</p>
     <p>Thread 1: Sets <code>lastName</code> to "Rocha"</p>
     <p>Final name: "Onurb Rocha". That's not right...</p>
 </blockquote>
 <p>This is called a <b>race condition</b>, and it's the least-worst scenario in this case. In reality, what would probably happen is that the Swift would just straight-up crash for illegal parallel property access.</p>
 <p>In short, this means that the <code>Name</code> class is not thread-safe. To fix the above race condition, we need to <b>synchronize how threads get to access and modify the state of this class</b>. If we make it so that <i>Thread 2</i> cannot start running <code>setFullName</code> until <i>Thread 1</i> finishes doing so, the scenario above would become impossible.</p>
 <p>In practice, many developers have trouble getting this right because they <b>confuse atomicity with thread safety.</b> Consider the following attempt to fix the race condition:</p>
 <pre>
<code>var dontLetSomeoneElseInPlease = false</code>
<code>func setFullName(firstName: String, lastName: String) {</code>
<code>    guard !dontLetSomeoneElseInPlease else {</code>
<code>        return</code>
<code>    }</code>
<code>    dontLetSomeoneElseInPlease = true</code>
<code>    self.firstName = firstName</code>
<code>    self.lastName = lastName</code>
<code>    dontLetSomeoneElseInPlease = false</code>
<code>}</code>
 </pre>
 <p>Many developers would look at this and think it solves the problem, while in reality, it achieves quite literally nothing. First of all, <b>booleans in Swift are not atomic like in Obj-C</b>, meaning that this code would give you the exact same memory corruption crash you'd have if you didn't have this logic in place. You need to use OS-level synchronization APIs, which we'll mention further below in the article in detail.</p>
 <p>Second of all, even if you <b>did</b> create your own custom <code>AtomicBool</code> class, you'd still not be solving the race condition. While making <code>dontLetSomeoneElseInPlease</code> atomic would result in the boolean <i>itself</i> being thread-safe, that doesn't mean that the <code>Name</code> class <i>as a whole</i> is. What's difficult to grasp here is that thread safety is <b>relative</b>; while something might be thread-safe in relation to itself, it might not be in relation to something else. When evaluating thread safety from the point of view of <code>Name</code>, <code>setFullName</code> is still unsafe because it's still possible for multiple threads to go past the guard check at the same time and cause the same race condition scenario from before.</p>
 <p>To prevent a race condition in the state of the <code>Name</code> class, you need to prevent the <b>entire</b> <code>setFullName</code> logic from running in parallel. Here's one possible way of doing it:</p>
<pre>
<code>var stateLock = NSLock()</code>
<code>func setFullName(firstName: String, lastName: String) {</code>
<code>    stateLock.lock()</code>
<code>    self.firstName = firstName</code>
<code>    self.lastName = lastName</code>
<code>    stateLock.unlock()</code>
<code>}</code>
</pre>
<p>In theoretical terms, what we did by wrapping the logic around calls to <code>lock()</code> and <code>unlock()</code> was to establish a <b>critical region</b> within <code>setFullName</code> which only one thread can access at any given time (a guarantee made by the <code>NSLock</code> API in this case). The logic within <code>setFullName</code> is now thread-safe.</p>
<p>Does this mean that the <code>Name</code> class itself is now thread-safe? <b>It depends on the point of view.</b> While the <code>setFullName</code> method itself is safe from race conditions, we still technically could have a race condition if some external object attempted to read the user's name in parallel with a new name being written. This is why the most important thing for you to keep in mind is the <b>relativity</b> of this problem: While you could say that <code>Name</code> is technically thread-safe in relation to itself, it could very well be the case that whatever class that would be using this in a real application could be doing so in a way that is not. Even the reverse can happen: Although the strings in this example are technically not thread-safe themselves, they are if you consider that they cannot be modified outside <code>setFullName</code>. To fix thread safety issues in the real world, you'll need to first rationalize the problem this way to determine what exactly needs to be made thread-safe in order to fix the problem.</p>
 <h2>Thread Safety costs</h2>
 <p>Before going further, it's good to be aware that any form of synchronization comes with a performance hit, and this hit can sometimes be quite noticeable. On the other hand, I'd argue that this trade-off is always worth it. The worst issues I had to debug were always related to code that is not thread-safe, and because we cannot easily unit-test for it, you never know what kinds of bizarre situations you'll get.</p>
 <p>For that reason, my main tip for you is to stay away from any form of state that can be accessed in parallel in exchange for having a nice and simple atomic serial queue of events. If you truly need to create something that can be used in parallel, then I suggest you put extra effort into understanding all possible usage scenarios. Try to describe every possible bizarre thread scenario that you would need to orchestrate, and what should happen in each of them. If you find this task to be too complicated, then it's possible that your system is too complex to be used in parallel, and having it run serially would save you a lot of trouble.</p>
 <h2>Thread Safety APIs in iOS</h2>
 <h3>Serial DispatchQueues</h3>
 <p>Despite not being generally connected to the topic of thread safety, <code>DispatchQueues</code> are amazing tools for thread safety. By creating a queue of tasks where only one task can be processed at any given time, you are indirectly introducing thread safety to the component that is using the queue.</p>
 <pre>
<code>let queue = DispatchQueue(label: "my-queue", qos: .userInteractive)</code>
<code></code>
<code>queue.async {</code>
<code>    // Critical region 1</code>
<code>}</code>
<code></code>
<code>queue.async {</code>
<code>    // Critical region 2</code>
<code>}</code>
</pre>
 <p>The greatest feature of <code>DispatchQueue</code> is how it completely manages any threading-related tasks like locking and prioritization for you. Apple advises you to never create your own <code>Thread</code> types for resource management reasons -- threads are not cheap, and they must be prioritized between each other. <code>DispatchQueues</code> handle all of that for you, and in the case of a serial queue specifically, the state of the queue itself and the execution order of the tasks will also be managed for you, making it perfect as a thread safety tool.</p>
 <p>Queues, however, are only great if the tasks are meant to be completely asynchronous. If you need to synchronously wait for a task to finish before proceeding, you should probably be using one of the lower-level APIs mentioned below instead. Not only running code synchronously means that we have no use for its threading features, resulting in wasted precious resources, but the <code>DispatchQueue.sync</code> synchronous variant is also a relatively dangerous API as it cannot deal with the fact that you might <b>already</b> be inside the queue:</p>
 <pre>
<code>func logEntered() {</code>
<code>    queue.sync {</code>
<code>        print("Entered!")</code>
<code>    }</code>
<code>}</code>
<code></code>
<code>func logExited() {</code>
<code>    queue.sync {</code>
<code>        print("Exited!")</code>
<code>    }</code>
<code>}</code>
<code></code>
<code>func logLifecycle() {</code>
<code>    queue.sync {</code>
<code>        logEntered()</code>
<code>        print("Running!")</code>
<code>        logExited()</code>
<code>    }</code>
<code>}</code>
<code></code>
<code>logLifecycle() // Crash!</code>
</pre>
 <p>Recursively attempting to <b>synchronously</b> enter the serial <code>DispatchQueue</code> will cause the thread to wait for <i>itself</i> to finish, which doesn't make sense and will result in the app freezing for eternity. This scenario is called a <b>deadlock</b>.</p>
 <p>It's technically possible to fix this, but we will not go into details of that as it's simply not a good idea to use <code>DispatchQueues</code> for synchronous purposes. For synchronous execution, we can have better performance and more predictable safety by using an old-fashioned mutual exclusion (mutex) lock.</p>
 <p>Note: When using <code>DispatchQueues</code>, make sure to follow <a href="https://gist.github.com/tclementdev/6af616354912b0347cdf6db159c37057">these guidelines from @tclementdev</a> in order to use them efficiently.</p>
 <h2>os_unfair_lock</h2>
 <p>The <code>os_unfair_lock</code> mutex is currently the fastest lock in iOS. If your intention is to simply establish a critical region like in our original <code>Name</code> example, then this lock will get the job done with great performance.</p>
 <p><b>Note: Due to how Swift's memory model works, you should never use this API directly. Use the <code>UnfairLock</code> abstraction below when using this lock in your code.</b></p>
 <pre>
<code>// Read http://www.russbishop.net/the-law for more information on why this is necessary</code>
<code>final class UnfairLock {</code>
<code>    private var _lock: UnsafeMutablePointer&lt;os_unfair_lock></code>
<code></code>
<code>    init() {</code>
<code>        _lock = UnsafeMutablePointer&lt;os_unfair_lock>.allocate(capacity: 1)</code>
<code>        _lock.initialize(to: os_unfair_lock())</code>
<code>    }</code>
<code></code>
<code>    deinit {</code>
<code>        _lock.deallocate()</code>
<code>    }</code>
<code></code>
<code>    func locked&lt;ReturnValue>(_ f: () throws -> ReturnValue) rethrows -> ReturnValue {</code>
<code>        os_unfair_lock_lock(_lock)</code>
<code>        defer { os_unfair_lock_unlock(_lock) }</code>
<code>        return try f()</code>
<code>    }</code>
<code>}</code>
<code></code>
<code>let lock = UnfairLock()</code>
<code>lock.locked {</code>
<code>    // Critical region</code>
<code>}</code>
</pre>
 <div class="post-image"> 
  <img src="https://i.imgur.com/VR72J4H.png" alt="Alt"> 
 </div>
 <p>It's not a surprise that it's faster than a <code>DispatchQueue</code> -- despite being low-level C code, the fact that we are not dispatching the code to an entirely different thread is saving us a lot of time.</p>
<p>One very important thing you should be aware of mutexes in iOS is that all of them are <b>unfair</b>. This means that unlike a serial <code>DispatchQueue</code>, locks like <code>os_unfair_lock</code> make no guarantees in terms of the order in which the different threads get to access it. This means that one single thread could theoretically keep acquiring the lock over and over indefinitely and leave the remaining threads waiting in a process referred to as <i>starving</i>. When evaluating locks, you should first determine whether or not this can be a problem in your case.</p>
<p>Note also that this lock specifically <i>also</i> cannot handle the recursion scenario we've shown in the <code>DispatchQueue</code> example. If your critical region is recursive, you'll need to use a <b>recursive lock</b> (shown further below).</p>
 <h2>NSLock</h2>
 <p>Despite also being a mutex, <code>NSLock</code> is different from <code>os_unfair_lock</code> in the sense that it's an Obj-C abstraction for a completely different locking API (<code>pthread_mutex</code>, in this case). While the functionality of locking and unlocking is the same, you might want to choose <code>NSLock</code> over <code>os_unfair_lock</code> for two reasons. The first one is that, well, unlike <code>os_unfair_lock</code>, you can actually use this API without having to abstract it.</p>
 <p>But lastly and perhaps more interestingly, <code>NSLock</code> contains additional features you might find very handy. The one I like the most is the ability to set a <b>timeout</b>:</p>
 <pre>
<code>let nslock = NSLock()</code>
<code></code>
<code>func synchronize(action: () -&gt; Void) {</code>
<code>    if nslock.lock(before: Date().addingTimeInterval(5)) {</code>
<code>        action()</code>
<code>        nslock.unlock()</code>
<code>    } else {</code>
<code>        print("Took to long to lock, did we deadlock?")</code>
<code>        reportPotentialDeadlock() // Raise a non-fatal assertion to the crash reporter</code>
<code>        action() // Continue and hope the user's session won't be corrupted</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>We saw that deadlocking yourself with a <code>DispatchQueue</code> at least will eventually cause the app to crash, but that's not the case with your friendly neighborhood mutexes. If you fall into a deadlock with them, they will do nothing and leave you with a completely unresponsive app. Yikes!</p>
 <p>However, in the case of <code>NSLock</code>, I actually find this to be a good thing. This is because the timeout feature allows you to be smarter and implement your own fallbacks when things don't go as planned; in the case of a potential deadlock, one thing I've done in the past with great success was to report this occurrence to our crash reporter and actually <i>allow the app to proceed</i> as an attempt to not ruin the user's experience with a crash. Note however that the reason why I could gamble on that was that what was being synchronized was purely some innocent client-side logic that doesn't get carried over to the next session. For anything serious and persistent, this would be a horrible thing to do.</p>
 <div class="post-image"> 
  <img src="https://i.imgur.com/CSNvtKc.png" alt="Alt"> 
 </div>
 <p>Despite being the same type of lock as <code>os_unfair_lock</code>, you'll find <code>NSLock</code> to be slightly slower due to the hidden cost of Obj-C's messaging system.</p>
 <h2>NSRecursiveLock</h2>
 <p>If your class is structured in a way where claiming a lock can cause a thread to recursively try to claim it again, you'll need to use a <b>recursive lock</b> to prevent your app from deadlocking. <code>NSRecursiveLock</code> is exactly <code>NSLock</code> but with the additional ability to handle recursion:</p>
 <pre>
<code>let recursiveLock = NSRecursiveLock()</code>
<code></code>
<code>func synchronize(action: () -&gt; Void) {</code>
<code>    recursiveLock.lock()</code>
<code>    action()</code>
<code>    recursiveLock.unlock()</code>
<code>}</code>
<code></code>
<code>func logEntered() {</code>
<code>    synchronize {</code>
<code>        print("Entered!")</code>
<code>    }</code>
<code>}</code>
<code></code>
<code>func logExited() {</code>
<code>    synchronize {</code>
<code>        print("Exited!")</code>
<code>    }</code>
<code>}</code>
<code></code>
<code>func logLifecycle() {</code>
<code>    synchronize {</code>
<code>        logEntered()</code>
<code>        print("Running!")</code>
<code>        logExited()</code>
<code>    }</code>
<code>}</code>
<code></code>
<code>logLifecycle() // No crash!</code>
</pre>
<p>While regular locks will cause a deadlock when recursively attempting to claim the lock in the same thread, a recursive lock allows the owner of the lock to repeatedly claim it again. Because of this additional ability, <code>NSRecursiveLock</code> is slightly slower than the normal <code>NSLock</code>.</p>
 <div class="post-image"> 
  <img src="https://i.imgur.com/2PDjXPQ.png" alt="Alt"> 
 </div>
 <h2>DispatchSemaphore</h2>
 <p>So far we've only looked at the problem of preventing two threads from running conflicting code at the same time, but another very common thread safety issue is when you need one thread to <b>wait</b> until another thread finishes a particular task before it can continue:
<pre>
<code>getUserInformation {</code>
<code>    // Done</code>
<code>}</code>
<code></code>
<code>// Pause the thread until the callback in getUserInformation is called</code>
<code>print("Did finish fetching user information! Proceeding...")</code>
</pre> 
<p>Although this may sound very similar to a lock, you'll find that you cannot implement such a thing with them. This is because what you're looking for here is the <i>opposite</i> of a lock: instead of claiming a region and preventing other threads from doing so, we want to <b>intentionally</b> block ourselves and wait for a completely different thread to release us. This is what a <b>semaphore</b> is for:</p>
<pre>
<code>let semaphore = DispatchSemaphore(value: 0)</code>
<code></code>
<code>mySlowAsynchronousTask {</code>
<code>    semaphore.signal()</code>
<code>}</code>
<code></code>
<code>semaphore.wait()</code>
<code>print("Did finish fetching user information! Proceeding...")</code>
</pre>
 <p>The most common example of a semaphore in iOS is <code>DispatchQueue.sync</code> -- we have some code running in another thread, but we want to wait for it to finish before continuing our thread. The example here is exactly what <code>DispatchQueue.sync</code> does, except we're building the semaphore ourselves.</p>
 <p><code>DispatchSemaphore</code> is generally quick and contains the same features that <code>NSLock</code> has. You can additionally use the <code>value</code> property to control the number of threads that are allowed to go through <code>wait()</code> before they're blocked and <code>signal()</code> has to be called; in this case, a value of 0 means that they will always be blocked.</p>
 <h2>DispatchGroup</h2>
 <p>A <code>DispatchGroup</code> is exactly like a <code>DispatchSemaphore</code>, but for <b>groups</b> of tasks. While a semaphore waits for one event, a group can wait for an infinite number of events:</p>
 <pre>
<code>let group = DispatchGroup()</code>
<code></code>
<code>for _ in 0..&lt;6 {</code>
<code>    group.enter()</code>
<code>    mySlowAsynchronousTask {</code>
<code>        group.leave()</code>
<code>    }</code>
<code>}</code>
<code></code>
<code>group.wait()</code>
<code>print("ALL tasks done!")</code>
</pre>
 <p>In this case, the thread will only be unlocked when <b>all</b> 6 tasks have finished.</p>
 <p>One really neat feature of <code>DispatchGroups</code> is that you have the additional ability to wait <b>asynchronously</b> by calling <code>group.notify</code>:</p>
 <pre>
<code>group.notify(queue: .main) {</code>
<code>    print("ALL tasks done!")</code>
<code>}</code>
</pre>
 <p>This lets you be notified of the result in a <code>DispatchQueue</code> instead of blocking the thread, which can be extremely useful if you don't need the result synchronously.</p>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>Because of the group mechanism, you'll find groups to be usually slower than plain semaphores:</p>
 <div class="post-image"> 
  <img src="https://i.imgur.com/V1S7N2y.png" alt="Alt"> 
 </div>
 <p>This means you should generally use <code>DispatchSemaphore</code> if you're only waiting for a single event, but in practice, the presence of the <code>notify</code> API makes a lot of people use <code>DispatchGroups</code> for individual events as well.</p>
 <h2>Async/Await</h2>
 <p>After this article was originally published, many readers messaged me with a very relevant question: <b>what about actors and async/await?</b></p>
<p>As insightfully noticed by you, these are <i>also</i> thread safety tools worth mentioning. Features like <b>Actors</b> have the same objective of synchronizing threads as the APIs we've seen, but because they're compiler-level abstractions, they are considerably <b>more powerful</b> than the manual APIs. We've gone through these advantages in detail in our article about <a href="https://swiftrocks.com/how-actors-work-internally-in-swift">how Actors work inside the Swift compiler</a>, but one specific advantage worth re-mentioning is that unlike the APIs, <b>actors are able to detect race conditions during compilation time.</b></p>
<p>One frustrating disadvantage of these features however is that you <b>cannot use them outside of async/await environments</b>, making them unfit for the majority of Swift projects at the moment. If you're one of the lucky few that don't have this constraint, these can prove to be amazing tools for solving thread safety issues in your projects.</p>
<p>I have to admit though that I'm not a huge fan of async/await, so I'm wary of suggesting that you should actually use this feature. I have a feeling that it in its current state makes the concept of running async code unnecessarily complicated and over-engineered, and long-time SwiftRocks readers will notice that I always advocate for keeping things as simple as possible. It's a fact however that Apple is continuously improving this feature and its APIs, so you can expect this paragraph to be revisited in the future.</p>
</div></div>
                              
   

    <div class="blog-post" style="margin-top: 8px; margin-bottom: 32px;">
      <div class="footer-text">
        Thanks for reading! If you want to see more content like this, follow me on <a href="https://twitter.com/rockbruno_">Twitter!</a>
        <ul>
          <li>        <a href="https://twitter.com/intent/tweet?via=rockbruno_&hashtags=swiftrocks,ios,swiftlang&url=https%3A%2F%2Fswiftrocks.com%2Fthread-safety-in-swift&text=Thread Safety in Swift" target="_blank" class="share">Share this page</a> on Twitter</li>
          <li>Subscribe via <a href="https://swiftrocks.com/rss.xml">RSS</a> or <a href="https://swiftrocks.us17.list-manage.com/subscribe/post?u=d6bdd39e59b8d9b8f2b8d4852&id=cbca5f3532">e-mail</a></li>
        </ul>
        <a href="https://swiftrocks.com">See all articles</a>
      </div>

    </div>

                         </div>

</div>
                        
                           
                         </div>
                     
                     
                  </div>
                  <!-- Blog Post (Right Sidebar) End -->
                
            </div>
         </div>
      </div>
    
    
    <!-- All Javascript Plugins  -->
  <script type="text/javascript" src="js/jquery.min.js"></script> 
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM" crossorigin="anonymous"></script>
  <script type="text/javascript" src="js/prism3.js"></script> 
    <!-- Main Javascript File  -->
    <script type="text/javascript" src="js/scripts26.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-130406165-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-130406165-1');
</script>

   </body>
 </html>
