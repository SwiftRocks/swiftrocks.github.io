<!DOCTYPE html>
<html lang="en">

  <head>

    <script src="https://use.fontawesome.com/afd448ce82.js"></script>
    
    <!-- Meta Tag -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    
    <!-- SEO -->
    <meta name="author" content="Bruno Rocha">
    <meta name="keywords" content="iOS, Xcode, Swift, Articles, Tutorials, OBJ-C, Objective-C, Apple">
    <meta name="description" content="As (possibly) a response to jailbreaking become popular again in recent times, Apple has released their own solution to hackers creating compromised versions of your app.">
    <meta name="title" content="App Attest: How to prevent an iOS app's APIs from being abused">
    <meta name="url" content="https://swiftrocks.com/app-attest-apple-protect-ios-jailbreak">
    <meta name="image" content="https://swiftrocks.com/images/thumbs/app-attest-apple-protect-ios-jailbreak.jpg?3">
    <meta name="copyright" content="Bruno Rocha">
    <meta name="robots" content="index,follow">

    <meta property="og:title" content="App Attest: How to prevent an iOS app's APIs from being abused"/>
    <meta property="og:image" content="https://swiftrocks.com/images/thumbs/app-attest-apple-protect-ios-jailbreak.jpg?3"/>
    <meta property="og:description" content="As (possibly) a response to jailbreaking become popular again in recent times, Apple has released their own solution to hackers creating compromised versions of your app."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://swiftrocks.com/app-attest-apple-protect-ios-jailbreak"/>

    <meta name="twitter:card" content="summary_large_image"/>
    <meta name="twitter:image" content="https://swiftrocks.com/images/thumbs/app-attest-apple-protect-ios-jailbreak.jpg?3"/>
    <meta name="twitter:image:alt" content="Page Thumbnail"/>
    <meta name="twitter:title" content="App Attest: How to prevent an iOS app's APIs from being abused"/>
    <meta name="twitter:description" content="As (possibly) a response to jailbreaking become popular again in recent times, Apple has released their own solution to hackers creating compromised versions of your app."/>
    <meta name="twitter:site" content="@rockbruno_"/>
    
    <!-- Favicon -->
    <link rel="shortcut icon" href="images/favicon/favicon-2.ico">
    <link rel="mask-icon" href="images/favicon/favicon-2.ico">
    <link rel="apple-touch-icon" href="images/favicon/apple-touch-icon.png">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:light,lightitalic,regular,regularitalic,medium,mediumitalic,bold,bolditalic,black,blackitalic">
    
  <!-- Bootstrap CSS Plugins --> 
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
  <!-- Prism CSS Stylesheet --> 
  <link rel="stylesheet" type="text/css" href="css/prism3.css"> 
  <!-- Main CSS Stylesheet --> 
  <link rel="stylesheet" type="text/css" href="css/style42.css"> 
  <link rel="stylesheet" type="text/css" href="css/sponsor2.css">
    
    <!-- HTML5 shiv and Respond.js support IE8 or Older for HTML5 elements and media queries -->
    <!--[if lt IE 9]>
	   <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
	   <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->

  <script type="application/ld+json">
  {
"@context": "https://schema.org",
"@type": "BlogPosting",
"mainEntityOfPage": {
  "@type": "WebPage",
  "@id": "https://swiftrocks.com/app-attest-apple-protect-ios-jailbreak"
},
"image": [
  "https://swiftrocks.com/images/bg/swiftrockssocial.png"
],
"datePublished": "2020-08-11T14:00:00+02:00",
"dateModified": "2020-08-11T14:00:00+02:00",
"author": {
  "@type": "Person",
  "name": "Bruno Rocha"
},
 "publisher": {
  "@type": "Organization",
  "name": "SwiftRocks",
  "logo": {
    "@type": "ImageObject",
    "url": "https://swiftrocks.com/images/bg/swiftrockssocial.png"
  }
},
"headline": "App Attest: How to prevent an iOS app's APIs from being abused",
    "abstract": "As (possibly) a response to jailbreaking become popular again in recent times, Apple has released their own solution to hackers creating compromised versions of your app."
}
  </script>
    

  </head>

 <body>
      
    
    
     
    
    
  <div id="main"> 
<!-- Blog Header --> 
      <div class="blog-header-container" style="width: 100%">
         <div style="display: flex; justify-content: center;"><a href="https://swiftrocks.com">
           <img id="logo" alt="SwiftRocks" src="images/bg/swiftrockswithtextdarkmode2.png" style="margin-top: 32px; margin-left: 32px; margin-right: 32px; max-width: calc(100% - 64px); width: auto; height: auto;"> 
         </a></div>
         <div style="margin-top: 15px; display: flex; justify-content: center;">
           <p class="blog-header-text">A blog about <b style="color: white;">how Swift works</b> and <b style="color: white;">iOS tricks</b>, by <a href="https://twitter.com/rockbruno_">Bruno Rocha</a>.</p>
         </div>
          <div class="blog-header-button-container">
          <div class="blog-header-button">
               <a href="https://twitter.com/rockbruno_" target="_blank" style="display: flex;">
                  <i class="fa fa-twitter"></i>
                  <div class="blog-header-button-follow-shape"></div>
                  <div class="blog-header-button-follow">5570<div class="blog-header-button-follow-verbose"> followers</div>!</div>
               </a>
          </div>
          <div class="blog-header-button">
               <a href="rss.xml" target="_blank">
                  <i class="fa fa-rss"></i>
               </a>
          </div>
          <div class="blog-header-button">
               <a href="mailto:rockbruno@rockbruno.com" target="_blank">
                  <i class="fa fa-envelope"></i>
               </a>
          </div>
          <div class="blog-header-button">
               <a href="https://github.com/rockbruno" target="_blank">
                  <i class="fa fa-github"></i>
               </a>
          </div>
<!--           <div class="blog-header-button">
               <a href="sponsor-advertise-at-swiftrocks">
                  <div class="blog-header-button-sponsor">Sponsor</div>
               </a>
          </div> -->
         </div>
     </div>
         <!-- Blog Post (Right Sidebar) Start --> 
   <div class="container"> 
                 <div class="col-xs-12">
                    <div class="page-body">
                    	<div class="row">

 <!-- Mailchimp -->
  <div id="mc_embed_signup">
  <div style="display:flex; justify-content: center;">
  <p style="font-weight: 100; font-size: 16px; text-align: center;">Articles about advanced Swift development in excruciating detail, for free!</p>
  </div>
  <form action="https://swiftrocks.us17.list-manage.com/subscribe/post?u=d6bdd39e59b8d9b8f2b8d4852&amp;id=cbca5f3532" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" style="padding: 0;" novalidate>
      <div id="mc_embed_signup_scroll">
    
    <input type="email" value="" name="EMAIL" class="email" id="mce-EMAIL" placeholder="Your email address" required>
      <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->
      <div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_d6bdd39e59b8d9b8f2b8d4852_cbca5f3532" tabindex="-1" value=""></div>
      <div class="clear"><input type="submit" value="Notify me of new posts" name="subscribe" id="mc-embedded-subscribe" class="button"></div>
      </div>
  </form>
  </div>
  <!-- Mailchimp End -->

                            <div class="content-page" id="WRITEIT_DYNAMIC_CONTENT">
 
  
  <!--WRITEIT_POST_NAME=App Attest: How to prevent an iOS app's APIs from being abused--> 
  <!--WRITEIT_POST_HTML_NAME=app-attest-apple-protect-ios-jailbreak--> 
  <!--Add here the additional properties that you want each page to possess.--> 
  <!--These properties can be used to change content in the template page or in the page itself as shown here.--> 
  <!--Properties must start with 'WRITEIT_POST'.--> 
  <!--Writeit provides and injects WRITEIT_POST_NAME and WRITEIT_POST_HTML_NAME by default.--> 
  <!--WRITEIT_POST_SHORT_DESCRIPTION=As (possibly) a response to jailbreaking become popular again in recent times, Apple has released their own solution to hackers creating compromised versions of your app.--> 
  <!--WRITEIT_POST_SITEMAP_DATE_LAST_MOD=2020-08-11T14:00:00+02:00--> 
  <!--WRITEIT_POST_SITEMAP_DATE=2020-08-11T14:00:00+02:00--> 
  <title>App Attest: How to prevent an iOS app's APIs from being abused</title>  
 

<div class="blog-post"> 
 <div class="post-title-index">  
  <h1>App Attest: How to prevent an iOS app's APIs from being abused</h1>
 </div> 
 <div class="post-info"> 
  <div class="category category-ios">
   iOS
  </div> 
  <div class="post-info-text">
   Published on 11 Aug 2020 
  </div> 
 </div>   
 <p>When jailbreaking of iOS devices first became popular, it was very common for iOS developers to try to defend their apps from users that altered their devices to enable piracy. There were many ways of doing that, which included checking for the existence of <b>Cydia</b>, checking if the app could read files outside its sandbox, crashing the app if it detects a debugger and more.</p>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>As time has shown, these "defensive" measures were and still are a really <b>bad</b> idea. If an attacker has physical access to the device, there's <b>no way</b> you can trust your app's logic. It was and still is trivial for hackers to "pretend" their devices were not jailbroken and effectively bypass these measures, and besides, having a jailbroken device doesn't mean the user wants to pirate content -- some people just want to have cooler looking home screens.</p>
 <p>As (possibly) a response to jailbreaking become popular again in recent times, Apple has released their own measure to this problem. In iOS 14, the new <b>App Attest</b> APIs provide you a way to sign server requests as an attempt to prove to your server that they came from an <b>unmodified</b> version of your app.</p>
 <p>It's important to know that <b>App Attest is not a "is this device jailbroken?" check</b>, as that has been proven over and over to be impossible to pinpoint. Instead, it aims to <b>protect server requests</b> in order to make it harder for hackers to create compromised versions of your app that unlock premium features or inserts features like cheats, while also adding a layer of protection against <b>replay attacks</b> against your server's APIs. Note the word <b>harder</b>: as jailbreakers have physical access to their devices, nothing will <b>completely</b> safe-guard you from fraud in this case.</p>
 <p>As you can't trust your app to protect itself, App Attest requires work on your backend to be fully implemented. I won't go through the backend part of it as this is a Swift blog, but will at least mention how it works to show how it wrap things together.</p>
 <h2>Generating a pair of keys to sign requests</h2>
 <p>App Attest works through the use of an asymmetric public/secret pair of encryption keys. The intention, in the end, is for your app to sign server requests with the secret key, send the data to the backend and have it confirm it to be true with the public one. If a hacker intercepts the request, it will not be able to alter its contents without making the backend's subsequent validation fail.</p>
 <p>To generate the keys, import the <code>DeviceCheck</code> framework and call the <code>generateKey</code> method from the <code>DCAppAttestService</code> singleton:</p>
 <pre>
<code>import DeviceCheck</code>
<code></code>
<code>let service = DCAppAttestService.shared</code>
<code>service.generateKey { (keyIdentifier, error) in</code>
<code>    guard error == nil else {</code>
<code>        return</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>The keys generated by App Attest are safely stored in your device's Security Enclave. As you can't directly access it, the result of this method will be a <code>keyIdentifier</code> property that allows iOS to find the keys when needed. You need to store it so you can later validate your app's requests.</p>
 <p>It's important to mention that App Attest is not supported by <b>all</b> types of devices, and if you look at Apple's own documentation, they will ask you to first check if it's supported and have your server support a fallback in case it's not:</p>
 <pre>
<code>if service.isSupported { ... }</code>
</pre>
 <p><b>Do not do this!</b> As said before, it's trivial for a jailbreak user to "pretend" their device doesn't support it. Apple doesn't expand on this topic, but the reasons for this check to exist appears to be that there are some Macbooks that don't have the necessary chip to support it. However, <a href="https://twitter.com/_inside/status/1291810797782544386">as investigated by Guilherme Rambo, it appears that every single iOS device supports it.</a> For an iOS app, you do not need to do a compatibility check.</p>
 <h2>Attesting: Sending the public key to the backend</h2>
 <p>In order to sign server requests, you need to provide your backend with a way to <b>confirm</b> that signature. This is done by giving the backend access to the public key we previously generated, but we can't simply create a request and add it as a parameter because it would be pretty easy for a hacker to intercept it and send their <b>own</b> public key instead, giving them full control of what your app sends to the backend.</p>
 <p>The solution to this problem is to ask Apple to <b>attest</b> that what the key we're sending originated from a uncompromised version of your app. This is done by calling the <code>attestKey</code> method, which receives the key's identifier as a parameter:</p>
 <pre>
<code>service.attestKey(keyIdentifier, clientDataHash: hash) { attestation, error in</code>
<code>    guard error == nil else { return }</code>
<code>    let attestationString = attestation?.base64EncodedString()</code>
<code>    // Send the attestation to the server. It now has access to the public key!</code>
<code>    // If it fails, throw the identifier away and start over.</code>
<code>}</code>
</pre>
 <p>This method accesses a remote Apple server, and the result is an "attestation" object that contains not only your public key, but a ton of information about your app that serves as a statement from Apple that the previously generated keys are not fake. When you receive this object, you must send it to your backend and have it perform several validations on it that allows it to confirm that it was unaltered. If the attestation object was successfully validated, the backend will be able to safely extract the app's public key from it.</p>
 <p>It's unclear if Apple attempts or not to check if the user's device if jailbroken during this process. It's never mentioned that this is the case, but they do say "App Attest can’t <b>definitively</b> pinpoint a device with a compromised operating system." which could imply that they at least <b>try</b> something. It's probably safe to assume that this is not the case, and the word attest here simply means that your request (probably) wasn't intercepted and modified.</p>
 <p>The additional <code>clientDataHash</code> parameter of the attestation request is not related to the attestation process itself, but extremely important for it to make it safe. As it is, this request is susceptible to a <b>replay attack</b> where a hacker could intercept the validation request and steal the attestation object sent from Apple so that later they can "replay" the same validation request at a fake version of your app to make the server believe it came from the real one.</p>
 <p>A solution to this problem is to simply not allow the validation request to be executed freely. Instead, the client can provide a one-time use token (or session ID) that the server will expect to accompany the request to ensure its validity. If the same token is used twice, the request will fail. That's what <code>clientDataHash</code> is for: By providing a hashed version of that expected token to the attestation request, Apple will embed it into the final object and provide your server a way to extract it. With this, it's pretty hard for a hacker to create a compromised version of your app by simply intercepting requests.</p>
 <pre>
<code>let challenge = getSessionId().data(using: .utf8)!</code>
<code>let hash = Data(SHA256.hash(data: challenge))</code>
<code>service.attestKey(keyIdentifier, clientDataHash: hash) { ... }</code>
</pre>
 <p>As mentioned earlier, Apple suggests you to not reuse keys. You should do this entire process for each user account in a device.</p>
 <p>Because this request relies on a remote Apple server, it's possible for it to fail. If the error is that the server was unavailable, Apple says that you can simply try again, but if it's anything else, you should <b>discard</b> the key identifier and start over. This can happen for example when a user reinstalls your app -- The keys that you generate remain valid through regular app updates, but don’t survive app reinstallation, device migration, or restoration of a device from a backup. For these cases, your app needs to be able to restart the key generation process.</p>
 <p>From the server side of things, it's also interesting to mention that the statement object also contains a receipt that your server can use to request fraud assessment metrics from Apple. This allows you to check the number of generated keys and the devices that they have been associated to detect possible cases of fraud. Apple specifically mentions the possibility of an attack where a user could use one device to provide valid assertions to compromised devices, which can be detected by this fraud assessment by locating users with unusually high amounts of assertion requests.</p>
 <h2>Wrapping it up: Encrypting Server Requests</h2>
 <p>After attesting the validity of the key, your backend will have access to the public key. From now on, every time you're dealing with sensitive content, you have the ability to safely sign that request. The <code>generateAssertion</code> method used for this works very similarly to the attestation of the keys, except this time you're attesting the request itself:</p>
 <pre>
<code>let challenge = getSessionId().data(using: .utf8)!</code>
<code>let requestJSON = "{ 'requestedPremiumLevel': 300, 'sessionId': '\(challenge)' }".data(using: .utf8)!</code>
<code>let hash = Data(SHA256.hash(data: requestJSON))</code>
<code>service.generateAssertion(keyIdentifier, clientDataHash: hash) { assertion, error in</code>
<code>    guard error == nil else { return }</code>
<code>    let assertionString = assertion?.base64EncodedString()</code>
<code>    // Send the signed assertion to your server.</code>
<code>    // The server will validate it, grab your request and process it.</code>
<code>}</code>
</pre>
 <p>Just like before, your backend must support the usage of a one-time token to prevent replay attacks. This time, since the request itself is our <code>clientDataHash</code>, we're adding the token inside the JSON. There's no restriction on the number of assertions that you can make with a given key, but still, you typically should reserve that for requests made at sensitive moments of your app such as the download of premium content.</p>
 <p>In this case, your additional protection comes from the fact that the request is hashed and usable only once. Because the entire request is signed by your private key, a hacker can't simply intercept your requests and use them to craft their own. They must figure out where the parameters of your request are coming from and manually attempt to sign it, something that will take slightly more skill than simply attaching a proxy. As mentioned in the beginning, it's not impossible to break this protection, just harder.</p>
 <h2>Testing and rolling out your implementation</h2>
 <p>The App Attest service records metrics that you can't reset. To prevent that, apps not in a production environment will use a sandboxed version of it. If you instead want to test in the production environment, you should add the <b>com.apple.developer.devicecheck.appattest-environment</b> entitlement to your app and set its value to <b>production</b>.</p>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>If you have a large user base, Apple recommends you to gradually roll this feature as requests to <code>attestKey</code> are rate limited. After carefully rolling it out for existing users, you can guarantee that it will only be called for new users.</p>
 <h2>Conclusion</h2>
 <p>By implementing this in your client and in your backend, it should become harder for hackers to abuse your server's APIs. However, be aware of the word <b>harder</b> -- it doesn't mean impossible! As mentioned before, there's no sure way for you to detect if a user has a jailbroken device, and even fewer ways to prevent them from attacking your app. As with most security measures, the intention of App Attest is instead to make this process <b>difficult enough</b> so that only a very skilled and dedicated hacker would be able to find a way to break into your app -- someone much harder to come by.</p>
 <h2>References and Good Reads</h2>
 <a href="https://developer.apple.com/documentation/devicecheck">Official App Attest Docs covering the Backend implementation</a>
 <br>
</div></div>
                              
   

    <div class="blog-post" style="margin-top: 16px;">
      <div class="footer-text">
        <p>Thanks for reading! If you want to see more Swift / iOS content like this, follow me on <a href="https://twitter.com/rockbruno_">Twitter!</a></p>
        <div class="footer-share">
        <a href="https://twitter.com/intent/tweet?via=rockbruno_&hashtags=swiftrocks,ios,swiftlang&url=https%3A%2F%2Fswiftrocks.com%2Fapp-attest-apple-protect-ios-jailbreak&text=App Attest: How to prevent an iOS app's APIs from being abused" target="_blank" class="share" style="font-size: 18px;"><i class="fa fa-twitter"></i>‏‏‎ ‎‏‏‎ ‎‏‏‎ ‎Share this page on Twitter</a>
        </div>
      </div>
    <!-- Mailchimp -->
  <div id="mc_embed_signup" style="border-top: 1px solid black; padding-top: 32px;">
  <div style="display:flex; justify-content: center; text-align: center;">
  <p style="font-weight: 100; font-size: 16px;">Articles about advanced Swift development in excruciating detail, for free!</p>
  </div>
  <form action="https://swiftrocks.us17.list-manage.com/subscribe/post?u=d6bdd39e59b8d9b8f2b8d4852&amp;id=cbca5f3532" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" style="padding: 0;" novalidate>
      <div id="mc_embed_signup_scroll">
    
    <input type="email" value="" name="EMAIL" class="email" id="mce-EMAIL" placeholder="Your email address" required>
      <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->
      <div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_d6bdd39e59b8d9b8f2b8d4852_cbca5f3532" tabindex="-1" value=""></div>
      <div class="clear"><input type="submit" value="Notify me of new posts" name="subscribe" id="mc-embedded-subscribe" class="button"></div>
      </div>
  </form>
  </div>
  <!-- Mailchimp End -->
    <div class="copyright">
    <text>Copyright © 2016-2021 SwiftRocks.</text>
    <text><a href="https://swiftrocks.com">Index</a> | <a href="sponsor-advertise-at-swiftrocks">Sponsor</a></text>
    </div>

    </div>

                         </div>

</div>
                        
                           
                         </div>
                     
                     
                  </div>
                  <!-- Blog Post (Right Sidebar) End -->
                
            </div>
         </div>
      </div>
    
    
    <!-- All Javascript Plugins  -->
  <script type="text/javascript" src="js/jquery.min.js"></script> 
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM" crossorigin="anonymous"></script>
  <script type="text/javascript" src="js/prism3.js"></script> 
    <!-- Main Javascript File  -->
    <script type="text/javascript" src="js/scripts25.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-130406165-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-130406165-1');
</script>

   </body>
 </html>
