<!DOCTYPE html>
<html lang="en">

  <head>

    <script src="https://use.fontawesome.com/afd448ce82.js"></script>
    
    <!-- Meta Tag -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    
    <!-- SEO -->
    <meta name="author" content="Bruno Rocha">
    <meta name="keywords" content="iOS, Xcode, Swift, Articles, Tutorials, OBJ-C, Objective-C, Apple">
    <meta name="description" content="In this article, we'll introduce the field of algorithms and data structures in a neutral way, show how this knowledge is applied in practice using an analogy, and finally use all of that to clarify why large companies like Google and Apple are so focused on it.">
    <meta name="title" content="How necessary are the programming fundamentals?">
    <meta name="url" content="https://swiftrocks.com/how-necessary-are-the-programming-fundamentals">
    <meta name="image" content="https://swiftrocks.com/images/thumbs/how-necessary-are-the-programming-fundamentals.jpg?3">
    <meta name="copyright" content="Bruno Rocha">
    <meta name="robots" content="index,follow">

    <meta property="og:title" content="How necessary are the programming fundamentals?"/>
    <meta property="og:image" content="https://swiftrocks.com/images/thumbs/how-necessary-are-the-programming-fundamentals.jpg?3"/>
    <meta property="og:description" content="In this article, we'll introduce the field of algorithms and data structures in a neutral way, show how this knowledge is applied in practice using an analogy, and finally use all of that to clarify why large companies like Google and Apple are so focused on it."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://swiftrocks.com/how-necessary-are-the-programming-fundamentals"/>

    <meta name="twitter:card" content="summary_large_image"/>
    <meta name="twitter:image" content="https://swiftrocks.com/images/thumbs/how-necessary-are-the-programming-fundamentals.jpg?3"/>
    <meta name="twitter:image:alt" content="Page Thumbnail"/>
    <meta name="twitter:title" content="How necessary are the programming fundamentals?"/>
    <meta name="twitter:description" content="In this article, we'll introduce the field of algorithms and data structures in a neutral way, show how this knowledge is applied in practice using an analogy, and finally use all of that to clarify why large companies like Google and Apple are so focused on it."/>
    <meta name="twitter:site" content="@rockbruno_"/>
    
    <!-- Favicon -->
    <link rel="shortcut icon" href="images/favicon/favicon-2.ico">
    <link rel="mask-icon" href="images/favicon/favicon-2.ico">
    <link rel="apple-touch-icon" href="images/favicon/apple-touch-icon.png">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:light,lightitalic,regular,regularitalic,medium,mediumitalic,bold,bolditalic,black,blackitalic">
    
    

  <!-- Bootstrap CSS Plugins --> 
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
  <!-- Prism CSS Stylesheet --> 
  <link rel="stylesheet" type="text/css" href="css/prism3.css"> 
  <!-- Main CSS Stylesheet --> 
  <link rel="stylesheet" type="text/css" href="css/style42.css"> 
  <link rel="stylesheet" type="text/css" href="css/sponsor2.css">
    
    <!-- HTML5 shiv and Respond.js support IE8 or Older for HTML5 elements and media queries -->
    <!--[if lt IE 9]>
	   <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
	   <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->

  <script type="application/ld+json">
  {
"@context": "https://schema.org",
"@type": "BlogPosting",
"mainEntityOfPage": {
  "@type": "WebPage",
  "@id": "https://swiftrocks.com/how-necessary-are-the-programming-fundamentals"
},
"image": [
  "https://swiftrocks.com.com/images/logo/logo.png"
],
"datePublished": "2021-05-18T14:00:00+02:00",
"dateModified": "2021-05-20T23:00:00+02:00",
"author": {
  "@type": "Person",
  "name": "Bruno Rocha"
},
 "publisher": {
  "@type": "Organization",
  "name": "SwiftRocks",
  "logo": {
    "@type": "ImageObject",
    "url": "https://swiftrocks.com.com/images/logo/logo.png"
  }
},
"headline": "How necessary are the programming fundamentals?",
    "abstract": "In this article, we'll introduce the field of algorithms and data structures in a neutral way, show how this knowledge is applied in practice using an analogy, and finally use all of that to clarify why large companies like Google and Apple are so focused on it."
}
  </script>
    

  </head>

 <body>
      
    
    
     
    
    
  <div id="main"> 
<!-- Blog Header --> 
      <div class="blog-header-container" style="width: 100%">
         <div style="display: flex; justify-content: center;"><a href="https://swiftrocks.com">
           <img id="logo" alt="SwiftRocks" src="images/bg/swiftrockswithtextdarkmode2.png" style="margin-top: 32px; margin-left: 32px; margin-right: 32px; max-width: calc(100% - 64px); width: auto; height: auto;"> 
         </a></div>
         <div style="margin-top: 15px; display: flex; justify-content: center;">
           <p class="blog-header-text">A blog about <b style="color: white;">how Swift works</b> and <b style="color: white;">iOS tricks</b>, by Bruno Rocha.</p>
         </div>
          <div class="blog-header-button-container">
          <div class="blog-header-button">
               <a href="https://twitter.com/rockbruno_" target="_blank" style="display: flex;">
                  <i class="fa fa-twitter"></i>
<!--                   <div class="blog-header-button-follow-shape"></div>
                  <div class="blog-header-button-follow">5570<div class="blog-header-button-follow-verbose"> followers</div>!</div> -->
               </a>
          </div>
          <div class="blog-header-button">
               <a href="rss.xml" target="_blank">
                  <i class="fa fa-rss"></i>
               </a>
          </div>
          <div class="blog-header-button">
               <a href="mailto:rockbruno@rockbruno.com" target="_blank">
                  <i class="fa fa-envelope"></i>
               </a>
          </div>
          <div class="blog-header-button">
               <a href="https://www.linkedin.com/in/bruno-rocha-45786a98/" target="_blank">
                  <i class="fa fa-linkedin"></i>
               </a>
          </div>
<!--           <div class="blog-header-button">
               <a href="sponsor-advertise-at-swiftrocks">
                  <div class="blog-header-button-sponsor">Sponsor</div>
               </a>
          </div> -->
         </div>
     </div>
         <!-- Blog Post (Right Sidebar) Start --> 
   <div class="container"> 
                 <div class="col-xs-12">
                    <div class="page-body">
                    	<div class="row">

 <!-- Mailchimp -->
  <div id="mc_embed_signup">
  <div style="display:flex; justify-content: center;">
  <p style="font-weight: 100; font-size: 16px; text-align: center;">Articles about advanced Swift development in excruciating detail, for free!</p>
  </div>
  <form action="https://swiftrocks.us17.list-manage.com/subscribe/post?u=d6bdd39e59b8d9b8f2b8d4852&amp;id=cbca5f3532" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" style="padding: 0;" novalidate>
      <div id="mc_embed_signup_scroll">
    
    <input type="email" value="" name="EMAIL" class="email" id="mce-EMAIL" placeholder="Your email address" required>
      <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->
      <div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_d6bdd39e59b8d9b8f2b8d4852_cbca5f3532" tabindex="-1" value=""></div>
      <div class="clear"><input type="submit" value="Notify me of new posts" name="subscribe" id="mc-embedded-subscribe" class="button"></div>
      </div>
  </form>
  </div>
  <!-- Mailchimp End -->

                            <div class="content-page" id="WRITEIT_DYNAMIC_CONTENT">
 
  
  <!--WRITEIT_POST_NAME=How necessary are the programming fundamentals?--> 
  <!--WRITEIT_POST_HTML_NAME=how-necessary-are-the-programming-fundamentals--> 
  <!--Add here the additional properties that you want each page to possess.--> 
  <!--These properties can be used to change content in the template page or in the page itself as shown here.--> 
  <!--Properties must start with 'WRITEIT_POST'.--> 
  <!--Writeit provides and injects WRITEIT_POST_NAME and WRITEIT_POST_HTML_NAME by default.--> 
  <!--WRITEIT_POST_SHORT_DESCRIPTION=In this article, we'll introduce the field of algorithms and data structures in a neutral way, show how this knowledge is applied in practice using an analogy, and finally use all of that to clarify why large companies like Google and Apple are so focused on it.--> 
  <!--DateFormat example: 2021-05-18T14:00:00+02:00--> 
  <!--WRITEIT_POST_SITEMAP_DATE_LAST_MOD=2021-05-20T23:00:00+02:00--> 
  <!--WRITEIT_POST_SITEMAP_DATE=2021-05-18T14:00:00+02:00--> 

  <title>How necessary are the programming fundamentals?</title> 


<div class="blog-post"> 
 <div class="post-title-index">  
  <h1>How necessary are the programming fundamentals?</h1>
 </div> 
 <div class="post-info"> 
  <div class="category category-theory">
   Theory
  </div> 
  <div class="post-info-text">
   Published on 18 May 2021 <b>(Reworked on 15 Jun 2022)</b>
  </div> 
 </div>   
 <p>I've been meaning to write an article about computer science fundamentals and how it can improve a programmer's career for a long time, but I always had trouble finding a good way of introducing this topic. The reason I'd like to talk about this is first that, well, I really like this field and I feel that most of my programming ability today is a result of having studied this, but also because I feel like there's a lot of misinformation around this topic and I've been hoping I could address that in a way that could be convincing even for those who can't stand hearing the word "algorithms" anymore.</p>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>The context, for those who are unaware, is that part of the tech community <i>despises</i> this topic so much that they actively fight against it. The reason for that is due to how the interview process of large companies like Google is shaped; When regular-sized companies hire programmers, they usually look for people to perform a specific role on a specific platform (for example, iOS Developer). In this case, it's very common for the interview processes to focus on the <i>practical</i> aspects of these platforms, such as understanding how the platform works, the details of certain APIs, and the person's overall ability to work with that specific platform.</p>
 <p>Traditional large companies, however, focus more on the <i>theory</i> of programming, asking questions not about what you can do in a specific platform, but about your understanding of the building blocks that allow such platforms to exist in the first place. This includes understanding the functionality of basic data structures like <code>Arrays</code> and <code>Sets</code>, your ability to predict, often in an academic fashion, the performance of your code, and your knowledge of fundamental algorithms like a binary search in the shape of a programming puzzle. The knowledge used in those puzzles comes from a field that has multiple names, with the most common ones being <i>Algorithms and Data Structures</i> and <i>CS Fundamentals</i>.</p>
 <p>The thing though is that these companies tend to run puzzles that are <b>so hard</b> that not even extremely competent engineers are able to answer them. They often require you to have extensive knowledge of very specific pieces of theory that are almost always completely unrelated to the position being interviewed for, and while people used to be relatively unbothered by this in a past where we had way fewer layers of abstractions and the only way you could learn engineering was by going to a traditional college that would quite literally force you to study those concepts, this practice became considered unfair and outdated in the modern world where most people tend to learn from bootcamps and work with way higher layers of abstractions, and is now heavily frowned upon by the tech community.</p>
 <p><i>Bruno, it looks like you agree that this is an outdated practice. So what is it that needs to be addressed?</i></p>
 <p>The problem is that I believe <b>the community tends to misplace this hate</b> in dangerous ways. The negativity around this interview format became so large that you can now often find the community bashing computer science theory <i>itself</i>, even though it has nothing to do with the bad practices of these companies. The consequence of that is that nowadays it can be very hard to mention a programming concept at an abstract level without the conversation immediately derailing into a flame war about LeetCode and interviews, which is something I believe to be hurtful not just for these conversations, but also for the individual careers of engineers who are being led to believe that they should stay away from these concepts for reasons that don't make sense.</p>
 <p><b>I believe it's very important for the community to separate the knowledge from the interviews,</b> and I'd like to use this article as an attempt to solve this misunderstanding. I'd like to first introduce you to the field of algorithms and data structures, show how this knowledge is applied in practice using an analogy, and then finally use that information to clarify <b>why</b> large companies care about this knowledge (despite the fact that they unfortunately do it very badly). I hope that this will give you the tools to separate in your head the field itself from these companies' bad practices, allowing you to not only understand why this knowledge can be useful, but also to help you determine if this is something you should be studying to achieve your personal goals.</p>
 <h2>Separating the knowledge from the bad practices</h2>
 <p>Here are some common complaint points you hear in discussions about fundamentals:</p>
 <ul> 
  <li>Theory doesn't reflect what the person will actually do in their job.</li> 
  <li>Knowledge of the theory is not indicative of the person's skill in a given practical role.</li> 
  <li>Theory, in general, is pointless. Why does an iOS developer need to know what a graph is?</li> 
 </ul>
 <p>People who feel this way then claim that this field is something that only academics should worry about, and practical programmers should not have to deal with this as part of their daily jobs.</p>
 <p>I think anyone can see why someone would have these views. If you have never been introduced to this field, it can definitely look like it's all about pieces of obscure knowledge that aren't relevant to the actual role. They are called fundamentals, but you can learn how to code without them. Are they really that fundamental?</p>
 <p>What's important to be aware of is <b>the role</b> this knowledge plays in your programming ability. Let's take a look at the third point again:</p>
 <ul> 
  <li>Theory, in general, is pointless. Why does an iOS developer need to know what a graph is?</li> 
 </ul>
 <p>Many people seem to hold the opinion that these companies are insinuating that you as a programmer need to know these things because that's what your job is going to be about, but that's not what this is about. As mentioned before, I believe it's imperative for you to separate the concept of knowing theory with the fact that these companies have terrible interview practices, because popular opinions like this spawned from a misleading assumption that these are one and the same.</p>
 <p>The role this knowledge plays in practice is that people use what they know about the fundamentals as a <b>reference</b> to determine how a certain piece of code they're writing should be designed. If this sounds familiar to you, then it's because that's how most of programming works! This is certainly something you do all the time, the difference being just what you're using as a reference.</p>
 <p>This implicitness gives people the impression that the fundamentals are useless, while in reality, <b>they're using them all the time!</b> I cannot tell you how many times I've heard an iOS developer say "I can safely tell you that never in my job I needed to use a graph" and then proceed to happily talk about something interesting they worked with involving <code>UIView</code> hierarchies. <b>They are the same thing!</b> Not only do they <i>know</i> what a graph is, but they have also have been using them since their very first day as a developer!</p>
 <p>In iOS specifically, you can draw these comparisons with many of the concepts people claim to have no knowledge of:</p>
<ul>
<li>Graphs/Trees: <code>UIView</code></li>
<li>Linked Lists: <code>UIResponder</code></li>
<li>Hash Tables: <code>Dictionary&lt;K,V></code> and the <code>Hashable</code> protocol</li>
<li>Bit Manipulation: <code>OptionSet</code></li>
</ul>
 <p>It can be quite common for developers to not make the distinction between what part of their knowledge is platform-specific (like knowing UIKit APIs in iOS) and what is actually fundamental knowledge (like knowing the difference between an <code>Array</code> and a <code>Set</code>) that they picked up in practice -- you as a professional programmer who never formally studied the theory very likely know a great deal of it, it's just that you haven't yet studied the part where you learn how to describe this knowledge in a platform-agnostic fashion.</p>
 <p>But when would <i>that</i> be particularly useful? We've shown that developers can do just fine with not separating their knowledge in that fashion, so when would having this ability be useful for you?</p>
 <h2>Analogy: Becoming a professional musician</h2>
 <p>To explain this, I would like to draw an analogy with a person's journey of learning a musical instrument. This is because musical instruments are accompanied by <b>music theory</b>, and I find the relation between them to be very similar to the one between programming and algorithms.</p>
 <blockquote>
  <i>21-05-2021 Update</i>: There were very interesting discussions about this article on HackerNews on how to form an analogy between these two concepts and actual musicians commented saying that a classical orchestra would be a better comparison. I updated the analogy -- thank you very much for your inputs!
 </blockquote>
 <p>In music, music theory is the study of the practices and possibilities of music. It seeks to define the processes and general principles of music, but also the concepts that define what <i>music</i> itself is, defining exactly what is a note, the theoretical definition of a chord and how it can be manipulated, how chords can be grouped into keys and how musical progression works.</p>
 <p>A person who wants to learn an instrument like the electric guitar and is doing music lessons will be introduced to the concept of music theory, but also be told that they don't really <i>need</i> to learn it to learn how to play the guitar. Although they will need to learn the basics of notes and chords, there's no need to get into the deeper complicated details unless the person happens to be interested in that. The learner will be perfectly capable to learn how to play their favorite songs, and maybe even play in a cover band with their friends. As we've seen above, this is exactly the same scenario we see in programming.</p>
 <p>In the case of music, the details of music theory start becoming more relevant when the person starts wanting to compose <b>their own songs</b>. Although this is still not a critical requirement in any shape whatsoever, a musician without knowledge of theory might have a harder time composing when compared with someone who does know it. This is because concepts like chord theory can give you many insights on how to achieve particular sounds and the progressions that include them, so although you can still do perfectly well without this knowledge (and we know many famous musicians who have done that), you'll be placing a lot of unnecessary responsibility on your raw musical talent that could be used much more efficiently if you had the ability to describe your knowledge in a logical/agnostic way. We can say that composing songs is the more <i>explicit</i> application of music theory, which could be comparable to a programmer being tasked to code a complicated feature that was never done before.</p>
 <p>However, music theory has also an <b>implicit</b> application, which is that <b>people who learn music theory are great musicians in general.</b> Even though the person might not be composing their own songs, their understanding of music likely makes them very comfortable playing and improvising any kind of song. These people are usually extremely skilled, being able to learn how to play new songs by ear without ever needing to check how the band that made the song actually plays it. The logic is simple: <b>they don't need to, because they understand the logic behind what they're listening to.</b></p>
 <p>Another implicit benefit of music theory is that <b>it applies to every instrument.</b> People who understand music theory usually have a much easier time mastering different instruments because most of their knowledge from previous instruments can be applied to new ones. All they need to learn is how the instrument is played.</p>
 <p>These are exactly the benefits that learning CS Fundamentals can provide you in everyday programming. Even though you're not "composing your own algorithms", your knowledge of how computer science works can provide a serious boost to your programming ability in general. The difference between music and programming is what exactly is "boosted": While a musician that knows the theory might be better at designing and understanding music, a programmer who knows the theory will be better at designing and understanding <i>systems</i>. A person who doesn't know programming theory is perfectly capable of creating a good product, but just like in the composing analogy, it's likely that they would have a harder time doing so when compared to someone who does have that knowledge.</p>
 <p>It's important to understand however what it's <i>meant</i> by system design in this case; we are not talking about concepts like Clean Code and SOLID, but how <b>correct</b> your code is from a design, performance and resource management point of view. Note that <i>correct</i> doesn't mean "this code must use this ultra-fast obscure algorithm this Russian dude published in 1970, otherwise it's wrong and you should quit", it simply means that the code you're writing <i>makes sense</i> from an engineering standpoint. I'm gonna reiterate it for good measure: <b>Do not confuse having this knowledge with bizarre interview processes! Fundamentals are not about weird obscure algorithms!</b></p>
 <p>If this doesn't click for you, think of how correctness applies in the musician's example: Even though two musicians might be playing the exact same song, one of them might have really bad posture and a choice of chords that is all over the fretboard. The other musician however has learned the proper posture, and their knowledge of theory allows them to find the exact same chords in much more comfortable positions. It's the same song with the same result, but one of the musicians will have a much easier time playing it, while the other one will struggle and likely end up with tendonitis.</p>
 <h2>Who <i>really</i> needs to learn the theory?</h2>
 <p>I hope that by now you have a clear view of how a programmer can benefit from studying the fundamentals and how it's orthogonal to the outdated processes of large companies, but before clarifying <i>why</i> these companies care about this, let's first evaluate this knowledge from a <b>career necessity</b> standpoint.</p>
 <p>If we go back to the music example, we can say that the <i>necessity</i> of studying music theory in a musician's career will heavily depend on what the musician wishes to achieve:</p>
 <ul> 
  <li>Do I want to learn it as a hobby, and never go beyond playing in my couch for fun?</li> 
  <li>Do I want to play in a band, and solidify myself as a musical artist?</li> 
  <li>Do I aspire to go beyond the mere title of a "musical artist" by living and breathing classical music, becoming an integral part of the Vienna Philharmonic, traveling the world, and going down as a legend that literally shaped the concept of music itself?</li> 
 </ul>
 <p>It should be clear that our two non-orchestra-dreamer-fanatics don't need music theory, as they can definitely achieve everything they want without it. They can still benefit from it if they want -- learning it would allow them to master their instrument, as well as open the door to every other musical instrument. However, from a pure <i>career necessity</i> standpoint, we can safely say that the theory is just a bonus thing they could learn to be a better musician.</p>
 <p>The dreamer, however, has a completely different objective. This person is not looking to simply have fun, they want to be part of a group of people who dedicate their entire lives to perfecting music as an art form. A famous orchestra will obviously not accept some random joe who picked up a violin weeks ago -- you must at very least be exceptionally good and versatile as a musician. Even though some professional musicians might argue that even in this case it's technically possible for the person to achieve this goal without formally studying the theory, it's clear that not having a deeper level of knowledge about music would be a major setback in this person's career. In fact, orchestras are so serious that having formally studied music is often a minimum requirement.</p>
 <p>Just like in this analogy, the necessity of studying algorithms in your career depends on what you as a programmer want to achieve. If you learned programming as a hobby and don't really want to work with it, then the fundamentals are not necessary at all. Similarly, if you see yourself working at a regular and more practical company, then it's also likely that you will never face a situation where the fundamentals would make a big difference. You could learn it to improve your ability in general, but from a pure <i>necessity</i> standpoint, you can surely live without them.</p>
 <p>However, if you aspire to learn multiple platforms, work in a global tech company with state-of-the-art technology and incredibly smart people who are at the top of their field helping them <i>literally</i> define what tech is, then it should be clear to you that even though this is technically achievable with pure programming talent and zero theoretical knowledge (and I'm certain the community can point many who have done so), you will likely have a much easier time getting there if you channel your talent into getting a deeper and more logical level of understanding of what you do in your daily work.</p>
 <h2>Why are top-tier companies so focused on the fundamentals?</h2>
 <p>To understand why larger companies are so obsessed with the theory, we'll focus on the following point:</p>
 <ul> 
  <li>Theory doesn't reflect what the person will actually do in their job.</li>
 </ul>
 <p>When referred to interview processes this point is absolutely correct for obvious reasons; some of the questions I got during my period running lots of interviews were so convoluted that I still can't figure out what they were supposed to test me for.</p>
 <p>But before we continue, we have another point of confusion that must be separated. Just like I urged you to not treat theory and bad interview processes as being the same thing, I'll now ask you to take some time to <b>separate the difficulty of the interviews from the fact that the interviews test for theoretical knowledge.</b> This is because these are wildly different things; one has a legit practical reason, and the other is corporate hiring bullshit.</p>
 <p>The reason the questions are hard is purely due to the corporate idiocy. These companies have so many candidates that in order to reduce the possibility of false positives and save time and money, someone decided that the way to go was to make the questions <b>so hard</b> that if they pass, there's a good chance they know what they're doing. I believe this was somewhat true 15 years ago, but today this is so detached from reality that it's hard to grasp why this is still a thing.</p>
 <p>But when it comes to the act of testing for the theory itself, you have to keep in mind how these companies operate. While in regular companies you are likely to be hired to perform a very specific role as a specialist, larger companies like Google are almost always focused on engineering T-shapedness and generalism. This means that even though you might be hired to do something specific like iOS development, it's still expected that you'll have the ability to work with different platforms if needed. I work in one of these companies -- even though I work primarily with iOS, there were many cases where a task I was doing involved checking code that was outside of iOS, like a relevant piece of Android code, the functionality of a C++ library, or even writing a new data pipeline inside our backend. This is expected to the point where it's covered extensively on performance reviews, and as a generalist myself I actually really enjoy this.</p>
 <p>I'd say that the reason why this happens is the nature of these companies -- while a regular company is trying to solve a small-scale problem that has likely been done before, top-tier companies have to deal with enormous problems that nobody has ever faced, which often requires them to be masters in multiple platforms. It's not interesting for a company like Google to hire someone who dedicated their life to understanding all about UIKit in iOS -- their problem is not that they don't know which UIKit APIs to use, is that the APIs they need <b>don't exist at all</b>. These problems are not solved by a person's platform knowledge, but by their understanding of computer science and their ability to craft new and efficient solutions.</p>
 <p>Just like how music theory applies to all instruments, the fundamentals apply to all platforms. Another reason why these companies test your knowledge of them is that it essentially proves that you can work with anything -- even if you never worked with a different platform, knowing the fundamentals will likely make it very easy for you to pick them up. A generalist might not know some random trivia about <code>UITableView</code> APIs that a specialist would, but they don't need to; this is the programming equivalent of the musician who can learn how to play a song by just listening to it. It's easy for a generalist to learn programming languages and platforms -- what's difficult to learn are programming skills you need to have to use these languages and platforms, which is something the fundamentals help you develop.</p>
 <p>This is why these companies like this field -- while in a regular company you can prove your ability by answering questions about a specific platform, in the larger companies' world of generalists it's your understanding of programming as a concept that proves you're the type of programmer they need.</p>
 <div class="sponsor-article-ad-auto hidden"></div>
 <h2>Creating better interview processes</h2>
 <p><i>Bruno, you're claiming that the problem with these interview processes is not the concept of testing knowledge of theory, but how these companies inject artificial difficulty for financial reasons. How would you design them in a fair and modern way?</i></p>
 <p>I don't have a clear answer for this at this moment, but this is a concept I constantly experiment with and have some thoughts on some <i>core concepts</i> I currently believe a better process would contain.</p>
 <p>One important thing you must be aware of is that <b>hiring is hard</b>. No matter how you shape it, it's simply impossible to properly evaluate a person's engineering skill in an hour-long puzzle. The only way to do that is to actually hire the person and work with them for a large period of time, and while some people do suggest that this is how hiring could be done in modern times, this would never work for several reasons. First of all, if you don't pay the person, then I doubt any sane person would sign up for this. On the other hand, if you do pay the person, then it would take little to no time for scamming rings to rise and abuse the process.</p>
 <p>Second of all, time is expensive both for the candidate and the company. Even though we know that interviewing the person for a large period of time is the only proper way to have a legitimate view of their skills, both the candidate and the company want this to happen as quickly as possible. The company obviously wants this for financial reasons, while candidates want that because 1) interviewing is in general very stressful and annoying, and 2) the majority of people interview for multiple companies at the same time, making it important for them to be over quickly so that the candidate can start more interviews with other companies.</p>
 <p>To optimize for these needs, companies opted to make a trade-off between accuracy and time spent. While speeding up the interviews makes everyone happy, it has the immediate consequence that you become unable to accurately measure the candidate's ability, making you need to make an <b>educated guess</b> instead. Because we know it's impossible to make a 100% accurate guess with a heavy time constraint, the most critical component of a good interview process becomes <b>how you can maximize the accuracy of your guess without creating downsides on other fronts.</b></p>
 <p>We know how traditional large companies maximize their guess: they make the interview as hard as possible. However, this artificial difficulty creates so many downsides on so many fronts that by this specific definition it logically cannot be considered a good process.</p>
 <p>So what are the good approaches? The answer is not yet clear, but I can share some concepts I'm currently studying and applying:</p>
 <h3>No generic questions. Always relevant to the product</h3>
 <p>To make the process fair to candidates with non-traditional backgrounds, I believe questions should always be non-generic and related to what the job actually consists of. Some people might think that this would make you unable to evaluate a person's knowledge of deeper programming concepts, but this is not the case at all. To understand why, refer back to one of the first points of this article: <b>people often know the theory, they just don't know it's theory.</b> To evaluate a person's understanding of a deeper concept without making it immediately unfair to candidates who didn't formally study the theory, all you have to do is wrap the question around something that is familiar to them and make it relevant to the product.</p>
 <p>Let's use iOS development as an example and pretend that I want to have an idea if the person is proficient at visualizing and traversing distributed components. The generic way of doing so could be to give them a generic graph data structure and ask them to search for a node, but this has two problems. First, as mentioned a couple of times, this will be very daunting for someone who hasn't studied theory. Second, most people will be discouraged from solving it as they cannot see why this is related to the product they're interviewing for.</p>
 <p>To fix this, we can do two things. First of all, remove all the references to generic terms and replace them with something that is familiar to everyone: In this case, we could simply replace "graph" with <code>UIView</code> and "search for a node" with "locate a subview in the hierarchy".</p>
 <p>Second of all, make it relevant to the product: instead of wording it like a general problem, we could use an actual feature of the app where this is or could be a legitimate necessity as a context for why this is being asked. This second step is not always necessary as in my experience simply making it non-generic already does a great job at making people feel comfortable with solving a particular question, but I find that making it relevant makes people actually enjoy the process more as they can see <b>exactly</b> why being able to solve that particular problem is important for the company.</p>
 <h3>Run multiple types of questions</h3>
 <p>Coding exercises are popular because they usually provide the maximum "guessing" ability, but that's only true if that's the only type of question you're running. I find that one way you can improve your guesses is to actually run different types of questions in <i>addition</i> to the coding exercises. One example of exercise some companies are running are "code reviews": Present a piece of really bad code and ask the candidate to pinpoint what's wrong with it. When paired with the regular coding tasks, these alternative exercises can give you a really good view of the candidate's practical knowledge due to how relevant they are to the position.</p>
 <h2>Conclusion</h2>
 <p>Hiring is an unsolved problem, and there are many questions I still don't have answers to. Still, I hope this article was able to give you new insights into the role that fundamental knowledge plays in a developer's career and what we can do to create better interview experiences.</p>
</div></div>
                              
   

    <div class="blog-post" style="margin-top: 16px;">
      <div class="footer-text">
        <p>Thanks for reading! If you want to see more Swift / iOS content like this, follow me on <a href="https://twitter.com/rockbruno_">Twitter!</a></p>
        <div class="footer-share">
        <a href="https://twitter.com/intent/tweet?via=rockbruno_&hashtags=swiftrocks,ios,swiftlang&url=https%3A%2F%2Fswiftrocks.com%2Fhow-necessary-are-the-programming-fundamentals&text=How necessary are the programming fundamentals?" target="_blank" class="share" style="font-size: 18px;"><i class="fa fa-twitter"></i>‏‏‎ ‎‏‏‎ ‎‏‏‎ ‎Share this page on Twitter</a>
        </div>
      </div>
    <!-- Mailchimp -->
  <div id="mc_embed_signup" style="border-top: 1px solid black; padding-top: 32px;">
  <div style="display:flex; justify-content: center; text-align: center;">
  <p style="font-weight: 100; font-size: 16px;">Articles about advanced Swift development in excruciating detail, for free!</p>
  </div>
  <form action="https://swiftrocks.us17.list-manage.com/subscribe/post?u=d6bdd39e59b8d9b8f2b8d4852&amp;id=cbca5f3532" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" style="padding: 0;" novalidate>
      <div id="mc_embed_signup_scroll">
    
    <input type="email" value="" name="EMAIL" class="email" id="mce-EMAIL" placeholder="Your email address" required>
      <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->
      <div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_d6bdd39e59b8d9b8f2b8d4852_cbca5f3532" tabindex="-1" value=""></div>
      <div class="clear"><input type="submit" value="Notify me of new posts" name="subscribe" id="mc-embedded-subscribe" class="button"></div>
      </div>
  </form>
  </div>
  <!-- Mailchimp End -->

    </div>

                         </div>

</div>
                        
                           
                         </div>
                     
                     
                  </div>
                  <!-- Blog Post (Right Sidebar) End -->
                
            </div>
         </div>
      </div>
    
    
    <!-- All Javascript Plugins  -->
  <script type="text/javascript" src="js/jquery.min.js"></script> 
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM" crossorigin="anonymous"></script>
  <script type="text/javascript" src="js/prism3.js"></script> 
    <!-- Main Javascript File  -->
    <script type="text/javascript" src="js/scripts26.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-130406165-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-130406165-1');
</script>

   </body>
 </html>
