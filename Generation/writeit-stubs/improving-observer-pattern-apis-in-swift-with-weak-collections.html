
<!--WRITEIT_POST_NAME=Improving Observer Pattern APIs in Swift With Weak Collections-->
<!--WRITEIT_POST_HTML_NAME=improving-observer-pattern-apis-in-swift-with-weak-collections-->

<!--Add here the additional properties that you want each page to possess.-->
<!--These properties can be used to change content in the template page or in the page itself as shown here.-->
<!--Properties must start with 'WRITEIT_POST'.-->
<!--Writeit provides and injects WRITEIT_POST_NAME and WRITEIT_POST_HTML_NAME by default.-->

<!--WRITEIT_POST_SHORT_DESCRIPTION=In this article, I'll show you a memory management trick with some old-school Foundation types that can be used in any object that applies the Observer pattern to create better and safer APIs.-->
<!--WRITEIT_POST_SITEMAP_DATE_LAST_MOD=2020-08-25T14:00:00+02:00-->
<!--WRITEIT_POST_SITEMAP_DATE=2020-08-25T14:00:00+02:00-->

<title>$WRITEIT_POST_NAME</title>
<div class="col-md-12 blog-post"> 
<div class="post-title"> 
  <h1>$WRITEIT_POST_NAME</h1> 
</div> 
<div class="post-info"> 
August 25th, 2020
</div>
<p>Even if you don't know what the <b>Observer</b> pattern is, there's a good chance that you applied it somewhere in the past. This design pattern is used to create APIs that notify one or more subjects about changes in a certain object, with the <code>NotificationCenter</code> being the most popular use of this pattern in iOS.</p>
<p>One simple way to reproduce what the <code>NotificationCenter</code> does is to create a dictionary that maps a string (a notification) to an array of closures. Whenever that notification is "posted", all of the closures are executed.</p>
<pre>
<code>final class NotificationCenter {</code>
<code></code>
<code>    var notifications = [String: [() -> Void]]()</code>
<code></code>
<code>    func register(_ closure: @escaping () -> Void, forNotification string: String) {</code>
<code>        notifications[string, default: []].append(closure)</code>
<code>    }</code>
<code></code>
<code>    func post(notification: String) {</code>
<code>        notifications[notification]?.forEach { $0() }</code>
<code>    }</code>
<code>}</code>
</pre>
<p>However, the point of this article is not to attempt to reproduce the <code>NotificationCenter</code>, but to show you <b>what</b> this implementation implies. You must be aware that whenever you're using the basic Swift dictionaries, arrays or sets, <b>all keys and values are retained!</b> Additionally, if you remember <b>closures are reference types</b>, so they are retained as well and can outlive their owners.</p>
<p>What this means is that you'll see that while this implementation works, it's going to be a huge memory issue. Because it's retaining the closures, they will never be unregistered. The notifications will attempt to execute them even if the object that registered it is <b>long gone</b>.</p>
<p>If you're been working with iOS for a long time, you might remember that iOS's own <code>NotificationCenter</code> had this issue! Prior to iOS 9, every observer had to be unregistered when being deallocated, because if you didn't, it would attempt to execute it when it shouldn't and crash your app.</p>
<pre>
<code>deinit {</code>
<code>    NotificationCenter.default.removeObserver(self, ...)</code>
<code>}</code>
</pre>
<p>In the case of our implementation, we could replicate this by adding the concept of "owners" to our closures, so that we are able to remove them if someone wishes to be unregistered. Fortunately, not only we don't need to go this far, but it's good if we don't. If you're developing an API, its usability should be one of your main priorities. In this case, let's take a look at how we can create an observer API that <b>is</b> memory safe while also <b>not having</b> to manually unregister the observers. The problem shown above that <code>NotificationCenter</code> had was fixed in iOS 9 (removing observers became an automatic process) when Apple started applying the same concept.</p>
<h2>Weak Collections</h2>
<p>Let's pretend we have a deeplink-based navigation system where "feature providers" can provide a feature (represented as an <code>UIViewController</code>) if they recognize the deeplink that the app wants to present:</p>
<pre>
<code>final class FeaturePusher {</code>
<code></code>
<code>    typealias FeatureProvider = (URL) -> UIViewController?</code>
<code></code>
<code>    lazy var providers = [FeatureProvider]()</code>
<code></code>
<code>    func register(featureProvider: @escaping FeatureProvider) {</code>
<code>        providers.append(featureProvider)</code>
<code>    }</code>
<code></code>
<code>    func feature(forUrl url: URL) -> UIViewController? {</code>
<code>        return providers.lazy.compactMap { $0(url) }.first</code>
<code>    }</code>
<code>}</code>
</pre>
<p>Like in the notification center example, this suffers from a memory issue. If whoever provided those closures ceases to exist, the <code>FeaturePusher</code> class will still be able to execute the closure and potentially crash the app. Fortunately, there are a few useful types in <code>Foundation</code> that can assist us in improving that.</p>
<p>As I've shown before in my <a href="https://swiftrocks.com/weak-dictionary-values-in-swift">Weak Dictionary Values</a> article, <code>Foundation</code> offers a series of lower-level Obj-C collection types that are more powerful than the basic Swift ones. Two of them specifically are <code>NSMapTable</code> and <code>NSHashTable</code>, which are Obj-C versions of <code>Dictionary</code> and <code>Set</code>, respectively. Both of them allow a higher range of memory management options, which include weak references for both values and keys. If instead of using a base Swift array we used a <code>NSMapTable</code> that has our closures as values and <b>weak</b> references to whoever provided that block as a key, our navigation system would automatically evict and deallocate the closures whenever the related providers are deallocated, due to the weak reference. That's because in weak collections if the weak component is deallocated, the entire entry will be evicted from the collection.</p>
<p>Creating Weak Collections is just a matter of using the correct initializer. A dictionary with weak keys can be initialized with <code>NSMapTable.weakToStrongObjects()</code>, while one with weak values can be initialized with <code>NSMapTable.strongToWeakObjects()</code>. If we want our fake notification center's closures to be automatically unregistered if the object that registered them was deallocated, we can create a weak-keyed dictionary that maps an object to an array of closures:</p>
<pre>
<code>lazy var providers = NSMapTable&lt;AnyObject, NSHashTable&lt;FeatureProviderBox>>.weakToStrongObjects()</code>
</pre>
<p>Because the keys are weak, the closures will automatically be evicted from the dictionary if the key ceases to exist.</p>
<p>Note that <code>NSMapTable</code> is an Obj-C API, so all keys and values must be class objects. That's why we have to use a <code>NSHashTable</code> as a value instead of a regular <code>Set</code> or <code>Array</code>.</p>
<p>You can also make Obj-C types like <code>NSMapTable</code> able to hold Swift structs by creating a generic <code>Box</code> class wrapper type. Here, we create one to be able to represent our feature closure as a class object (<code>FeatureProviderBox</code>) in order to be able to store it inside the <code>NSHashTable</code>.</p>
<pre>
<code>final class Box&lt;T> {</code>
<code>    let obj: T</code>
<code>    init(obj: T) {</code>
<code>        self.obj = obj</code>
<code>    }</code>
<code>}</code>
<code></code>
<code>final class FeaturePusher {</code>
<code></code>
<code>    typealias FeatureProvider = (URL) -> UIViewController?</code>
<code>    typealias FeatureProviderBox = Box&lt;FeatureProvider></code>
<code></code>
<code>    lazy var providers = NSMapTable&lt;AnyObject, NSHashTable&lt;FeatureProviderBox>>.weakToStrongObjects()</code>
<code></code>
<code>    func register(featureProvider: @escaping FeatureProvider, forObject object: AnyObject) {</code>
<code>        if providers.object(forKey: object) == nil {</code>
<code>            providers.setObject(NSHashTable(), forKey: object)</code>
<code>        }</code>
<code>        let box = FeatureProviderBox(obj: featureProvider)</code>
<code>        providers.object(forKey: object)?.add(box)</code>
<code>    }</code>
<code></code>
<code>    func feature(forUrl url: URL) -> UIViewController? {</code>
<code>        let allValues = providers.objectEnumerator()</code>
<code>        while let table = allValues?.nextObject() as? NSHashTable&lt;FeatureProviderBox> {</code>
<code>            if let feature = table.allObjects.lazy.compactMap { $0.obj(url) }.first {</code>
<code>                return feature</code>
<code>            }</code>
<code>        }</code>
<code>        return nil</code>
<code>    }</code>
<code>}</code>
</pre>
<h2>Unit Testing Weak Collections (and Reference Cycles)</h2>
<p>To check if our improvement worked, we can create a unit test that checks if the correct view controllers are returned:</p>
<pre>
<code>func test_observerReturnsTheCorrectFeature() {</code>
<code></code>
<code>    let pusher = FeaturePusher()</code>
<code>    let swiftRocksUrl = URL(string: "myApp://swiftRocks")!</code>
<code>    let swiftRocksVC = SwiftRocksViewController()</code>
<code></code>
<code>    let observerObject: UIView = UIView()</code>
<code></code>
<code>    pusher.register(featureProvider: { url in</code>
<code>        return url == swiftRocksUrl ? swiftRocksVC : nil</code>
<code>    }, forObject: observerObject)</code>
<code></code>
<code>    XCTAssertTrue(pusher.feature(forUrl: swiftRocksUrl) === swiftRocksVC)</code>
<code></code>
<code>    let someOtherURL = URL(string: "myApp://notSwiftRocks")!</code>
<code>    XCTAssertNil(pusher.feature(forUrl: someOtherURL))</code>
<code>}</code>
</pre>
<p>However, we are mostly interested in seeing if the automatic eviction is working. To test that the observers are being evicted and the closures are being deallocated, we can use an <code>autoreleasepool</code>. As described in my <a href="https://swiftrocks.com/autoreleasepool-in-2019-swift">autoreleasepool article</a>, you can use a pool whenever you want something to deallocate something as soon as possible:</p>
<pre>
<code>func test_observerIsDeallocated() {</code>
<code></code>
<code>    let pusher = FeaturePusher()</code>
<code>    let swiftRocksUrl = URL(string: "myApp://swiftRocks")!</code>
<code>    let swiftRocksVC = SwiftRocksViewController()</code>
<code></code>
<code>    autoreleasepool {</code>
<code>        let observerObject: UIView = UIView()</code>
<code></code>
<code>        pusher.register(featureProvider: { url in</code>
<code>            return url == swiftRocksUrl ? swiftRocksVC : nil</code>
<code>        }, forObject: observerObject)</code>
<code></code>
<code>        XCTAssertTrue(pusher.feature(forUrl: swiftRocksUrl) === swiftRocksVC)</code>
<code></code>
<code>        let someOtherURL = URL(string: "myApp://notSwiftRocks")!</code>
<code>        XCTAssertNil(pusher.feature(forUrl: someOtherURL))</code>
<code>    }</code>
<code></code>
<code>    XCTAssertNil(pusher.feature(forUrl: swiftRocksUrl))</code>
<code>}</code>
</pre>
<p>You'll see that this test will pass, but if you're not sure why, try removing the pool to see what happens. The test will fail, and the reason is that objects aren't deallocated as soon as they go out of scope in iOS (that will usually happen at the end of a <code>RunLoop</code>). In this case, the pool is simply a way to force it to deallocate immediately for unit testing purposes. This same trick can be applied to unit test any type of reference cycle situation :)</p>
<h2>Conclusion: Final considerations for Weak Collections</h2>
<p>Weak Collections are a great way to build better APIs, but you must be aware of their possible limitations. While types like <code>NSHashTable</code> and <code>NSPointerArray</code> are all-around great tools, you may see that <code>NSMapTable</code>'s documentation tells you to be careful with <code>weakToStrongObjects()</code>. In that configuration, although the values are ejected from the table as expected, they still may be held in memory for a larger period of time. That's why this article didn't attempt to fully reproduce the NotificationCenter, as <a href="https://forums.swift.org/t/why-is-this-unreferenced-object-refusing-to-deallocate/39604?u=rockbruno">it took me a while to realize that doing so would require a pretty ugly workaround.</a> However, you'll find that <code>NSHashTable</code> is good to go under any configuration.</p>
<h2>References and Good Reads</h2>
<a href="https://swiftrocks.com/weak-dictionary-values-in-swift">Weak Dictionary Values (SwiftRocks)</a><br>
<a href="https://swiftrocks.com/autoreleasepool-in-2019-swift">@autoreleasepool uses in 2019 Swift (SwiftRocks)</a><br>
</div>
