
<!--WRITEIT_POST_NAME=Avoiding Callback Hell in Swift-->
<!--WRITEIT_POST_HTML_NAME=avoiding-callback-hell-in-swift-->
<!--WRITEIT_POST_SITEMAP_DATE_LAST_MOD=2020-04-12T14:00:00+02:00-->
<!--WRITEIT_POST_SITEMAP_DATE=2018-12-17T13:42:07+00:00-->

<!--Add here the additional properties that you want each page to possess.-->
<!--These properties can be used to change content in the template page or in the page itself as shown here.-->
<!--Properties must start with 'WRITE_IT_POST'.-->
<!--Writeit provides and injects WRITEIT_POST_NAME and WRITEIT_POST_HTML_NAME by default.-->

<!--WRITEIT_POST_SHORT_DESCRIPTION=Being able to work in projects of the most diverse varieties gave me the chance to be in contact with several types of developers and code bases. Besides their core differences, what stood out to me during this process is that projects with a lower level of maturity will always face similar problems.-->

<title>Avoiding Callback Hell in Swift</title>
<div class="col-md-12 blog-post"> 
<div class="post-title"> 
  <h1>Avoiding Callback Hell in Swift</h1> 
</div> 
<div class="post-info"> 
December 17, 2018
</div>
<p>Being able to work in projects of the most diverse varieties gave me the chance to be in contact with several types of developers and code bases. Besides their core differences, what stood out to me during this process is that projects with a lower level of maturity will always face similar problems.</p>
<p>Perhaps they choose the wrong architecture, or the lack of unit tests caused a nasty bug to sneak into production, but there's a specific problem that always draws my attention - callback hell. If not treated from the very beginning, these awful pyramids of braces you get when chaining callbacks inside other callbacks or conditions plague code bases with an eternity of impossible code-reviews and distant screams of "what the hell is this method supposed to be doing?".</p>
<pre>
<code>private func requestNetwork&lt;T: Request>(request: T, completion: (Result&lt;T> -> Void)?) {</code>
<code>  if isUserLogged {</code>
<code>    do {</code>
<code>      let urlRequest = try request.toRequest()</code>
<code>      session.dataTask(with: urlRequest) { (data, response, error) in</code>
<code>        if let httpResponse = response as? HTTPURLResponse {</code>
<code>          if acceptedStatuses?.contains(httpResponse.statusCode) != true {</code>
<code>            if let apiError = errorParser?.possibleError(from: data) {</code>
<code>              completion(.failure(error))</code>
<code>              return</code>
<code>            }</code>
<code>          }</code>
<code>        }</code>
<code>        preprocess(data) { (processedData, error) in</code>
<code>          if let error = error {</code>
<code>            completion(.failure(error))</code>
<code>          }</code>
<code>          if let processedData = processedData {</code>
<code>            do {</code>
<code>              let result = try request.serialize(processedData)</code>
<code>              completion(.success(result))</code>
<code>            } catch {</code>
<code>              completion(.failure(error))</code>
<code>            }</code>
<code>          } else {</code>
<code>              completion(.failure(HTTPError.unknown))</code>
<code>          }</code>
<code>        }</code>
<code>      }</code>
<code>    } catch {</code>
<code>      completion(.failure(error))</code>
<code>    }</code>
<code>  } else {</code>
<code>    completion(.failure(HTTPError.loggedOut))</code>
<code>  }</code>
<code>}</code>
</pre>
<p>They are difficult to read, nearly impossible to review but unfortunately super easy to write, cementing their place as the bane of junior developers.</p>
<p>Fortunately for us, Swift offers several options to avoid this behavior. With a bit of patience and a proper style guide, you can prevent this sort of mistake from affecting your productivity. I'll use this article to share how I personally avoid them, and hopefully this will help you come up with your own solutions.</p>
<h2>Condition hells: Favor using guard instead of if</h2>
<p>Pyramids of conditions are very common, and fortunately the easier to deal with. <code>guard</code> is on my top 10 features in Swift for a good reason - although it works basically as an inverted <code>if</code> statement, it gives you a great advantage in terms of code quality. Besides providing a way for you to give an early return to a method, it allows you to put the "good" outcome of a method in the same indentation as the method itself, making your method's intent far easier to be understood by your colleague. The improvement is not difficult to spot in a chain of <code>if</code> statement:</p>
<pre>
<code>func foo() {</code>
<code>    if a {</code>
<code>        if b {</code>
<code>            if c {</code>
<code>                //Good outcome</code>
<code>            } else {</code>
<code>                //Bad outcome 3</code>
<code>            }</code>
<code>        } else {</code>
<code>            //Bad outcome 2</code>
<code>        }</code>
<code>    } else {</code>
<code>        //Bad outcome 1</code>
<code>    }</code>
<code>}</code>
</pre>
<pre>
<code>func foo() {</code>
<code>    guard a else {</code>
<code>        return //Bad outcome 1</code>
<code>    }</code>
<code>    guard b else {</code>
<code>        return //Bad outcome 2</code>
<code>    }</code>
<code>    guard c else {</code>
<code>        return //Bad outcome 3</code>
<code>    }</code>
<code>    //Good outcome</code>
<code>}</code>
</pre>
<p>If you embrace the mindset of putting the good outcome of your method as close as possible to the method's indentation and the bad outcomes as far as possible from it, you'll find your code to be significantly easier to read as a mere glance at the end of the method will be enough for someone to understand what it's supposed to do. Use <code>guards</code> to isolate things that are not supposed to happen and restrict the usage of <code>ifs</code> to things that aren't necessary for the good outcome to happen, like changing the color of a cell based on a property's value.</p>
<pre>
<code>func updatePromotions(animated: Bool = true) {</code>
<code>    guard isUserLogged else {</code>
<code>        displayLoginScreen()</code>
<code>        return</code>
<code>    }</code>
<code>    if animated {</code>
<code>        delegate?.didStartLoading()</code>
<code>    }</code>
<code>    //Good outcome: Fetch promotions</code>
<code>}</code>
</pre>
<h2>Closure hells: Abstracting completion handlers</h2>
<p>Callback hells caused by asynchronous calls are the trickier to solve as completion handlers can contain pretty much anything, but there are efficient ways to deal with them as well.</p>
<h3>Promises</h3>
<p>The concept of Promises is my go-to solution for managing anything that's asynchronous. If you have never seen them before, Promises relate to the concept of a type that may or may not resolve a value at a later time:</p>
<pre>
<code>func getInt() -> Promise&lt;Int></code>
<code>    return Promise { promise in</code>
<code>       //Do something async</code>
<code>       promise.fulfill(number)</code>
<code>       //Or promise.fail(error)</code>
<code>    }</code>
<code>}</code>
<code>let promise = getInt().then { number in</code>
<code>    print(number * 10) //if it succeeds</code>
<code>}.catch { error in</code>
<code>    print(error) //if it fails</code>
<code>}</code>
</pre>
<p>The <code>Promise</code> type can receive closures that determine how to proceed depending on the result of resolving the value, represented by <code>then(completion:)</code> and <code>catch(completion:)</code> in this case. If you're wondering why this helps with callback hells, it's because <code>then</code> handlers can optionally receive <b>another promise</b>, creating a limitless straight flow of operations:</p>
<pre>
<code>func perform&lt;T: Request>(request: T) -> Promise&lt;T.Response></code>
<code>    return Promise { promise in</code>
<code>       //Do the actual request here, then:</code>
<code>       promise.fulfill(response)</code>
<code>    }</code>
<code>}</code>
<code></code>
<code>perform(requestOne()).then { responseOne in </code>
<code>    perform(requestTwo(responseOne: responseOne))</code>
<code>}.then { responseTwo in</code>
<code>    perform(requestThree(responseTwo: responseTwo))</code>
<code>}.then { responseThree in</code>
<code>    perform(requestFour(responseThree: responseThree))</code>
<code>}.catch { error in</code>
<code>    print(error)</code>
<code>}.always {</code>
<code>    print("Finished")</code>
<code>}</code>
</pre>
<p>By making your async operations return <code>Promise</code> types instead of receiving completion handlers, you will be able to chain any amount of them together into a nice straight line of code. They are specially great when your operations depend on things returned by previous operations as more powerful Promise implementations will contain several options for transforming values as well.</p>
<p>I personally use <a href="https://github.com/mxcl/PromiseKit">PromiseKit</a> as it contains tons of features, <a href="https://github.com/khanlou/Promise">but there are lightweight libraries around the web</a> and you could certainly <a href="https://www.swiftbysundell.com/posts/under-the-hood-of-futures-and-promises-in-swift">develop a simple Promise implementation yourself.</a></p>
<p>You'll see people recommending things like RxSwift for this purpose as well - I would personally not do so because I think that anything that holds your entire project hostage is a death sentence in the long term (as in, every single thing you do has to take RxSwift's architecture in mind in order to work), but that's my personal opinion and you can definitely use it if you know what you're doing.</p>
<h3>"I don't want to add more code!": <code>OperationQueue</code></h3>
<p>If Promises aren't your thing because you'd rather solve things the Apple way, you can use <code>Foundation</code>'s native solutions for managing sequential operations.</p>
<p><code>OperationQueue</code> is Apple's abstraction of <code>DispatchQueue</code> that contains additional features to better support synchronizing and canceling operations. If your operations don't rely on data from previous operations, the <code>Operation</code> family of classes will do the trick. For synchronous operations, this is just a matter of queuing your custom operations:</p>
<pre>
<code>let queue = OperationQueue()</code>
<code>queue.maxConcurrentOperationCount = 1</code>
<code></code>
<code>func doLotsOfStuff(completion: (() -> Void)?) {</code>
<code>    let firstOperation: Operation = FirstOperation()</code>
<code>    let secondOperation: Operation = SecondOperation()</code>
<code>    secondOperation.completionBlock = {</code>
<code>      completion?()</code>
<code>    }</code>
<code>    secondOperation.addDependency(firstOperation)</code>
<code>    queue.addOperation(firstOperation)</code>
<code>    queue.addOperation(secondOperation)</code>
<code>}</code>
<code></code>
</pre>
<p>However, things are trickier for asynchronous operations. To make the queue wait for your operation to truly finish, you'll either have to use thread-blocking mechanisms such as <code>DispatchGroups</code> or <a href="https://gist.github.com/Sorix/57bc3295dc001434fe08acbb053ed2bc">create/use a custom AsynchronousOperation type</a> that manages an <code>Operation</code>'s states for this purpose.</p>
<p>If you need an operation to pass data to another one, you'll find no clean solution with <code>OperationQueue</code> as there's no guarantee that an operation's <code>completionBlock</code> will be called before the next one starts running. There a few hacks to achieve them through - you can wrap all your needed data in an external reference type that is accessible by all operations:</p>
<pre>
<code>func doLotsOfStuff(completion: (() -> Void)?) {</code>
<code>    let data = NeededOperationData()</code>
<code>    // data has all properties needed by all operations</code>
<code>    // and each operation fetches and sets the ones</code>
<code>    // needed by the next operation.</code>
<code>    let one = OperationOne(data)</code>
<code>    let two = OperationTwo(data)</code>
<code>    two.addDependency(one)</code>
<code>    let three = OperationThree(data)</code>
<code>    three.addDependency(two)</code>
<code></code>
<code>    queue.addOperation(one)</code>
<code>    queue.addOperation(two)</code>
<code>    queue.addOperation(three)</code>
<code>}</code>
</pre>
<p>Alternatively, you can store the necessary data in the operation's dependency and access it by subclassing the operation and fetching its dependencies when it gets executed.</p>
<pre>
<code>class SecondOperation: AsynchronousOperation {</code>
<code>    var data: Data?</code>
<code></code>
<code>    override func main() {</code>
<code>      super.main()</code></code>
<code>      let firstOperation = dependencies.first as? FirstOperation</code>
<code>      data = firstOperation.result</code>
<code>      //Run the operation</code>
<code>    }</code>
<code>}</code>
</pre>
<p>I dislike having to deal with optional properties everywhere, so I personally wouldn't use <code>OperationQueue</code> if my operations depended on data fetched by other operations.</p>
<h3>"Foundation sucks!": Use high-order functions</h3>
<p>If you want to do this without using additional data structures, you can treat callback hell with nothing but pure Swift by applying better coding practices and some principles from functional programming. Because closures are types, they can be passed as arguments to methods - normally as completion handlers. The thing is that Swift methods are just glorified closures, so you can pass <b>an entire method as a closure argument</b>. This exact concept can be used to reduce the amount of nested closures in a method:</p>
<pre>
<code>let sum = array.reduce(0, +)</code>
<code>//reduce() here is an ((Int, ((Int, Int) -> Int)) -> Int)</code>
<code>//and the + operator is func +(lhs: Int, rhs: Int) -> Int,</code>
<code>//... or ((Int, Int) -> Int), so there's no need to define reduce's closure.</code>
</pre>
<p>To see how this applies, let's assume that we have a method that downloads a picture from the web, locally applies a Sepia tone filter to it in another thread and then uploads it as the user's profile picture:</p>
<pre>
<code>func applySepiaFilterAndUpload(picUrl: URL, completion: ((User) -> Void)?) {</code>
<code>    session.perform(downloadPictureRequest(url: picUrl)) { data in</code>
<code>        filtersQueue.async {</code>
<code>            let filteredPicture = applySepiaFilterTo(picData: data)</code>
<code>            session.perform(uploadUserPictureRequest(data: filteredPicture)) { user in</code>
<code>                completion?(user)</code>
<code>            }</code>
<code>        }</code>
<code>    }</code>
<code>}</code>
</pre>
<p>I've left out any kind of error management to make this article easier to grasp, but as any classic callback hell problem, the first problem here is clear: this method does way too much stuff. Before we start thinking about the closures, let's first apply the single responsibility principle and divide each part of this workflow into separate methods:</p>
<pre>
<code>func downloadPicture(fromUrl url: URL, completion: ((Data) -> Void)?) {</code>
<code>    session.perform(downloadPictureRequest(url: url)) { data in</code>
<code>        completion?(data)</code>
<code>    }</code>
<code>}</code>
<code></code>
<code>func applySepiaFilter(toPicData data: Data, completion: ((Data) -> Void)?) {</code>
<code>    filtersQueue.async {</code>
<code>        let filteredPicture = applySepiaFilterTo(picData: data)</code>
<code>        completion?(filteredPicture)</code>
<code>    }</code>
<code>}</code>
<code></code>
<code>func uploadUserPicture(data: Data, completion: ((User) -> Void)?) {</code>
<code>    session.perform(uploadUserPictureRequest(data: data)) { user in</code>
<code>        completion?(user)</code>
<code>    }</code>
<code>}</code>
<code></code>
<code>func applySepiaFilterAndUpload(picUrl: URL, completion: ((User) -> Void)?) {</code>
<code>    downloadPicture(fromUrl: picUrl) { data in</code>
<code>        applySepiaFilter(toPicData: data) { filtered in</code>
<code>            uploadUserPicture(data: filtered) { user in</code>
<code>                completion?(user)</code>
<code>            }</code>
<code>        }</code>
<code>    }</code>
<code>}</code>
</pre>
<p>Although the callback hell still exists here, we at least have something that's readable now.</p>
<p>To reduce the amount of nested closures, analyze how this method works. Can you see the pattern in <code>applySepiaFilterAndUpload()</code>? The key to solving the nesting problem here is how each step works: every method here works in the exact same way. <code>downloadPicture</code> receives an <code>URL</code> and provides a <code>Data</code> completion, <code>applySepiaFilter</code> receives a <code>Data</code> and provides another <code>Data</code> completion, and <code>uploadUserPicture</code> receives a <code>Data</code> and provides a <code>User</code> completion. If you turn these types into generics, you'll end up with:</p>
<pre>
<code>downloadPicture    = (T, (U -> Void)) -> Void</code>
<code>applySepiaFilter   = (U, (V -> Void)) -> Void</code>
<code>uploadUserPicture  = (V, (W -> Void)) -> Void</code>
</pre>
<p>Because these async operations have the exact same structure and clearly depend on each other, we can completely remove the necessity of having closures by adapting these methods to recieve the next one as an argument. This would be trivial to do if each method had an explicit return type, but since we're dealing with completion handlers we need to write a little helper to achieve this effect. First, I'll define this shared behaviour as an <code>Operation</code> alias (with optionals so nobody's forced to do anything):</p>
<pre>
<code>public typealias Operation&lt;T, U> = ((T, ((U) -> Void)?) -> Void)?</code>
</pre>
<p>With that, we can define a method that "merges" two operations into one as long as they have matching parameters - making <code>(T, (U -> Void)) -> Void</code> + <code>(U, (V -> Void)) -> Void</code> become <code>(T, (V -> Void)) -> Void</code>:</p>
<pre>
<code>func merge&lt;T, U, V>(_ lhs: Operation&lt;T, U>, to rhs: Operation&lt;U, V>) -> Operation&lt;T, V> {</code>
<code>    return { (input, completion) in</code>
<code>        lhs?(input) { output in</code>
<code>            rhs?(output, completion)</code>
<code>        }</code>
<code>    }</code>
<code>}</code>
</pre>
<p>This method returns a <b>new closure</b> that performs the first operation method with a given input, uses its output to execute the second one and finally executes a given completion for the second operation's result. If all our methods follow the <code>Operation</code> structure, we can use <code>merge()</code> to progressively merge all steps into a single operation. We can't really escape the nesting in this helper, but this allows us to rewrite our main method without them:</p>
<pre>
<code>func applySepiaFilterAndUpload(picUrl: URL, completion: ((User) -> Void)?) {</code>
<code>    let job = merge(merge(downloadPicture, to: applySephiaFilter), to: uploadUserPicture)</code>
<code>    job?(picUrl, completion)</code>
<code>}</code>
</pre>
<p>Because the signature of our operations match <code>merge()</code>'s closure arguments, we can skip having to define closures by passing the methods' signatures as the arguments. In the end, <code>job</code> becomes an unified method that takes an <code>URL</code>, executes all operations in order and then finally the executes the method's completion handler with the result of the last operation. That's just like the first version, but with no nesting at all!</p>
<p>Now, if you're thinking <i>"but that looks terrible!"</i>, you're absolutely right. Because we can only merge two operations at a time, we need to call <code>merge()</code> several times which will result in something that's probably harder to read than the original callback hell. There's a way to fix this though - we can define an operator for <code>merge()</code>'s behavior:</i>
<pre>
<code>infix operator >>->>: LogicalConjunctionPrecedence // Precedence of &&</code>
<code></code>
<code>func >>->>&lt;T, U, V>(lhs: Operation&lt;T, U>, rhs: Operation&lt;U, V>) -> Operation&lt;T, V> {</code>
<code>    return merge(lhs, rhs)</code>
<code>}</code>
</pre>
<p>By using <code>&&</code>'s precedence, operations will be progressively merged all the way from the left. With that in place, we can now rewrite our workflow as a nice straight line of operations.</p>
<pre>
<code>func applySepiaFilterAndUpload(picUrl: URL, completion: ((User) -> Void)?) {</code>
<code>    let job = downloadPicture >>->> applySepiaFilter >>->> uploadUserPicture</code>
<code>    job?(picUrl, completion)</code>
<code>}</code>
</pre>
<p>If you're into this sort of stuff, the formal name for this very specific merging operation is the <a href="https://blog.ssanj.net/posts/2017-06-07-composing-monadic-functions-with-kleisli-arrows.html">Kleisi composition.</a></p>
<h2>Conclusion: Read articles and books about writing clean code</h2>
<p>If you take a deep look at it, you'll notice that the presence of things like callback hell will always boil down to the lack of good coding practices.</p>
<p>Clean code is a big topic, but there are great resources about it around the web. I've personally read and highly recommend <a href="https://www.amazon.com/dp/B001GSTOAM/ref=dp-kindle-redirect?_encoding=UTF8&btkr=1">Robert C. Martin's Clean Code book</a> as it teaches you how to see your code from the perspective of other developers - a great skill to have when learning how to write better looking code. You should definitely give it a try if you're a professional developer.</p>
<p>Follow me on my Twitter - <a href="https://twitter.com/rockbruno_">@rockbruno_</a>, and let me know of any suggestions and corrections you want to share.</p>
<h2>References and Good reads</h2>
<a href="https://en.wikipedia.org/wiki/Futures_and_promises">Promises</a><br>
<a href="https://blog.ssanj.net/posts/2017-06-07-composing-monadic-functions-with-kleisli-arrows.html">Kleisi composition</a><br>
<a href="https://developer.apple.com/videos/play/wwdc2015/226/">WWDC: Advanced NSOperations</a><br>
<a href="https://gist.github.com/Sorix/57bc3295dc001434fe08acbb053ed2bc">AsynchronousOperation.swift</a>
</div>
