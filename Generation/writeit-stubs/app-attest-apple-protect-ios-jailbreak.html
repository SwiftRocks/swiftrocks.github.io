
<!--WRITEIT_POST_NAME=App Attest: (Properly!) Protecting iOS apps from Jailbreak Tweaks in iOS 14-->
<!--WRITEIT_POST_HTML_NAME=app-attest-apple-protect-ios-jailbreak-->

<!--Add here the additional properties that you want each page to possess.-->
<!--These properties can be used to change content in the template page or in the page itself as shown here.-->
<!--Properties must start with 'WRITEIT_POST'.-->
<!--Writeit provides and injects WRITEIT_POST_NAME and WRITEIT_POST_HTML_NAME by default.-->

<!--WRITEIT_POST_SHORT_DESCRIPTION=As (possibly) a response to jailbreaking become popular again in recent times, Apple has released their own solution to hackers creating compromised versions of your app.-->
<!--WRITEIT_POST_SITEMAP_DATE_LAST_MOD=2020-08-11T14:00:00+02:00-->
<!--WRITEIT_POST_SITEMAP_DATE=2020-08-11T14:00:00+02:00-->

<title>$WRITEIT_POST_NAME</title>
<div class="col-md-12 blog-post"> 
<div class="post-title"> 
  <h1>$WRITEIT_POST_NAME</h1> 
</div> 
<div class="post-info"> 
August 11th, 2020
</div>
<p>When jailbreaking of iOS devices first became popular, it was very common for iOS developers to try to defend their apps from users that altered their devices to enable piracy. There were many ways of doing that, which included checking for the existence of <b>Cydia</b>, checking if the app could read files outside its sandbox, crashing the app if it detects a debugger and more.</p>
<p>As time has shown, these "defensive" measures were and still are a really <b>bad</b> idea. If an attacker has physical access to the device, there's <b>no way</b> you can trust your app's logic. It was and still is trivial for hackers to "pretend" their devices were not jailbroken and effectively bypass these measures, and besides, having a jailbroken device doesn't mean the user wants to pirate content -- some people just want to have cooler looking home screens.</p>
<p>As (possibly) a response to jailbreaking become popular again in recent times, Apple has released their own measure to this problem. In iOS 14, the new <b>App Attest</b> APIs provide you a way to sign server requests as an attempt to prove to your server that they came from an <b>uncompromised</b> version of your app.</p>
<p>It's important to know that <b>App Attest is not a "is this device jailbroken?" check</b>, as that has been proven over and over to be impossible to pinpoint. Instead, it aims to <b>protect server requests</b> in order to make it harder for hackers to create compromised versions of your app that unlock premium features or inserts features like cheats. Note the word <b>harder</b>: as jailbreakers have physical access to their devices, nothing will <b>completely</b> safe-guard you from fraud in this case.</p>
<p>As you can't trust your app to protect itself, App Attest requires work on your backend to be fully implemented. I won't go through the backend part of it as this is a Swift blog, but will at least mention how it works to show how it wrap things together.</p>
<h2>Generating a pair of keys to sign requests</h2>
<p>App Attest works through the use of an asymmetric public/secret pair of encryption keys. The intention, at the end, is for your app to sign server requests with the secret key, send the data to the backend and have it confirm it to be true with the public one. If a hacker intercepts the request, it will not be able to alter its contents without making the backend's subsequent validation fail.</p>
<p>To generate the keys, import the <code>DeviceCheck</code> framework and call the <code>generateKey</code> method from the <code>DCAppAttestService</code> singleton:</p>
<pre>
<code>import DeviceCheck</code>
<code></code>
<code>let service = DCAppAttestService.shared</code>
<code>service.generateKey { (keyIdentifier, error) in</code>
<code>    guard error == nil else {</code>
<code>        return</code>
<code>    }</code>
<code>}</code>
</pre>
<p>The keys generated by App Attest are safely stored in your device's Security Enclave. As you can't directly access it, the result of this method will be a <code>keyIdentifier</code> property that allows iOS to find the keys when needed. You need to store it so you can later validate your app's requests.</p>
<p>It's important to mention that App Attest is not support by <b>all</b> types of devices, and if you look at Apple's own documentation, they will ask you to first check if it's supported and have your server support a fallback in case it's not:</p>
<pre>
<code>if service.isSupported { ... }</code>
</pre>
<p><b>Do not do this!</b> As said before, it's trivial for a jailbreak user to "pretend" their device doesn't support it. Apple doesn't expand on this topic, but the reasons for this check to exist appears to be that there are some Macbooks that don't have the necessary chip to support it. However, <a href="https://twitter.com/_inside/status/1291810797782544386">as investigated by Guilherme Rambo, it appears that every single iOS device supports it.</a> For an iOS app, you do not need to do a compability check.</p>
<h2>Attesting: Sending the public key to the backend</h2>
<p>In order to sign server requests, you need to provide your backend with a way to <b>confirm</b> that signature. This is done by giving the backend access to the public key we previously generated, but we can't simply create a request and add it as a parameter because it would be pretty easy for a hacker to intercept it and send their <b>own</b> public key instead, giving them full control of what your app sends to the backend.</p>
<p>The solution to this problem is to ask Apple to <b>attest</b> that what the key we're sending originated from an uncompromised version of your app. This is done by calling the <code>attestKey</code> method, which receives the key's identifier as a parameter:</p>
<pre>
<code>service.attestKey(keyIdentifier, clientDataHash: hash) { attestation, error in</code>
<code>    guard error == nil else { return }</code>
<code>    let attestationString = attestation?.base64EncodedString()</code>
<code>    // Send the attestation to the server. It now has access to the public key!</code>
<code>    // If it fails, throw the identifier away and start over.</code>
<code>}</code>
</pre>
<p>This method accesses a remote Apple server, and the result is an "attestation" object that contains not only your public key, but a ton of information about your app that serves as an statement from Apple that the previously generated keys are not fake. When you receive this object, you must send it to your backend and have it perform several validations on it that allows it to confirm that it was unaltered. If the attestation object was successfully validated, the backend will be able to safely extract the app's public key from it.</p>
<p>It's unclear if Apple attempts or not to check if the user's device if jailbroken during this process. It's never mentioned that this is the case, but they do say "App Attest can’t <b>definitively</b> pinpoint a device with a compromised operating system." which could imply that they at least <b>try</b> something. It's probably safe to assume that this is not the case, and the word attest here simply means that your request (probably) wasn't intercepted and modified.</p>
<p>The additional <code>clientDataHash</code> parameter of the attestation request is not related to the attestation process itself, but extremely important for it to make it safe. As it is, this request is suspectible to a <b>replay attack</b> where a hacker could intercept the validation request and steal the attestation object sent from Apple so that later they can "replay" the same validation request at a fake version of your app to make the server believe it came from the real one.</p>
<p>A solution to this problem is to simply not allow the validation request to be executed freely. Instead, the client can provide an one-time use token (or session ID) that server will expect to accompany the request to ensure its validity. If the same token is used twice, the request will fail. That's what <code>clientDataHash</code> is for: By providing a hashed version of that expected token to the attestation request, Apple will embed it into the final object and provide your server a way to extract it. With this, it's pretty hard for a hacker to create a compromised version of your app by simply intercepting requests.</p>
<pre>
<code>let challenge = getSessionId().data(using: .utf8)!</code>
<code>let hash = Data(SHA256.hash(data: challenge))</code>
<code>service.attestKey(keyIdentifier, clientDataHash: hash) { ... }</code>
</pre>
<p>As mentioned earlier, Apple suggests you to not reuse keys. You should do this entire process for each user account in a device.</p>
<p>Because this request relies on a remote Apple server, it's possible for it to fail. If the error is that the server was unavailable, Apple says that you can simply try again, but if it's anything else, you should <b>discard</b> the key identifier and start over. This can happen for example when an user reinstalls your app -- The keys that you generate remain valid through regular app updates, but don’t survive app reinstallation, device migration, or restoration of a device from a backup. For these cases, your app needs to be able to restart the key generation process.</p>
<p>From the server side of things, it's also interesting to mention that the statement object also contains a receipt that your server can use to request fraud assessment metrics from Apple. This allows you to check the number of generated keys and the devices that they have been associated to detect possible cases of fraud. Apple specifically mentions the possibility of an attack where an user could use one device to provide valid assertions to compromised devices, which can be detected by this fraud assessment by locating users with unusually high amounts of assertion requests.</p>
<h2>Wrapping it up: Encrypting Server Requests</h2>
<p>After attesting the validity of the key, your backend will have access to the public key. From now on, everytime you're dealing with sensitive content, you have the ability to safely sign that request. The <code>generateAssertion</code> method used for this works very similar to the attestation of the keys, expect this time you're attesting the request itself:</p>
<pre>
<code>let challenge = getSessionId().data(using: .utf8)!</code>
<code>let requestJSON = "{ 'requestedPremiumLevel': 300, 'sessionId': '\(challenge)' }".data(using: .utf8)!</code>
<code>let hash = Data(SHA256.hash(data: challenge))</code>
<code>service.generateAssertion(keyIdentifier, clientDataHash: hash) { assertion, error in</code>
<code>    guard error == nil else { return }</code>
<code>    let assertionString = assertion?.base64EncodedString()</code>
<code>    // Send the encrypted assertion to your server.</code>
<code>    // The server will unencrypt it, validate it, grab your request and process it.</code>
<code>}</code>
</pre>
<p>Just like before, your backend must support the usage of an one-time token to prevent replay attacks. This time, since the request itself is our <code>clientDataHash</code>, we're adding the token inside the JSON. There's no restriction on the number of assertions that you can make with a given key, but still, you typically should reserve that for requests made at sensitive moments of your app such as the download of premium content.</p>
<h2>Testing and rolling out your implementation</h2>
<p>The App Attest service records metrics that you can't reset. To prevent that, apps not in a production environment will use a sandboxed version of it. If you instead want to test in the production environment, you should add the <b>com.apple.developer.devicecheck.appattest-environment</b> entitlement to your app and set its value to <b>production</b>.</p>
<p>If you have a large user base, Apple recommends you to gradually roll this feature as requests to <code>attestKey</code> are rate limited. After carefully rolling it out for existing users, you can guarantee that it will only be called for new users.</p>
<h2>Conclusion</h2>
<p>By implementing this in your client and in your backend, it should become harder for hackers to create compromised versions of your app. However, be aware of the word <b>harder</b> -- it doesn't mean impossible! As mentioned before, there's no sure way for you to detect if a user has a jailbroken device, and even less ways to prevent them from attacking your app. As with most security measures, the intention of App Attest is instead to make this process <b>difficult enough</b> so that only a very skilled and dedicated hacker would be able to find a way to break into your app -- someone much harder to come by.</p>
<h2>References and Good Reads</h2>
<a href="https://developer.apple.com/documentation/devicecheck">Official App Attest Docs covering the Backend implementation</a><br>
</div>
