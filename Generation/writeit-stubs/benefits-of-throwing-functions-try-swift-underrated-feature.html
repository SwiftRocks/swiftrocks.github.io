
<!--WRITEIT_POST_NAME=Benefits of using throwing functions (try) - Swift's most underrated feature?-->
<!--WRITEIT_POST_HTML_NAME=benefits-of-throwing-functions-try-swift-underrated-feature-->

<!--Add here the additional properties that you want each page to possess.-->
<!--These properties can be used to change content in the template page or in the page itself as shown here.-->
<!--Properties must start with 'WRITEIT_POST'.-->
<!--Writeit provides and injects WRITEIT_POST_NAME and WRITEIT_POST_HTML_NAME by default.-->

<!--WRITEIT_POST_SHORT_DESCRIPTION=I've always found throwing functions to be a very underrated feature in the Swift community. In this article, I've separated some of the benefits of this feature that have drawn my attention the most and shared some of my thoughts on why you should give it a second chance.-->
<!--WRITEIT_POST_SITEMAP_DATE_LAST_MOD=2020-06-03T14:00:00+02:00-->
<!--WRITEIT_POST_SITEMAP_DATE=2020-06-03T14:00:00+02:00-->

<title>$WRITEIT_POST_NAME</title>
<div class="col-md-12 blog-post"> 
<div class="post-title"> 
  <h1>Benefits of using throwing functions (try) - Swift's most underrated feature?</h1> 
</div> 
<div class="post-info"> 
June 15th, 2020
</div>
<p>I've always found throwing functions (<code>try/catch</code>, or <code>do/catch</code>) to be a very underrated feature in the Swift community. While many native APIs from iOS rely on it, very few people seem to actually use them in their daily projects. Most people seem to either optionally unwrap them (<code>try?</code>) or use other features like the <code>Result</code> type, and in my opinion, this stems from the fact that unless your entire project is built around throwing, the parts that do use it are somewhat annoying to deal with, and don't look very nice code-wise:</p>
<pre>
<code>func getAValue() -> Int? {</code>
<code>    do {</code>
<code>        let content = try getAnInteger()</code>
<code>    } catch {</code>
<code>        return nil</code>
<code>    }</code>
<code>}</code>
</pre>
<p>I've personally avoided this feature a lot for these reasons in favor of things like <b>Promises</b> or the new <code>Result&lt;></code> type, but even then, I still felt that my way of handling errors wasn't good. In fact, I was often falling into the same pitfalls, just in different ways. When I recently refactored one of my open-source CLI tools, I noticed that parts of it would not only look better if they used throwing functions instead, but they also would be considerably easier to unit test. I decided to try it out by refactoring that tool to use this feature, but to avoid falling into that same pit, I made the <b>entire</b> tool rely on it.</p> 
<p>The results exceeded all of my expectations. With about ~80% of code coverage, the tool is now very easy to maintain and evolve thanks to the benefits of throwing functions. In this article, I've separated some of the benefits of this feature that have drawn my attention the most and shared some of my thoughts on why you should give it a second chance.</p>
<h2>Throwing functions clean your code by allowing you to focus on what matters</h2>
<p>When you need the value of something wrapped in the <code>Result</code> type, you must switch its result immediately. This will make your method responsible for handling any errors associated with that result:</p>
<pre>
<code>func getUserProfile() -> Result&lt;Profile, Error> {</code>
<code>    let result = database.profileSchema</code>
<code>    switch result {</code>
<code>    case .success(let profileSchema)</code>
<code>        let profile = Profile(profileSchema)</code>
<code>        return .success(profile)</code>
<code>    case .error(let error)</code>
<code>        return .error(error)</code>
<code>    }</code>
<code>}</code>
</pre>
<p>This method now has <b>two responsibilities</b> which must ideally be covered by unit tests, which might not be your intention.</p>
<p>When you use <code>try</code> in a method that is itself <code>throws</code>, you can <b>delegate the treatment of errors to the code that is actually interested in it.</b> This allows you to develop methods that only handle their success cases:</p>
<pre>
<code>func getUserProfile() throws {</code>
<code>    let result = try database.profileSchema</code>
<code>    return Profile(profileSchema)</code>
<code>}</code>
</pre>
<p>As you can see, I don't need to worry about the database failing to fetch the user's profile schema in this specific method because that's not the point of it -- someone else will handle it if it happens. With these changes, this method is now so short that it possibly doesn't even need to exist anymore -- it could be refactored to a simple `try Profile(database: database)` call (initializers can also be <code>throws</code>!). This benefit is especially visible when your access depends on multiple things that can fail:</p>
<pre>
<code>func migrateDefaultsToDatabase() throws {</code>
<code>    let oldUserProfile = try defaultsWrapper.profileJSON</code>
<code>    let converted = try databaseConverter.convertToDatabaseFormat(defaultsWrapper)</code>
<code>    try database.set(converted, to: .profile)</code>
<code>}</code>
</pre>
<p>Without throwing functions, you would probably have to divide this operation into multiple methods.</p>
<h2>Throwing functions allows you to better design / unit test fatal problems</h2>
<p>In CLI tools, it's common to halt everything or cause a crash when something goes wrong, like failing to open a file:</p>
<pre>
<code>func obfuscate(file: File) {</code>
<code>    guard let contents = open(file) else {</code>
<code>        preconditionFailure()</code>
<code>    }</code>
<code>    let obfuscatedVersion = obfuscate(string: contents) // can also crash internally!</code>
<code>    guard success = save(contents, toFile: file) else {</code>
<code>        preconditionFailure()</code>
<code>    }</code>
<code>}</code>
</pre>
<p>Not only this method is impossible to unit test by itself, but other unit tests might also trip these failure conditions and crash your test bundle entirely. While your iOS app probably doesn't crash in these conditions, I have seen my share of similar conditions: using an optional <code>try?</code>, returning things like <code>nil</code> or an empty string, logging the occurrence and having the methods who rely on this information be able to treat these special cases. This can be made better by using <code>Result</code>, but that can make you fall back to the previous issue: your methods now do more than they have to.</p>
<p>Similar to the previous benefit, you can use <code>throws</code> here and defer the actual crash / failure to someone who is actually interested in it. In the case of my CLI tool, all fatal conditions will throw a special <code>FatalError</code>, which only results in a crash if handled by <code>main.swift</code>. In fact, <code>main.swift</code> is the only part of the code that even attempts to handle errors. Everything in the tool is delegate to it, which made the tool's code considerably cleaner.</p>
<pre>
<code>func obfuscate(file: File) throws {</code>
<code>    let contents = try open(file)</code>
<code>    let obfuscatedVersion = try obfuscate(string: contents)</code>
<code>    try save(contents, toFile: file)</code>
<code>}</code>
</pre>
<p>You can now unit test that this method succeeds if everything is fine and proceed with your life. It's not necessary to unit test this method's specific failure conditions because the errors are not only <b>not</b> coming from it, it also doesn't handle them -- it just sends them downstream.</p>
<p>For reference, here's an example of a method in my CLI tool that generates a failure condition:</p>
<pre>
<code>public func deobfuscate(crashFilePath: String, mapPath: String) throws {</code>
<code>    let crashFile = File(path: crashFilePath)</code>
<code>    let crash = try crashFile.read()</code>
<code>    let mapString = try File(path: mapPath).read()</code>
<code>    guard let map = ConversionMap(mapString: mapString) else {</code>
<code>        throw logger.fatalError(forMessage: "Failed to parse conversion map. Have you passed the correct file?")</code>
<code>    }</code>
<code>    let result = replace(crashLog: crash, withContentsOfMap: map)</code>
<code>    try crashFile.write(contents: result)</code>
<code>}</code>
</pre>
<p>Custom errors can be made by creating enums that conform to <code>Error</code>. Personally, I like making my custom error inherit from <code>LocalizedError</code> to make <code>error.localizedDescription</code> return a custom description. This can be done by implementing its <code>errorDescription</code> property. (implementing <code>localizedDescription</code> directly doesn't work)</p>
<pre>
<code>public enum SwiftShieldError: Error, LocalizedError {</code>
<code>    case fatal(String)</code>
<code></code>
<code>    public var errorDescription: String? {</code>
<code>        switch self {</code>
<code>        case .fatal(let message):</code>
<code>            return message</code>
<code>        }</code>
<code>    }</code>
<code>}</code>
<code></code>
<code>public func fatalError(forMessage message: String) -> Error {</code>
<code>    SwiftShieldError.fatal(message)</code>
<code>}</code>
</pre>
<h2>XCTestCase has special support for throwing methods</h2>
<p>Perhaps my favorite benefit is that <b>XCTestCase can automatically handle failures in throwing functions.</b> Here's a classic example on how would I unit test something that used <code>Result</code>:</p>
<pre>
<code>func testSomethingUsingResult() {</code>
<code>    let result: Result&lt;String, Error> = getAResult()</code>
<code>    guard let string = result.get() else {</code>
<code>        XCTFail()</code>
<code>    } // You could also use the new XCTUnwrap here.</code>
<code>    XCTAssertEqual(string, "aString")</code>
<code>}</code>
</pre>
<p>Having to bypass error conditions tests is very annoying. Fortunately, XCTestCase allows you to mark any test method as <code>throws</code>, making it automatically fail the test if it throws. By making the example's <code>getAResult()</code> become a throwing <code>getAString()</code> instead, you can refactor this test to a single line and completely ignore the failure conditions.</p>
<pre>
<code>func testSomethingUsingTryCatch() throws {</code>
<code>    XCTAssertEqual(try getAString(), "aString")</code>
<code>}</code>
</pre>
<p>If you would like to do the reverse, which is testing if something fails, there's no need to switch the result -- you can use the special <code>XCTAssertThrowsError</code> method. You can also use <code>XCTAssertNoThrow</code> to test that something succeeds when the result itself isn't what is being tested.</p>
<p>In general, what I like about this is that I don't need to consider failure cases when the test subject itself isn't the one throwing the errors. If I want to test that this method is working, all I have to do is test its success cases. If anything fails upstream, the test will throw an error and fail. This makes unit testing considerably easier and faster, while still being very durable (if not <b>more</b> durable, in my opinion).</p>
<h2><code>Result</code> can be translated from/to throwing functions</h2>
<p>Although <code>Result</code> is sometimes seen as the opposite to throwing functions, they are actually somewhat interchangeable. It's possible to build <code>Result</code> types from throwing operations and get throwing operations from existing <code>Result</code> instances, which might be helpful if you'd like to play with throwing functions in a project without fully commiting to it.</p>
<pre>
<code>let result: Result&lt;String, Error> = Result(catching: { try file.read() })</code>
<code>let contents = try result.get()</code>
</pre>
<h2>Conclusion</h2>
<p>Using throwing functions has been extremely beneficial in my new project, but as I said in the beginning, you might find that most of these benefits only apply if your project is <b>completely</b> using them to handle errors. Still, even if you don't have a full project, you can use <code>Result</code>'s special initializers to treat the gaps and benefit from cleaner methods and more durable unit tests.</p>
<p>The project in question is <a href="https://github.com/rockbruno/swiftshield">SwiftShield</a>. Make sure to check it out (especially the test cases!) to see how these benefits are translated to code.</p>
</div>
