<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
    <title>SwiftRocks</title>
    <description>SwiftRocks is a blog about how Swift works and general iOS tips and tricks.</description>
    <language>en-us</language>
    <copyright>2019 Bruno Rocha</copyright>
    <link>https://swiftrocks.com</link>
    <atom:link href="https://swiftrocks.com/rss.xml" rel="self" type="application/rss+xml"/><item>
    <title>Detecting Broken Constraints in Swift</title>
    <link>https://swiftrocks.com/detecting-broken-constraints-in-swift</link>
    <guid>https://swiftrocks.com/detecting-broken-constraints-in-swift</guid>
    <pubDate>Mon, 22 Nov 2021 09:00:00 GMT-3</pubDate>
<description><![CDATA[
<!--WRITEIT_POST_NAME=Detecting Broken Constraints in Swift-->
<!--WRITEIT_POST_HTML_NAME=detecting-broken-constraints-in-swift-->

<!--Add here the additional properties that you want each page to possess.-->
<!--These properties can be used to change content in the template page or in the page itself as shown here.-->
<!--Properties must start with 'WRITEIT_POST'.-->
<!--Writeit provides and injects WRITEIT_POST_NAME and WRITEIT_POST_HTML_NAME by default.-->

<!--WRITEIT_POST_SHORT_DESCRIPTION=In this article, I'd like to show a way you can intercept UIKit's exceptions directly in code (not using breakpoints!) and what you can use an implementation like this for.-->

<!--DateFormat example: 2021-04-12T14:00:00+02:00-->
<!--WRITEIT_POST_SITEMAP_DATE_LAST_MOD=2021-11-22T14:00:00+02:00-->
<!--WRITEIT_POST_SITEMAP_DATE=2021-11-22T14:00:00+02:00-->

<title>Detecting Broken Constraints in Swift</title>
<div class="blog-post">
  <div class="post-title-index">
    <h1>Detecting Broken Constraints in Swift</h1>
  </div>  
  <div class="post-info">
    <div class="category category-ios">iOS</div>
    <div class="category category-swift">Swift</div>
    <div class="post-info-text">Published on 22 Nov 2021</div>
  </div>
<p>Broken constraints are common, but there are good reasons you might wanted to get them sorted out. Even though iOS can sometimes provide a functional UI after breaking a constraint, the additional layout passes that this requires are usually a performance issue. If you care about your users' battery usage, you'll want to make sure your UI is always configured and rendered properly.</p>
<div class="sponsor-article-ad-auto hidden"></div>
<p>In this article, I'd like to show a way you can intercept UIKit's exceptions directly in code (not using breakpoints!) and what you can use an implementation like this for.</p>
<h2>How do broken constraint alerts work?</h2>
<p>The alert you get in Xcode when a constraint breaks is a really interesting little detail of UIKit. Although the alert describes it as an "exception", <code>UIViewAlertForUnsatisfiableConstraints</code> is actually a global C function:</p>
<div class="post-image">
  <img src="https://i.imgur.com/lGt3BqP.png" alt="Alt">                                    
</div>
<p>I imagine the reason they made that choice is because that would be the easiest way to allow you, a developer outside UIKit, to debug such issues -- if you the name of the method that causes something, you can attach a symbolic lldb breakpoint to it. And that's exactly what the alert suggests you to do.</p>
<p>At the time this article was written, UIKit contains four "exceptions":</p>
<ul>
<li>_UIViewAlertForUnsatisfiableConstraints</li>
<li>_UITableViewAlertForForcedLayout</li>
<li>_UITableViewAlertForLayoutOutsideViewHierarchy</li>
<li>_UITableViewAlertForVisibleCellsAccessDuringUpdate</li>
</ul>
<p>Although you can easily intercept these issues in a debug build by creating a symbolic breakpoint, I spent quite a while trying to figure out how to do that directly in the code. The reason for that is because I wanted to also be able to detect broken constraints in <b>internal releases</b> so that our beta testers could also find and report these issues.</p>
<p>When it comes to altering framework execution, the answer is clearly <b>method swizzling</b>. Unfortunately, after a long search, I couldn't find any easy way to swizzle a global C function. I did eventually find <a href="https://github.com/facebook/fishhook/blob/main/fishhook.c">fishhook</a>, which is an utility created by Facebook that is capable of modifying dynamic loader load commands, but it didn't work for UIKit's content for caching reasons. I don't think this is impossible to do per-se, but it's definitely complicated enough to make me not want to bother with it.</p>
<p>Instead, what we need to is find the closest Obj-C method that calls these methods and swizzle that instead. Luckily, in the case of the constraints, we have a very good candidate right off the bat!</p>
<div class="post-image">
  <img src="https://i.imgur.com/KUQyaXr.png" alt="Alt">                                    
</div>
<p>The <code>engine:willBreakConstraint:dueToMutuallyExclusiveConstraints:</code> private method does nothing but to call the relevant C function, making it a perfect swizzling candidate.</p>
<h2>Swizzling in Swift</h2>
<p>To swizzle this method, I've decided to create a central "interception" object that would bootstrap the swizzling and listen for any broken constraints in the form of a notification. This is because the method above is inside <code>UIView</code>, so notifications work as an easy way to transmit that information somewhere else.</p>
<pre>
<code>import Foundation</code>
<code>import UIKit</code>
<code></code>
<code>extension Notification.Name {</code>
<code>    static let willBreakConstraint = Notification.Name(</code>
<code>        rawValue: "NSISEngineWillBreakConstraint"</code>
<code>    )</code>
<code>}</code>
<code></code>
<code>final class ConstraintWarningCatcher {</code>
<code></code>
<code>    func startListening() {</code>
<code>        // Note: Only call this **once**!</code>
<code>        let sel = NSSelectorFromString("engine:willBreakConstraint:dueToMutuallyExclusiveConstraints:")</code>
<code>        let method = class_getInstanceMethod(UIView.self, sel)!</code>
<code>        let impl = method_getImplementation(method)</code>
<code></code>
<code>        let replSel = #selector(UIView.willBreakConstraint(_:_:_:))</code>
<code>        let replMethod = class_getInstanceMethod(UIView.self, replSel)!</code>
<code>        let replImpl = method_getImplementation(replMethod)</code>
<code></code>
<code>        class_replaceMethod(UIView.self, sel, replImpl, method_getTypeEncoding(replImpl))</code>
<code>        class_replaceMethod(UIView.self, replSel, impl, method_getTypeEncoding(impl))</code>
<code></code>
<code>        NotificationCenter.default.addObserver(</code>
<code>            self,</code>
<code>            selector: #selector(didReceiveBrokenConstraintNotification),</code>
<code>            name: .willBreakConstraint,</code>
<code>            object: nil</code>
<code>        )</code>
<code>    }</code>
<code></code>
<code>    @objc func didReceiveBrokenConstraintNotification(notification: NSNotification) {</code>
<code>        guard let constraint = notification.object as? NSLayoutConstraint else {</code>
<code>            return</code>
<code>        }</code>
<code>        // do something with this information</code>
<code>    }</code>
<code>}</code>
<code></code>
<code>extension UIView {</code>
<code>    @objc func willBreakConstraint(_ engine: Any, _ constraint: NSLayoutConstraint, _ conflict: Any) {</code>
<code>        willBreakConstraint(engine, constraint, conflict) // swizzled, will call original impl instead</code>
<code>        NotificationCenter.default.post(</code>
<code>            name: .willBreakConstraint,</code>
<code>            object: constraint</code>
<code>        )</code>
<code>    }</code>
<code>}</code>
</pre>
<p>From here, you can keep an instance of <code>ConstraintWarningCatcher</code> alive and start the observation. When a constraint breaks, the instance will receive a notification.</p>
<pre>
<code>let catcher = ConstraintWarningCatcher()</code>
<code>catcher.startListening()</code>
<code></code>
<code>let v = UIView()</code>
<code>v.heightAnchor.constraint(equalToConstant: 50).isActive = true</code>
<code>v.heightAnchor.constraint(equalToConstant: 100).isActive = true</code>
<code>view.addSubview(v) // A constraint will break and the catcher will be notified</code>
</pre>
<p><b>An important note to be made is that you should never push code involving private APIs to production.</b> In the event that Apple doesn't reject your app (they probably will), there's nothing guaranteeing that Apple won't change how this API works, which could have immediate and devastating effects in your app. Keep this only in your debug builds.</p>
<h2>What can you use this for?</h2>
<div class="sponsor-article-ad-auto hidden"></div>
<p>For me, what I find this most useful for is that it allows you to have your own backlog of constraint issues. Instead of relying solely on breakpoints, you could use this interception to send this information somewhere (ex: Firebase). Just remember to never push this to actual production builds!</p>
<p>Unfortunately, I couldn't find a good way to swizzle the other exceptions mentioned in this article. Although they are indeed called from Obj-C methods deeper down, these methods are also handling tons of other things, which makes swizzling them a very dangerous idea. Still, being able to do that to constraints alone is already a very good win in my book.</p>
</div>
]]></description>
</item>
<item>
    <title>How To Solve Any iOS Crash Ever</title>
    <link>https://swiftrocks.com/how-to-solve-any-ios-crash-ever</link>
    <guid>https://swiftrocks.com/how-to-solve-any-ios-crash-ever</guid>
    <pubDate>Mon, 1 Nov 2021 09:00:00 GMT-3</pubDate>
<description><![CDATA[
<!--WRITEIT_POST_NAME=How To Solve Any iOS Crash Ever-->
<!--WRITEIT_POST_HTML_NAME=how-to-solve-any-ios-crash-ever-->

<!--Add here the additional properties that you want each page to possess.-->
<!--These properties can be used to change content in the template page or in the page itself as shown here.-->
<!--Properties must start with 'WRITEIT_POST'.-->
<!--Writeit provides and injects WRITEIT_POST_NAME and WRITEIT_POST_HTML_NAME by default.-->

<!--WRITEIT_POST_SHORT_DESCRIPTION=Ever had a crash in which you had absolutely no idea what was going on, and no amount of testing allowed you to reproduce the issue? If so, you've come to the right place!-->

<!--DateFormat example: 2021-11-02T14:00:00+02:00-->
<!--WRITEIT_POST_SITEMAP_DATE_LAST_MOD=2021-11-01T14:00:00+02:00-->
<!--WRITEIT_POST_SITEMAP_DATE=2021-11-01T14:00:00+02:00-->

<title>How To Solve Any iOS Crash Ever</title>
<div class="blog-post">
  <div class="post-title-index">
    <h1>How To Solve Any iOS Crash Ever</h1>
  </div>  
  <div class="post-info">
    <div class="category category-ios">iOS</div>
    <div class="post-info-text">Published on 01 Nov 2021</div>
  </div>
<p><i>Closed: Cannot Reproduce</i></p>
<p>Ever had a crash in which you had absolutely no idea what was going on, and no amount of testing allowed you to reproduce the issue? If so, you've come to the right place!</p>
<div class="sponsor-article-ad-auto hidden"></div>
<p>Well, sort of. As you'll see in this article, the ability to debug complex crashes is not something immediate. Keep this out of your expectations: there's no magical instrument that you forgot to run that will give you the output you're expecting. When it comes to complex crashes, what we need to do instead is <i>prepare</i> our environment so that these issues are better understood when they arrive, making them more actionable. Let's see how to do that!</p>
<h2>What are complex crashes?</h2>
<p>One thing that I find helpful is to rationalize the issue. It's easy to look at a weird issue and just dismiss it as something magical that will never again, but that makes no sense. There's always a perfectly logical reason the issue happened (most likely your fault), and the more users are affected by it, the more likely it's that this is not a freak accident. So how come you might be looking right now at an issue that affects a high amount of users, and still you have no idea what's going on or how to reproduce it?</p>
<p>In my experience, the inability to understand a crash will always boil down to <b>a lack of information</b>. The problem is <i>never</i> that the issue is "too complicated", <b>but that you don't have enough data.</b> Think about the weirdest crash you ever had to look at: wouldn't it be a lot less complicated if the crash report told you exactly what the issue was and how to solve it? It doesn't matter how bizarre a crash is, it's your ability to understand and reproduce the issue which dictates how likely it's to be solved.</p>
<p>Thus, if you want to be able to solve any crash ever, you need to enhance the data that accompanies them. Let's take a look at a couple of ways do to that!</p>
<h2>App-specific metadata</h2>
<p>You might have noticed that crash platforms like Firebase will always include some useful pieces of device-related metadata on your crashes, such as the most common iOS version causing the crash, if the users were in foreground or background, if the devices are jailbroken, how much disk space each user had left when the crash happened, and so on. These are extremely useful, but are not nearly enough. What you truly need here is to include metadata of <b>your app</b> which helps you pinpoint what the user was doing at the moment of the crash. Some examples of things you should add are:</p>
<ul>
<li>The screen the user was looking at</li>
<li>The "type" of the user, if applicable (free? premium? logged out?)</li>
<li>The last action the user did (did they try to navigate somewhere?)</li>
<li>Did the app finish launching correctly?</li>
<li>Did the user receive a memory warning?</li>
<li>Is the app shutting down?</li>
<li>Does the user have an active internet connection?</li>
<li>Which language is the user seeing?</li>
</ul>
<p>It's hard to provide a complete list given that this will be completely different from app to app, but what you need to do here is essentially assemble everything that you can think about your app that can make a difference in its execution and include it to your crash reports.</p>
<p>You can add this information to Firebase through its SDK's key/value pairs API, but in order to see this information as percentages you will probably have to abstract Firebase under your own crash reporting backend.</p>
<h2>Analytics</h2>
<p>In addition to metadata, another critical component is to have a solid analytics infrastructure in your app. This is something that most apps might already include, though you might require some changes to make it useable for crash reporting purposes.</p>
<p>The point here is that if you have a solid analytics implementation, you should be able to use it to replay a users steps to the crash. Thus, for this to happen, you need to make sure your analytics SDK is receiving as much information as possible regarding user interactions like:</p>
<ul>
<li>"User touched button X"</li>
<li>"User saw banner Y"</li>
<li>"User navigated to screen Z"</li>
</ul>
<p>For the replayability itself, most third-party SDKs nowadays include a "timeline" feature that shows you all the events sent by a particular user around a specific time.</p>
<h2>Using this information to solve crashes</h2>
<p>Finally, with your crashes receiving as much information as possible about the state of the app at the moment of the crash, you can now follow this step-by-step guide I made that should help you track down and solve the great majority of cases!</p>
<h3>Check the crashed thread</h3>
<p>If you're reading this guide it probably means that you already tried this and it didn't work, but it's good to mention anyway that for the huge majority of cases the answer lies directly in the crashed trace. By checking the path the code took, you may be able to locate and reproduce the issue.</p>
<h3>Check the metadata for the crash</h3>
<p>If the trace is vague, then looking at your added metadata may reveal the issue. When looking at the metadata, pay attention to values that are close to either 100% or 0%. This may reveal that the crash is tied to a very specific device or condition inside the app.</p>
<h3>Check the background threads of the crash</h3>
<p>If the metadata is <i>also</i> vague, then it may mean that the crashed code is not the problem itself, but more of an indirect consequence of a problem that happened asynchronously somewhere else. In this situation, you may be able to locate the issue by looking at what's happening in the other threads of the crash. Try grabbing many occurrences of the crash and compare their threads with each other. Do they all have something in common that you don't see in other issues? If so, that could be the cause of the problem.</p>
<h3>Match the environment of the crashing users</h3>
<p>If after deeply analyzing the trace and metadata you still can't figure out what's going on, it may be the case that the crash is tied to a specific device and/or AB test. If that's the case, then you should be able to reproduce the crash by matching the user's environment. Besides making sure to use the exact phone/OS version that the user experienced the crash on, make sure that you're also matching the user's AB testing flags (if your app has them).</p>
<p>Regarding flags, one very useful thing to do is to compare the flags of a list of users with the issue against those of a list of users <b>without</b> the issue. If the issue is connected to a flag, then compiling a list of common flags in these groups will reveal which flag (or lack of, if the issue was caused by removing an experiment) is causing the problem.</p>
<p>EDIT: <a href="https://twitter.com/daveverwer">Dave Verwer</a> also mentioned something important that I forgot to add -- make sure to also run the exact build of the app that the users are crashing on! It's not unlikely for the changes on your branch to affect the conditions for the crash, so always make sure you're on the exact commit the build was archived on. You can gain this ability by making your CI create a git tag every time it uploads a new build -- by naming the tag with the correspondent build number, you'll have the power to rollback to any release you've ever created.</p>
<h3>Retrace the user's steps</h3>
<p>If everything proved to be useless, you should be able to reproduce the issue by mimicking what the users are doing before the crash happens. This can sometimes be something absurdly specific like opening/closing the app a couple of times, turning it upside-down, opening a playlist and then throwing the device against a wall, and if that's the case, then you should be able to find these steps by looking at your analytics SDK's timeline for that user.</p>
<p>It's important to note that it's possible that the conditions to trigger the issue can span <b>multiple</b> sessions, like an issue that involves content that was downloaded a couple of days ago. In cases like that, understanding the issue requires looking not only at the data of the session where the crash happened, but also of the sessions that came before it.</p>
<h3>Instrument for thread / memory safety issues</h3>
<p>If you <b>still</b> can't figure out what's happening, then you may be dealing with a non-deterministic issue caused by either thread safety issues such as race conditions or memory issues like heap corruption. There's unfortunately no easy way of figuring these out, and you'll need to have a deep understanding of the code to catch them. In iOS, the Zombies instrument and the thread/memory sanitizers can be of some help.</p>
<p>The best thing you can do here is to prevent these from being possible to happen in the first place. If you're working with asynchronous code, always be 100% sure that your implementation is thread-safe for all its usage scenarios before merging it. While thread-related issues are very easy to introduce, they're extremely hard to debug. Choose to always be on the safer side to avoid issues like this in the future.</p>
<h3>Check what was introduced in the release the crash started</h3>
<p>In some cases, especially very old issues, it can be helpful to track down the exact version the issue started happening and hop into GitHub to see what exactly was introduced in that release. If nothing worked, then reverting suspicious pull requests could do the trick.</p>
<h3>Add more logs</h3>
<p>In the event that you have absolutely no clue what's happening, then adding additional logs could provide some relief. Firebase allows you to attach generic logs to a crash report, and one way you can use them is to log information about the state of the user's app around the place the crash happens. Try to think of anything weird or unintentional that can happen around the code that is crashing and log it to Firebase -- in the next release, you'll be able to see them alongside the crashes. They can also be useful even before you push a new feature; if you think a new feature could cause issues, you can already safeguard it with logs before it's even released. In the event that it does cause an issue, you'll already have the additional information you need to debug it.</p>
<h3>What else?</h3>
<p>If you reach this far, then it's possible for your initial thoughts might be true: you're dealing with some bizarre hardware problem caused by the sun's radiation at a specific time of the day for a specific user in Latvia.</p>
<div class="sponsor-article-ad-auto hidden"></div>
<p>To avoid situations like this, I personally try to completely avoid looking into issues until they are consistently happening for a sufficiently large amount of users. It's always possible for issues to be caused by situational things, but unless they are consistent or of high impact, it's probably best to ignore them to avoid the possibility of wasting your time looking into something that turns out to not be your fault.</p> 
</div>
]]></description>
</item>
<item>
    <title>Enabling Module Stability in Swift Package Manager Projects</title>
    <link>https://swiftrocks.com/enabling-module-stability-in-swift-package-manager-projects</link>
    <guid>https://swiftrocks.com/enabling-module-stability-in-swift-package-manager-projects</guid>
    <pubDate>Tue, 26 Oct 2021 09:00:00 GMT-3</pubDate>
<description><![CDATA[
<!--WRITEIT_POST_NAME=Enabling Module Stability in Swift Package Manager Projects-->
<!--WRITEIT_POST_HTML_NAME=enabling-module-stability-in-swift-package-manager-projects-->

<!--Add here the additional properties that you want each page to possess.-->
<!--These properties can be used to change content in the template page or in the page itself as shown here.-->
<!--Properties must start with 'WRITEIT_POST'.-->
<!--Writeit provides and injects WRITEIT_POST_NAME and WRITEIT_POST_HTML_NAME by default.-->

<!--WRITEIT_POST_SHORT_DESCRIPTION=Uh-oh! You've been visited by the module stability fairy. Let's see how to solve this classic error.-->

<!--DateFormat example: 2021-10-12T14:00:00+02:00-->
<!--WRITEIT_POST_SITEMAP_DATE_LAST_MOD=2021-10-26T14:00:00+02:00-->
<!--WRITEIT_POST_SITEMAP_DATE=2021-10-26T14:00:00+02:00-->

<title>Enabling Module Stability in Swift Package Manager Projects</title>
<div class="blog-post">
  <div class="post-title-index">
    <h1>Enabling Module Stability in Swift Package Manager Projects</h1>
  </div>  
  <div class="post-info">
    <div class="category category-compiler">Compiler</div>
    <div class="category category-swift">Swift</div>
    <div class="post-info-text">Published on 26 Oct 2021</div>
  </div>
<p><i>Module compiled with Swift X cannot be imported by the Swift Y compiler</i></p>
<p>Uh-oh! You've been visited by the module stability fairy. <i>"Wait a second, didn't they fix this in Swift 5?"</i> you ask, to no avail.</p>
<div class="sponsor-article-ad-auto hidden"></div>
<p>Technically, yes and no. Stable binary interfaces were introduced in Swift 5 to allow apps built with the Swift 5.0 compiler to use the Swift runtime and standard library built into the operating system, and to make sure that existing apps will remain compatible with new versions of the Swift runtime in future operating system releases.</p>
<p>This error refers to <i>module stability</i>, which was introduced in Swift 5.1 to allow Swift modules built with different compiler versions to be used together in one app. While this is possible, it's something you need to explictly enable. This is because module stability currently requires <b>Library Evolution</b> to also be enabled, which is a setting that ensures that newer versions of your module will not break previous releases.</p>
<p>If you search this error on Google, you'll get a bunch of StackOverflow answers saying "well, all you have to do is enable this in Xcode!" Pretty cool, except that I'm not using Xcode, god damnit!</p>
<h2>Enabling Module Stability in the CLI</h2>
<p>Before enabling module stability, make sure that you actually need it. According to Swift's official docs, library evolution support should only be used when a framework is going to be built and updated separately from its clients.</p>
<p>This use case is exactly how you end up with that error in the first place, so I'm assuming that you're enabling it for the right reasons.</p>
<p>To compile with module stability outside of Xcode, we need to pass the following flags:</p>
<ul> 
  <li>-emit-module-interface</li> 
  <li>-enable-library-evolution</li> 
</ul>
<p>For SPM, you can do it by passing <code>Xswiftc</code> flags like this:</p>
<pre>
<code>swift build -c release -Xswiftc -emit-module-interface -Xswiftc -enable-library-evolution</code>
</pre>
<p>This will result in a series of <code>.swiftinterface</code> files being generated, which you need ship alongside the binary.</p>
<h2>Library Evolution Implications</h2>
<p>While this is straight-forward, enabling module stability / library evolution means you now need to be careful about how you make changes to your library. Because clients can now technically swap versions of your framework without being recompiled, you cannot introduce binary breaking changes in future updates. The compiler has features to assist you with this, so you'll know exactly when this happens.</p>
<p>I wish it was possible to uncouple these two concepts, because you don't need to worry about binary compability if you're also in control of the clients. This is the case of <a href="https://github.com/rockbruno/SwiftInfo">SwiftInfo</a>, in which I need use module stability due to way the Swift inputs are read. The Swift team is aware of this, so maybe this will happen in the near future.</p>
<h2>Module Stability Limitations</h2>
<p>If you enable module stability, you need to make sure you don't have types with the same name as your module. Basically, interface files will reference types with the qualified format <code>Module.Type</code>, which you can't do in Swift if they have the same name. This is a limitation of the compiler that has not yet been resolved, <a href="https://forums.swift.org/t/frameworkname-is-not-a-member-type-of-frameworkname-errors-inside-swiftinterface/28962">and you can read more about it here.</a>
<p>One way to workaround this is to modify the <code>.swiftinterface</code> file after compiling the framework to remove all broken module references. My colleague Andr√© Alves added the following script to solve this in SwiftInfo, which depends on a framework called <code>XcodeProj</code> that has this issue:</p>
<pre>
<code>sed -i '' 's/XcodeProj\.//g' XcodeProj.swiftinterface</code>
</pre>
<div class="sponsor-article-ad-auto hidden"></div>
<p>Essentially, this transforms references to <code>XcodeProj.XcodeProj</code> into <code>XcodeProj</code>, countering the limitation.</p>
</div>
]]></description>
</item>
<item>
    <title>Unit Testing Weak References / Retain Cycles in Swift</title>
    <link>https://swiftrocks.com/unit-testing-weak-references--deallocation-in-swift</link>
    <guid>https://swiftrocks.com/unit-testing-weak-references--deallocation-in-swift</guid>
    <pubDate>Wed, 13 Oct 2021 09:00:00 GMT-3</pubDate>
<description><![CDATA[
<!--WRITEIT_POST_NAME=Unit Testing Weak References / Retain Cycles in Swift-->
<!--WRITEIT_POST_HTML_NAME=unit-testing-weak-references--deallocation-in-swift-->

<!--Add here the additional properties that you want each page to possess.-->
<!--These properties can be used to change content in the template page or in the page itself as shown here.-->
<!--Properties must start with 'WRITEIT_POST'.-->
<!--Writeit provides and injects WRITEIT_POST_NAME and WRITEIT_POST_HTML_NAME by default.-->

<!--WRITEIT_POST_SHORT_DESCRIPTION=Code that relies on memory tricks to work can be complicated, but there's a solid way of unit testing these cases.-->

<!--DateFormat example: 2021-10-13T14:00:00+02:00-->
<!--WRITEIT_POST_SITEMAP_DATE_LAST_MOD=2021-10-13T14:00:00+02:00-->
<!--WRITEIT_POST_SITEMAP_DATE=2021-10-13T14:00:00+02:00-->

<title>Unit Testing Weak References / Retain Cycles in Swift</title>
<div class="blog-post">
  <div class="post-title-index">
    <h1>Unit Testing Weak References / Retain Cycles in Swift</h1>
  </div>  
  <div class="post-info">
    <div class="category category-swift">Swift</div>
    <div class="post-info-text">Published on 13 Oct 2021</div>
  </div>
<p>Code that relies on memory tricks to work can be complicated, but there's a solid way of unit testing these cases. I see people wonder about this every once in a while, so I think it's a good moment to share the trick I use to achieve this.</p>
<div class="sponsor-article-ad-auto hidden"></div>
<p>Any sort of deallocation unit testing can be achieved by using <code>autoreleasepool</code>. I already wrote an article about it in the past, so if you're unfamiliar with this feature, <a href="https://swiftrocks.com/autoreleasepool-in-swift">here's a good place to start</a> before reading this article.</p>
<p>In short, while in normal development a property's release is done at the <code>autoreleasepool</code> of the thread's <code>RunLoop</code>, you can create your own pools to have finer-grained control. For tests, pools can be used to validate <code>weak</code> references and test code that runs in a class' <code>deinit</code>.</p>
<p>Here's a simple example where we can see it in action. Let's assume that we want to test that a class' deinit is being called:</p>
<pre>
<code>func testClassDeinitIsCalled() {</code>
<code>    let semaphore = DispatchSemaphore(value: 0)</code>
<code>    final class TestClass {</code>
<code>        let semaphore: DispatchSemaphore</code>
<code>        init(semaphore: DispatchSemaphore) { self.semaphore = semaphore }</code>
<code>        deinit {</code>
<code>            semaphore.signal()</code>
<code>        }</code>
<code>    }</code>
<code></code>
<code>    var cls: TestClass? = TestClass(semaphore: semaphore)</code>
<code>    cls = nil</code>
<code></code>
<code>    semaphore.wait()</code>
<code>}</code>
</pre>
<p>This test will never succeed. While setting the property to <code>nil</code> does result in a <code>cls.release()</code> call by the compiler, the resources won't be freed until the main thread's current loop ends, which is going to be blocked by the test's execution. You could technically make this work by initializing the class in a different thread, but there's a much easier way!</p>
<pre>
<code>func testClassDeinitIsCalled() {</code>
<code>    let semaphore = DispatchSemaphore(value: 0)</code>
<code>    final class TestClass {</code>
<code>        let semaphore: DispatchSemaphore</code>
<code>        init(semaphore: DispatchSemaphore) { self.semaphore = semaphore }</code>
<code>        deinit {</code>
<code>            semaphore.signal()</code>
<code>        }</code>
<code>    }</code>
<code></code>
<code>    autoreleasepool {</code>
<code>        let cls = TestClass(semaphore: semaphore)</code>
<code>    }</code>
<code></code>
<code>    semaphore.wait()</code>
<code>}</code>
</pre>
<p>The test now passes, because any resources created by <code>cls</code> will be freed when the pool ends, resulting in <code>deinit</code> being called.</p>
<p>My favorite use of this trick is to test that a particular component isn't causing a retain cycle. If we have two types that use each other, you can test for a retain cycle by initializing both and checking that eliminating one doesn't result in the other keeping it alive:</p>
<pre>
<code>class TypeA {</code>
<code>    weak var typeB: TypeB?</code>
<code>}</code>
<code></code>
<code>class TypeB {</code>
<code>    var typeA: TypeA?</code>
<code>}</code>
<code></code>
<code>func testNoRetainCycle() {</code>
<code></code>
<code>    let typeA = TypeA()</code>
<code>    weak var _typeB: TypeB? = nil</code>
<code></code>
<code>    autoreleasepool {</code>
<code>        let typeB = TypeB()</code>
<code>        typeB.typeA = typeA</code>
<code>        typeA.typeB = typeB</code>
<code>        _typeB = typeB</code>
<code>    }</code>
<code></code>
<code>    XCTAssertNil(_typeB)</code>
<code>}</code>
</pre>
<p>Try modifying this test yourself to see what happens! If you modify <code>TypeA</code> to cause a retain cycle, the test will fail as the test's weak reference will be unable to deallocate.</p>
<p>This trick can also be done in reverse. In this case, we're using a weak property to test that <code>TypeA</code> <b>does</b> keep <code>TypeB</code> alive:</p>
<pre>
<code>func testKeepsValueAlive() {</code>
<code></code>
<code>    let typeA = TypeA()</code>
<code>    weak var _typeB: TypeB? = nil</code>
<code></code>
<code>    autoreleasepool {</code>
<code>        let typeB = TypeB()</code>
<code>        typeA.typeB = typeB</code>
<code>        _typeB = typeB</code>
<code>    }</code>
<code></code>
<code>    XCTAssertNotNil(_typeB)</code>
<code>}</code>
</pre>
<p>If <code>TypeA</code> has a weak reference or disposes of <code>TypeB</code> after it's set, the test will fail.</p>
</div>
]]></description>
</item>
<item>
    <title>Solving CPU Usage Crashes with Xcode's Energy Organizer</title>
    <link>https://swiftrocks.com/debug-cpu-exceptions-xcode-energy-reports</link>
    <guid>https://swiftrocks.com/debug-cpu-exceptions-xcode-energy-reports</guid>
    <pubDate>Tue, 28 Sep 2021 09:00:00 GMT-3</pubDate>
<description><![CDATA[
<!--WRITEIT_POST_NAME=Solving CPU Usage Crashes with Xcode's Energy Organizer-->
<!--WRITEIT_POST_HTML_NAME=debug-cpu-exceptions-xcode-energy-reports-->

<!--Add here the additional properties that you want each page to possess.-->
<!--These properties can be used to change content in the template page or in the page itself as shown here.-->
<!--Properties must start with 'WRITEIT_POST'.-->
<!--Writeit provides and injects WRITEIT_POST_NAME and WRITEIT_POST_HTML_NAME by default.-->

<!--WRITEIT_POST_SHORT_DESCRIPTION=If you don't know what a CPU Usage termination is, consider yourself lucky. Let's explore iOS' CPU Exceptions!-->

<!--DateFormat example: 2021-09-28T14:00:00+02:00-->
<!--WRITEIT_POST_SITEMAP_DATE_LAST_MOD=2021-09-28T14:00:00+02:00-->
<!--WRITEIT_POST_SITEMAP_DATE=2021-09-28T14:00:00+02:00-->

<title>Solving CPU Usage Crashes with Xcode's Energy Organizer</title>
<div class="blog-post">
  <div class="post-title-index">
    <h1>Solving CPU Usage Crashes with Xcode's Energy Organizer</h1>
  </div>  
  <div class="post-info">
    <div class="category category-compiler">iOS</div>
    <div class="post-info-text">Published on 28 Sep 2021</div>
  </div>
<p>If you don't know what a CPU Usage termination is, consider yourself lucky. Not only this is one of the nastiest crashes you can get in iOS, but it's also not even considered as a crash by the system. These terminations are not reported to crash providers like Firebase, so if your app has a severe high CPU usage crash, you won't even know about it until your users start reporting it to you. Really nasty stuff!</p>
<div class="sponsor-article-ad-auto hidden"></div>
<p>If you found this article by googling "how the hell do I solve this CPU usage thing?", you're in good hands. I experienced some of these crashes recently, and after suffering due to the lack of proper documentation from Apple explaining this issue, I was able to aggregate several pieces of scattered information about this on the web. Let's explore iOS' CPU Exceptions!</p>
<h2>What are CPU Exceptions in iOS?</h2>
<p>According to Apple, your app is free to destroy the phone's CPU -- as long as it's running in the foreground and not doing it for a very long time. If your app is running in the <i>background</i> however, you need to cut back on CPU usage. It's not necessarily a problem to have an expensive task in the background once, but if you're consistently using over 80% CPU over a period of one minute, iOS will kill your app without warning. This is called a <b>CPU Exception</b>, or a "high CPU usage termination".</p>
<p>As far as I know, this situation is only possible if your app is using a background mode (like an audio app) as regular apps can't run in the background for large periods of time. In any case, when iOS kills your app, you'll get a report file that looks roughly like this:</p>
<pre>
<code>Event:            cpu usage</code>
<code>Action taken:     Process killed</code>
<code>CPU:              48 seconds cpu time over 52 seconds (93% cpu average), exceeding limit of 80% cpu over 60 seconds</code>
<code>CPU limit:        48s</code>
<code>Limit duration:   60s</code>
<code>CPU used:         48s</code>
<code>CPU duration:     52s</code>
<code>Duration:         51.59s</code>
<code>Duration Sampled: 47.54s</code>
<code>Steps:            44</code>
<code></code>
<code>Heaviest stack for the target process:</code>
<code>(trace)</code>
</pre>
<p>If you receive one of these logs as part of a bug report, my first advice is to ignore it completely. The problem here is that the trace is completely useless -- although it tells you roughly which part of the app is hosting the problematic code, it gives you no information about what the actual problem is, and to make it worse, every trace is going to be different from each other. Remember: The issue is not that one specific piece of code is expensive, it's that you've been doing expensive things consistently for over a minute.</p>
<p>To properly debug this problem, you'll need the reports of multiple users. By having the "expensive stack trace" of multiple instances of the termination, the idea is that we can overlay them to see what they have in common, which should hopefully pinpoint the exact line of code that is bootstrapping the entire cascade that is leading to this issue.</p>
<h2>Enter Xcode's Energy Organizer</h2>
<p>As it turns out, Apple already does this for you. If you open your Xcode's Organizer and click on the <b>Energy</b>, you'll see that Apple reports to you all instances of problematic CPU/memory usage -- including cases where it decided to terminate the app! (as long as the user has agreed to share metrics with the developer)</p>
<div class="post-image">
  <img src="https://i.imgur.com/77jLQee.png" alt="Energy Organizer">
</div>
<h2>How to Symbolicate Xcode's Energy Logs</h2>
<p>If your crashes are symbolicated, you can skip to the next section. If your crashes are <b>not</b> symbolicated then it means that the app's archive wasn't created from your machine, so we need to download its dSYMs and provide them to Xcode.</p>
<p>Unfortunately, this is one of these moments where you start to rue the fact that Apple has a monopoly on iOS developer tools, but symbolicating these logs can be a pain in the ass.</p>
<ul>
<li>Make sure you have the dSYM file for the version you're trying to symbolicate. If you're archiving the app from a CI pipeline, you should make sure your pipeline is storing the dSYMs somewhere you can retrieve them later on for cases like this. Don't trust the "Download debug symbols" button in the Archive window, because that button simply doesn't work and they never bothered to fix it.</li>
<li>Now, place the dSYM zip somewhere. It doesn't matter where, because Xcode will attempt to find it through Spotlight.</li>
<li>With everything set, open the energy report, right click the stack trace and click <code>Symbolicate</code>. If it fails, it means that your computer's Spotlight failed to index the dSYM. Fortunately that's easy to fix, <a href="https://swiftrocks.com/reverse-engineering-xcode-issue-crash-symbol">and you can find the steps at the end of my article about the symbolication process.</a></li>
</ul>
<h2>Analyzing Xcode's Energy Logs</h2>
<p>I was surprised to see how detailed the Energy Organizer is, because I didn't even know it existed before I went deep into trying to find out how to solve CPU usage issues. The organizer reports several different kinds of issues, with symbols on the log indicating the issue being reported. These symbols changed across different Xcode versions, but in my Xcode 12.4, a minus sign indicates that the app crashed.</p>
<p>For <i>High CPU Usage</i> reports and terminations, an energy log contains a sampling of CPU usage taken over a period of time. But instead of showing individual traces like in a crash, the Energy Organizer instead groups similar samplings together and show you what they have in common:</p>
<div class="post-image">
  <img src="https://i.imgur.com/QiQJHpU.png" alt="Energy Organizer">
</div>
<p>The percentage represents how many times that frame appeared in all the samples, with a massive increase of it likely indicating what line of code is causing the high CPU usage. It might not necessarily indicate that this is the root of the issue, but since everyone is congregating into it, it's at the very least indicating one of the consequences of whatever is causing the issue.</p>
<p><b>If you're trying to reproduce the termination itself, you should probably grab one of your app's Release builds and run it in a real device without a debugger attached.</b> I think it's possible to get these terminations in the simulator, but in general it's always a good idea to debug this sort of problem in a production build.</p>
<h2>How to prevent and detect high CPU usage warnings?</h2>
<p>According to Apple, the problem is not that you can't use CPU in the background, it's that you need to use the proper APIs for it. If you absolutely need to do an expensive task in the background, you should be using the proper <b>background task</b> APIs. More specifically for this issue, the <a href="https://developer.apple.com/videos/play/wwdc2020/10078/#:~:text=If%20the%20foreground%20app%20grows,for%20less%20than%2050%20megabytes.">Why is my app getting killed?</a> WWDC session from 2020 recommends using the <code>BGProcessingTask</code> API, which represents an expensive task that will only be executed when the device is in an idle state (for example, charging during the night).</p>
<p>At the beginning of this article I mentioned that the system won't treat these issues as "crashes", but there's actually you can detect them. Although they are not crashes, <code>MetricKit</code> has a special diagnostic payload specifically for this problem: <code>MXCPUExceptionDiagnostic</code>.</p>
<p>If you haven't used <code>MetricKit</code> before, it works by subscribing an object to a diagnostics reporter singleton. When that is done, the system will send a report as an array of <code>MXMetricPayload</code> objects at most once per day, containing metrics from the past 24 hours and any previously undelivered daily reports. There are many interesting metrics you can extract, but in this article we're only interested in CPU Exception ones. Here's how you can implement an object that reports CPU Exceptions from a device:</p>
<pre>
<code>import MetricKit</code>
<code></code>
<code>final class CPUExceptionsReporter: NSObject, MXMetricManagerSubscriber {</code>
<code>    override init() {</code>
<code>        super.init()</code>
<code>        MXMetricManager.shared.add(self)</code>
<code>    }</code>
<code></code>
<code>    func didReceive(_ payloads: [MXMetricPayload]) {}</code>
<code>    func didReceive(_ payloads: [MXDiagnosticPayload]) {</code>
<code>        for payload in payloads {</code>
<code>            payload.cpuExceptionDiagnostics?.forEach(handleCPUException)</code>
<code>        }</code>
<code>    }</code>
<code></code>
<code>    func handleCPUException(_ diagnostic: MXCPUExceptionDiagnostic) {</code>
<code>        // Write a report to your crash reporter of choice</code>
<code>    }</code>
<code></code>
<code>    deinit {</code>
<code>        MXMetricManager.shared.remove(self)</code>
<code>    }</code>
<code>}</code>
</pre>
<div class="sponsor-article-ad-auto hidden"></div>
<p>You should be aware that <code>MetricKit</code> only reports this data once a day, so the data represents a warning/termination that happened <b>in the past</b>, very much likely in a different session entirely.</p>
</div>
]]></description>
</item>
<item>
    <title>How AsyncSequence works internally in Swift</title>
    <link>https://swiftrocks.com/how-asyncsequence-works-internally-in-swift</link>
    <guid>https://swiftrocks.com/how-asyncsequence-works-internally-in-swift</guid>
    <pubDate>Mon, 20 Sep 2021 09:00:00 GMT-3</pubDate>
<description><![CDATA[
<!--WRITEIT_POST_NAME=How AsyncSequence works internally in Swift-->
<!--WRITEIT_POST_HTML_NAME=how-asyncsequence-works-internally-in-swift-->

<!--Add here the additional properties that you want each page to possess.-->
<!--These properties can be used to change content in the template page or in the page itself as shown here.-->
<!--Properties must start with 'WRITEIT_POST'.-->
<!--Writeit provides and injects WRITEIT_POST_NAME and WRITEIT_POST_HTML_NAME by default.-->

<!--WRITEIT_POST_SHORT_DESCRIPTION=As part of my series of articles about Swift's new Structured Concurrency features, let's take a look at how AsyncSequence works behind the curtains!-->

<!--DateFormat example: 2021-04-12T14:00:00+02:00-->
<!--WRITEIT_POST_SITEMAP_DATE_LAST_MOD=2021-09-20T14:00:00+02:00-->
<!--WRITEIT_POST_SITEMAP_DATE=2021-09-20T14:00:00+02:00-->

<title>How AsyncSequence works internally in Swift</title>
<div class="blog-post">
  <div class="post-title-index">
    <h1>How AsyncSequence works internally in Swift</h1>
  </div>  
  <div class="post-info">
    <div class="category category-compiler">Compiler</div>
    <div class="category category-swift">Swift</div>
    <div class="post-info-text">Published on 20 Sep 2021</div>
  </div>
<p>As part of my series of articles about Swift's new <i>Structured Concurrency</i> features, let's take a look at how <code>AsyncSequence</code> works behind the curtains!</p>
<div class="sponsor-article-ad-auto hidden"></div>
<h2>Sequences vs AsyncSequences</h2>
<p><a href="https://swiftrocks.com/swift-sequence-inside-the-compiler-how-for-loops-work">I wrote back in 2019 an article</a> detailing how regular <code>Sequence</code> types work in Swift, and like its older counterpart, the purpose of <code>AsyncSequence</code> is to allow async objects representing a collection of values to be used in for loops:</p>
<pre>
<code>let sequence = SomeDataProvider()</code>
<code></code>
<code>for await value in sequence {</code>
<code>    print(value)</code>
<code>}</code>
</pre>
<p>You should take a look at the article about <code>Sequence</code> before reading this one, but if you don't want to, one way we can summarize it is that for loops aren't a hardcoded feature of Swift, but a syntax sugar that is built on top of two Swift protocols: <code>Sequence</code> and <code>IteratorProtocol</code>. Implementing these protocols allows you to use the relevant type as the right-hand value in a for loop, but deep down everything will simply be a syntax sugar of calling the methods you've implemented from the protocols.</p>
<p>When I first saw <code>AsyncSequence</code> I was wondering how that one would work, and as it turns out, it's roughly the same thing as a regular <code>Sequence</code>. Here's how the Swift protocols for the feature look like:</p>
<pre>
<code>public protocol AsyncSequence {</code>
<code>  associatedtype AsyncIterator: AsyncIteratorProtocol where AsyncIterator.Element == Element</code>
<code>  associatedtype Element</code>
<code>  __consuming func makeAsyncIterator() -> AsyncIterator</code>
<code>}</code>
<code></code>
<code>public protocol AsyncIteratorProtocol {</code>
<code>  associatedtype Element</code>
<code>  mutating func next() async throws -> Element?</code>
<code>}</code>
</pre>
<p>Just like <code>Sequence</code>, an asynchronous sequence must define the object type used by it, as well as an "iteration object" (often the sequence itself) which provides these objects in the first place. Deep down, <code>for await</code> loops are converted by the compiler to an iteration on top of the <code>AsyncIteratorProtocol</code>.</p>
<pre>
<code>while let line = try await it.next() {</code>
<code>  // Do something with each line</code>
<code>}</code>
</pre>
<p>To be specific, this conversion happens when emitting the SIL for the loop. While for loops exist within the compiler as a <code>ForEachStmt</code> type, they stop existing when compiler is going to write the optimized code that is later going to be transformed into assembly code. In this case <code>Sequence</code> and <code>AsyncSequence</code> will behave exactly the same, with the only difference being that asynchronous for loops will result in the <code>ForEachStmt</code> having a special flag that is later used to craft the asynchronous version of the optimized code.</p>
<p>One thing that is different here is that <code>AsyncIteratorProtocol</code> can throw, which is something that regular sequences can't do. As a fun side-effect this means that you can add the <code>try</code> keyword to regular for-loops, but they will do nothing because the regular <code>Sequence</code> can't throw.</p>
<pre>
<code>for try number in 0..<5 {} // Doesn't do anything special but is also not a warning.</code>
</pre>
<h2>What's __consuming?</h2>
<p>One thing you might have noticed is that <code>makeAsyncIterator()</code> has a special modifier called <code>__consuming</code>, which we haven't mentioned here in previous articles. The regular <code>Sequence</code> also has it, but I didn't notice it when I wrote its article!</p>
<p>I was first made aware of it when <a href="https://twitter.com/txaiwieser/status/1418564669581692932">Txai Wieser asked me about it a while ago</a>, and it seems that this is an internal compiler feature that was ninja'd into Swift back in 2018. To be specific, the feature itself doesn't exist yet, but the modifiers were added to make sure the types that would make use of it would be ready by the time the feature is fully implemented.</p>
<div class="sponsor-article-ad-auto hidden"></div>
<p>The feature in question here is something called <b>move-only types</b>, which describes objects that can be cheaply moved around to different memory addresses instead of being copied, which can be both a performance and a memory optimization technique when passing objects around different layers of abstraction. This is especially relevant for <code>Sequences</code> as the <code>IteratorProtocol</code> implementation in practice requires duplicating some or all of the information in the original <code>Sequence</code>, which today is not possible if the <code>Sequence</code> cannot be copied without consuming the original sequence. If the <code>Sequence</code> was able to provide move-only objects, the cost of iterating would be reduced. Unfortunately it seems that this feature was never actually implemented, with old forum posts being the only piece of information we have on it.</p>
</div>
]]></description>
</item>
<item>
    <title>Reverse engineering a 5 year old Xcode issue</title>
    <link>https://swiftrocks.com/reverse-engineering-xcode-issue-crash-symbol</link>
    <guid>https://swiftrocks.com/reverse-engineering-xcode-issue-crash-symbol</guid>
    <pubDate>Tue, 31 Aug 2021 09:00:00 GMT-3</pubDate>
<description><![CDATA[
<!--WRITEIT_POST_NAME=Reverse engineering a 5 year old Xcode issue-->
<!--WRITEIT_POST_HTML_NAME=reverse-engineering-xcode-issue-crash-symbol-->

<!--Add here the additional properties that you want each page to possess.-->
<!--These properties can be used to change content in the template page or in the page itself as shown here.-->
<!--Properties must start with 'WRITEIT_POST'.-->
<!--Writeit provides and injects WRITEIT_POST_NAME and WRITEIT_POST_HTML_NAME by default.-->

<!--WRITEIT_POST_SHORT_DESCRIPTION=Have you ever had issues with Xcode not symbolicating crashes? Me too, and I found the fix by reverse engineering the IDE.-->

<!--DateFormat example: 2021-08-31T14:00:00+02:00-->
<!--WRITEIT_POST_SITEMAP_DATE_LAST_MOD=2021-08-31T14:00:00+02:00-->
<!--WRITEIT_POST_SITEMAP_DATE=2021-08-31T14:00:00+02:00-->

<title>Reverse engineering a 5 year old Xcode issue</title>
<div class="blog-post">
  <div class="post-title-index">
    <h1>Reverse engineering a 5 year old Xcode issue</h1>
  </div>  
  <div class="post-info">
    <div class="category category-reverse">Reverse Engineering</div>
    <div class="post-info-text">Published on 31 Aug 2021</div>
  </div>
<p>Xcode has a feature called <b>Organizer</b> that shows you important information about builds you sent to the App Store, with the most relevant ones being crashes and energy reports (for CPU/memory usage). In my experience, this feature will work perfectly fine if you pushed the build from your <i>own</i> machine, but if that's not true for any reason (the most common being because you're using a CI pipeline to do) then you might have a frustrating experience. To be specific, if you didn't push the build from your machine, then all reports provided by Xcode will be unsymbolicated:</p>
<div class="post-image">
  <img src="https://i.imgur.com/9UaPOZb.png" alt="Alt">                                    
</div>
<p>This is perfectly expected given that the symbol information comes from the <b>dSYM</b> package that is generated when you archive your app, so it's also normal for CI pipelines to store the dSYMs of a build somewhere that can be retrieved later. The problem is that <b>even</b> if you have a copy of the original build archive, chances are that Xcode will not know what to do. If you right-click a stack trace and press <i>Symbolicate</i>, you'll either get a useless error or nothing will happen.</p>
<div class="sponsor-article-ad-auto hidden"></div>
<p>This bug is not deterministic (some people have it, some people don't), and it's not clear at first glance what factors make it work or not. What I do know is that a <b>lot</b> of people have experienced this -- a Google search will reveal many StackOverflow and Apple Developer threads complaining about this issue, <a href="https://developer.apple.com/forums/thread/51873">with the earliest being 5 years old.</a> The threads point to many CLI alternatives that can be used to symbolicate crashes manually, but no one seems to be able to pinpoint exactly <i>why</i> Xcode doesn't work in the first place. As you might also expect, Apple has never said or done anything about this.</p>
<p><i>"But wait a second Bruno, why do you care about this bug? Isn't everyone using Firebase for crash reporting?"</i></p>
<p>That is true, but the Organizer contains more than just plain crashes. I was particularly interested in reading Xcode's <b>energy reports</b> to learn more about cases where iOS decides to shut down apps due to high CPU usage, which are not reported to Firebase.</p>
<p>Additionally, even though there are many workarounds available to symbolicate crashes manually, <b>none of them work for the energy reports I wanted to look at.</b> The most common workaround shared by developers is to extract the <code>symbolicatecrash</code> file that exists inside Xcode and call it manually from the CLI, but this only works for regular crashes. To be specific, <code>symbolicatecrash</code> is in fact what Xcode uses to symbolicate energy reports, but because Xcode stores them in a different format, you're not able to pass them to <code>symbolicatecrash</code> without first somehow converting them, something of which I had no interest in doing as I had no idea what format this tool is looking for in the first place. To make it worse, because issues with CPU and memory usage tend to be rare in the iOS world, I couldn't find <i>any</i> workaround for this. I made an angry Twitter post, and sometime after that realized that if I want to see these logs then I should reverse engineer Xcode and fix this issue myself.</p>
<h2>Finding the source of the error</h2>
<p>The only piece of relevant information I had about this issue is the error that Xcode returns when attempting to symbolicate an energy report. Although the error is useless, it's customized enough to allow me to search for it inside the binary:</p>
<div class="post-image">
  <img src="https://i.imgur.com/NJJw17V.png" alt="Alt">                                    
</div>
<p>I then <code>grep</code>'d the entire Xcode archive for this string. It took a very long time for it to finish given that my Xcode is about 30 gigabytes in size, but it did find the reference inside the <code>IDEAnalyticsKit</code> framework:</p>
<pre>
Binary file .//PlugIns/IDEAnalyticsKit.framework/Versions/A/IDEAnalyticsKit matches
Binary file .//PlugIns/IDEAnalyticsKit.framework/Versions/Current/IDEAnalyticsKit matches
Binary file .//PlugIns/IDEAnalyticsKit.framework/IDEAnalyticsKit matches
</pre>
<p>Xcode is not one giant binary, but a collection of many smaller specialized frameworks. In fact, the main Xcode binary seems to do almost nothing but launch the other frameworks.</p>
<p>After opening the <code>IDEAnalyticsKit</code> binary in Hopper, I was easily able to locate the Obj-C method that hardcoded the error string:</p>
<div class="post-image">
  <img src="https://i.imgur.com/iBbWFVR.png" alt="Alt">                                    
</div>
<p>Thanks to Hopper's amazing feature of converting assembly to pseudocode, navigating the decompiled binary is a breeze. By selecting the first instruction of a method, I could navigate the stack trace all the way to the method that is called when the <i>Symbolicate</i> button is touched:</p>
<div class="post-image">
  <img src="https://i.imgur.com/dKfpaEs.png" alt="Alt">                                    
</div>
<p>In short, what this method does is simply assert that we're in the main thread and then start the symbolization process by sending a completion handler that throws the error we're ending up in. By navigating the assembly code with the help of Hopper's pseudocode feature, we should be able to find out exactly what's causing it to fail.</p>
<p>Following the symbolization trace eventually led me to <i>another</i> framework, <code>DVTAnalytics</code>, where a more specialized method lives:</p>
<div class="post-image">
  <img src="https://i.imgur.com/NqY13Jc.png" alt="Alt">                                    
</div>
<p>Despite being a long method, there's nothing special going on here -- Xcode is simply grabbing information about the crash and initializing more specialized objects as it travels from framework to framework. After setting up another completion handler, the journey continues inside <code>symbolicateWithCallback</code>.</p>
<p>When I tried navigating to that method, Hopper greeted me with this awesome pop-up:</p>
<div class="post-image">
  <img src="https://i.imgur.com/YvwFOgN.png" alt="Alt">                                    
</div>
<p>It turns out that Hopper is smart enough to notice that <code>symbolicateWithCallback</code> is a Obj-C protocol method that is implemented by three different objects in this framework, which represent the three different types of crashes available in the Organizer (crash, energy report and disk report)! After picking the energy variant, I eventually fell here:</p>
<div class="post-image">
  <img src="https://i.imgur.com/w4z5zFq.png" alt="Alt">                                    
</div>
<p>This method is saying that we're initializing a <code>DVTLocalLogSymbolicator</code> object and asking it to continue the process, but I couldn't find it anywhere in this framework. After another <code>grep</code>, I found out that this and all the core symbolization logic was placed in a separate <code>DVTFoundation</code> framework. After locating the class and its <code>symbolicateLogData</code> method, I was finally able to locate where the symbolization is done:</p>
<div class="post-image">
  <img src="https://i.imgur.com/Fuw2J77.png" alt="Alt">                                    
</div>
<p>This is essentially saying that Xcode is fetching and calling the <code>symbolicatecrash</code> utility, which is not a surprise given that this is exactly the workaround that we mentioned in the beginning. However, I could immediately tell what the problem was -- when this workaround is suggested, the correct way of invoking this utility is by sending the dSYM that contains the symbols you're trying to translate:</p>
<pre>
<code>symbolicatecrash --dsym ./symbols.dSYM --output ./symbolicated.txt</code>
</pre>
<p>However, Xcode doesn't do that -- it just sets the output and hopes for the best. What happens essentially is that this tool is capable of searching for dSYMs on its own, but for some reason sometimes it just fails to do so. I could easily reproduce the issue by trying to symbolicate a regular crash without passing the dsym argument:</p>
<pre>
<code>Did not find dsym for (uuid)</code>
</pre>
<p>My first assumption was that this tool was probably looking for specific names or in specific folders, and we could confirm that by opening <code>symbolicatecrash</code> in Hopper and reverse engineering that logic. But quickly I realized that there was something fishy going on, because what I found instead was... nothing?</p>
<div class="post-image">
  <img src="https://i.imgur.com/RAdUFL8.png" alt="Alt">                                    
</div>
<p>After being stumped for a while, my colleague √Öke quickly noticed that although macOS says that this file is a binary, it's actually just a really big perl script!</p>
<pre>
<code>#!/usr/bin/perl -w</code>
<code>#</code>
<code># This script parses a crashdump file and attempts to resolve addresses into function names.</code>
<code>#</code>
<code># It finds symbol-rich binaries by:</code>
<code>#   a) searching in Spotlight to find .dSYM files by UUID, then finding the executable from there.</code>
<code>#       That finds the symbols for binaries that a developer has built with "DWARF with dSYM File".</code>
<code>#   b) searching in various SDK directories.</code>
<code>#</code>
<code># Copyright (c) 2008-2015 Apple Inc. All Rights Reserved.</code>
<code>#</code>
<code>#</code>
</pre>
<p>This made everything else easier, because we could now freely modify this script and test our changes without having to generate new binaries. The first thing we did was locate the part of the code that parsed the arguments, which was right in the beginning:</p>
<pre>
<code># read and parse command line</code>
<code>my $opt_help = 0;</code>
<code>my $opt_verbose = 0;</code>
<code>my $opt_output = "-";</code>
<code>my @opt_dsyms = ();</code>
<code>my $opt_spotlight = 1;</code>
</pre>
<p>If we know that <code>symbolicatecrash</code> works by sending the dSYM manually, could we simply override the <code>opt_dsyms</code> param and fix the issue? The answer is <b>yes!</b></p>
<div class="post-image">
  <img src="https://i.imgur.com/uSdkNsU.png" alt="Alt">                                    
</div>
<p>This was sufficient for the data gathering we wanted to do, but I was still interested in knowing why this script couldn't find the dSYMs on its own. After a deeper inspection, we can see that the script attempts to locate the dSYM in three ways:</p>
<ul>
<li>The --dsym flag</li>
<li>The /Volumes/Build/UUIDToSymbolMap folder</li>
<li>The <code>Symbols</code> folder inside of every iOS/macOS SDK you have installed</li>
</ul>
<p>If neither of those returned a valid result, <b>it attempts to search the symbols through Spotlight, your macOS's search engine.</b> More specifically, it runs the following command:</p>
<pre>
<code>mdfind \"com_apple_xcode_dsym_uuids == $canonical_uuid\"</code>
</pre>
<p>This means that the failure to symbolicate crashes isn't a problem with Xcode, but that for some reason Spotlight failed to add the dSYM to its search index. After some quick searches about Spotlight issues, I found two ways to force Spotlight to re-index a folder:</p>
<ul>
<li>The <code>mdimport</code> CLI tool, pointing directly to where the dSYM is stored.</li>
<li>This <a href="https://support.apple.com/en-us/HT201716">support article</a> from Apple</li>
</ul>
<div class="sponsor-article-ad-auto hidden"></div>
<p>I had mixed success with <code>mdimport</code> (in fact, I remember seeing this as a buried comment in one of the StackOverflow posts, so someone <i>did</i> also figure this out in the past), but the trick from the article solved it for me. I think this feature would've been better developed if Xcode allowed you to provide the dSYM manually instead of completely relying on Spotlight, but investigating this issue was a very fun couple of hours for me.</p>
</div>
]]></description>
</item>
<item>
    <title>Swift's Documentation Markup</title>
    <link>https://swiftrocks.com/swifts-documentation-markup</link>
    <guid>https://swiftrocks.com/swifts-documentation-markup</guid>
    <pubDate>Tue, 17 Aug 2021 09:00:00 GMT-3</pubDate>
<description><![CDATA[
<!--WRITEIT_POST_NAME=Swift's Documentation Markup-->
<!--WRITEIT_POST_HTML_NAME=swifts-documentation-markup-->

<!--Add here the additional properties that you want each page to possess.-->
<!--These properties can be used to change content in the template page or in the page itself as shown here.-->
<!--Properties must start with 'WRITEIT_POST'.-->
<!--Writeit provides and injects WRITEIT_POST_NAME and WRITEIT_POST_HTML_NAME by default.-->

<!--WRITEIT_POST_SHORT_DESCRIPTION=Swift always had its own documentation format, but the introduction of DocC in Xcode 13 added some cool new features. Let's take a look at what we can do now!-->

<!--DateFormat example: 2021-04-12T14:00:00+02:00-->
<!--WRITEIT_POST_SITEMAP_DATE_LAST_MOD=2021-08-17T14:00:00+02:00-->
<!--WRITEIT_POST_SITEMAP_DATE=2021-08-17T14:00:00+02:00-->

<title>Swift's Documentation Markup</title>
<div class="blog-post">
  <div class="post-title-index">
    <h1>Swift's Documentation Markup</h1>
  </div>  
  <div class="post-info">
    <div class="category category-swift">Swift</div>
    <div class="post-info-text">Published on 17 Aug 2021</div>
  </div>
<p>Swift always had its own documentation format, but the introduction of DocC in Xcode 13 added some cool new features. Let's take a look at what we can do now!</p>
<div class="sponsor-article-ad-auto hidden"></div>
<h2>Basics of Swift Documentation</h2>
<p>One thing I find interesting about Swift is that the documentation markup is not a feature of IDEs, but that of the compiler itself. By snipping through the source code, we can see everything that Swift supports:</p>
<pre>
<code>MARKUP_SIMPLE_FIELD(AttentionField, attention, Attention)</code>
<code>MARKUP_SIMPLE_FIELD(AuthorField, author, Author)</code>
<code>MARKUP_SIMPLE_FIELD(AuthorsField, authors, Authors)</code>
<code>MARKUP_SIMPLE_FIELD(BugField, bug, Bug)</code>
<code>MARKUP_SIMPLE_FIELD(Complexity, complexity, Complexity)</code>
<code>MARKUP_SIMPLE_FIELD(CopyrightField, copyright, Copyright)</code>
<code>MARKUP_SIMPLE_FIELD(DateField, date, Date)</code>
<code>MARKUP_SIMPLE_FIELD(ExperimentField, experiment, Experiment)</code>
<code>MARKUP_SIMPLE_FIELD(ImportantField, important, Important)</code>
<code>MARKUP_SIMPLE_FIELD(InvariantField, invariant, Invariant)</code>
<code>MARKUP_SIMPLE_FIELD(LocalizationKeyField, localizationkey, LocalizationKey)</code>
<code>MARKUP_SIMPLE_FIELD(MutatingvariantField, mutatingvariant, Mutatingvariant)</code>
<code>MARKUP_SIMPLE_FIELD(NonmutatingvariantField, nonmutatingvariant, Nonmutatingvariant)</code>
<code>MARKUP_SIMPLE_FIELD(NoteField, note, Note)</code>
<code>MARKUP_SIMPLE_FIELD(PostconditionField, postcondition, Postcondition)</code>
<code>MARKUP_SIMPLE_FIELD(PreconditionField, precondition, Precondition)</code>
<code>MARKUP_SIMPLE_FIELD(RemarkField, remark, Remark)</code>
<code>MARKUP_SIMPLE_FIELD(RemarksField, remarks, Remarks)</code>
<code>MARKUP_SIMPLE_FIELD(ReturnsField, returns, Returns)</code>
<code>MARKUP_SIMPLE_FIELD(ThrowsField, throws, Throws)</code>
<code>MARKUP_SIMPLE_FIELD(RequiresField, requires, Requires)</code>
<code>MARKUP_SIMPLE_FIELD(SeeField, seealso, See)</code>
<code>MARKUP_SIMPLE_FIELD(SinceField, since, Since)</code>
<code>MARKUP_SIMPLE_FIELD(TagField, tag, Tag)</code>
<code>MARKUP_SIMPLE_FIELD(TODOField, todo, TODO)</code>
<code>MARKUP_SIMPLE_FIELD(VersionField, version, Version)</code>
<code>MARKUP_SIMPLE_FIELD(WarningField, warning, Warning)</code>
<code>MARKUP_SIMPLE_FIELD(KeywordField, keyword, Keyword)</code>
<code>MARKUP_SIMPLE_FIELD(RecommendedField, recommended, Recommended)</code>
<code>MARKUP_SIMPLE_FIELD(RecommendedoverField, recommendedover, Recommendedover)</code>
</pre>
<p>(Not mentioned here is the <code>Parameters</code> field, which is treated slightly differently).</p>
<p>You can attach any of these fields to a method by adding a dash followed by the identifier of the markup. What happens when you do that will depend on Xcode, but most of these fields are supported by the Quick Look feature:</p>
<pre>
<code>/// Combines this with another condition publisher.</code>
<code>///</code>
<code>/// I'm just adding random information for an article. Carry on!</code>
<code>///</code>
<code>/// - Attention: This code is really cool.</code>
<code>/// Here's why I think you should use this:</code>
<code>///  * item 1</code>
<code>///  * item 2</code>
<code>///    * item 2.1</code>
<code>/// * item 3</code>
<code>///</code>
<code>/// - Complexity: O(1)</code>
<code>/// - Parameters:</code>
<code>///   - publisher: The other publisher.</code>
<code>/// - Returns: A combined publisher that has the condition of both publishers.</code>
<code>func ...</code>
</pre>
<div class="post-image">
  <img src="https://i.imgur.com/AMjU98I.png" alt="Alt">                                    
</div>
<h2>Xcode specific features</h2>
<p>Although most of the work is inside Swift, Xcode has some features of its own. You may know by now that Xcode can render Markdown, and perhaps the most interesting use of it in my opinion is to add links to the documentation:</p>
<pre>
<code>/// Combines this with another condition publisher.</code>
<code>///</code>
<code>/// - Bug:[IOS-10395](https://myjira.com/ios/10395)</code>
</pre>
<div class="post-image">
  <img src="https://i.imgur.com/Fm3UssT.png" alt="Alt">                                    
</div>
<p>But Xcode also has some styling utilities. I especially like that you can create horizontal rules:</p>
<pre>
<code>An example of using a *horizontal rule*</code>
<code></code>
<code>This text is above the horizontal rule</code>
<code></code>
<code>*  *  *  *  *</code>
<code> </code>
<code>And this is below</code>
</pre>
<div class="post-image">
  <img src="https://i.imgur.com/AAnJMbf.png" alt="Alt">                                    
</div>
<p>But unfortunately, Xcode's coolest documentation features are restricted to playgrounds. In a playground, the link markup can be used even to display videos:</p>
<pre>
<code>//: Watch the WWDC session introducing the San Francisco Font</code>
<code>//: ![San Francisco font introduction](new-fonts.mp4)</code>
</pre>
<div class="post-image">
  <img src="https://i.imgur.com/oFW6TS8.png" alt="Alt">                                    
</div>
<p>Xcode also claims to support a heading markup to display larger text, but it doesn't seem to work in the latest Xcode versions.</p>
<pre>
<code>/**</code>
<code>  An example of using a character underline for a *heading*</code>
<code> </code>
<code>  This is a Heading 1</code>
<code>  ===================</code>
<code> */</code>
</pre>
<div class="post-image">
  <img src="https://i.imgur.com/hLAFybL.png" alt="Alt">                                    
</div>
<h2>Changes introduced with Xcode 13 / DocC</h2>
<p>With Apple's new documentation page generation tool released in Xcode 13, you now have the ability to <b>reference code</b>. You could already write chunks of code with <code>`</code> or <code>```swift</code> for blocks, but it didn't actually link to the references:</p>
<pre>
<code>/// Merges two `Publishers` of `Condition&lt;T>`.</code>
<code>/// ```swift</code>
<code>/// let publisher = CurrentValueSubject&lt;Condition&lt;Int>, Never>(.satisfied(1))</code>
<code>/// let publisherB = CurrentValueSubject&lt;Condition&lt;Int>, Never>(.satisfied(2))</code>
<code>/// let combined = publisher.combineCondition(publisherB)</code>
<code>/// ```</code>
</pre>
<div class="post-image">
  <img src="https://i.imgur.com/OVgrJEp.png" alt="Alt">                                    
</div>
<p>In Xcode 13, a new double backtick markup was introduced for this purpose to allow DocC to reference other pages:</p>
<div class="post-image">
  <img src="https://i.imgur.com/X11pshP.png" alt="Alt">                                    
</div>
<div class="post-image">
  <img src="https://i.imgur.com/RMZReD6.png" alt="Alt">                                    
</div>
<p>References of the same class can be reference by just typing the name, while references from other types can be referenced with the <code>``Type/property``</code> format. There's even code completion!</p>
<div class="sponsor-article-ad-auto hidden"></div>
<p>Clicking the property in the documentation itself will move you to the line where the code was defined, while clicking it in Quick Look will re-direct you to the DocC page of the property. You can even control-click the property to see that property's <i>own</i> quick look documentation, although this seems to be broken in the current version. One unfortunate downside of this new feature however is that at least in Xcode 13's first betas it seems to be totally tied to DocC, meaning that the links don't actually work unless there's a DocC page for it, which means that this only works for public types in frameworks. Hopefully in the future versions they can make it work based on Xcode's indexer so that we can use this feature without DocC, which would allow it to work in an app's main target and internal documentation.</p>
</div>
]]></description>
</item>
<item>
    <title>StaticString, and how it works internally in Swift</title>
    <link>https://swiftrocks.com/staticstring-in-swift</link>
    <guid>https://swiftrocks.com/staticstring-in-swift</guid>
    <pubDate>Tue, 3 Aug 2021 09:00:00 GMT-3</pubDate>
<description><![CDATA[
<!--WRITEIT_POST_NAME=StaticString, and how it works internally in Swift-->
<!--WRITEIT_POST_HTML_NAME=staticstring-in-swift-->

<!--Add here the additional properties that you want each page to possess.-->
<!--These properties can be used to change content in the template page or in the page itself as shown here.-->
<!--Properties must start with 'WRITEIT_POST'.-->
<!--Writeit provides and injects WRITEIT_POST_NAME and WRITEIT_POST_HTML_NAME by default.-->

<!--WRITEIT_POST_SHORT_DESCRIPTION=StaticString is an interesting type in Swift. Let's see how it works!-->

<!--DateFormat example: 2021-04-12T14:00:00+02:00-->
<!--WRITEIT_POST_SITEMAP_DATE_LAST_MOD=2021-08-03T14:00:00+02:00-->
<!--WRITEIT_POST_SITEMAP_DATE=2021-08-03T14:00:00+02:00-->

<title>StaticString, and how it works internally in Swift</title>
<div class="blog-post">
  <div class="post-title-index">
    <h1>StaticString, and how it works internally in Swift</h1>
  </div>  
  <div class="post-info">
    <div class="category category-compiler">Compiler</div>
    <div class="category category-swift">Swift</div>
    <div class="post-info-text">Published on 03 Aug 2021</div>
  </div>
<p><code>StaticString</code> is an interesting type in Swift. It's essentially nothing more than a <code>String</code> that can't be modified for the purposes of referencing static content inside your binary.</p>
<div class="sponsor-article-ad-auto hidden"></div>
<p>You can encounter <code>StaticString</code> in Swift when referencing source metadata like <code>#file</code> and <code>#function</code>, but you can also define one yourself by explicitly declaring it in a string literal:</p>
<pre>
<code>let path: StaticString = #file // StaticString</code>
<code>let myStaticString: StaticString = "SwiftRocks!"</code>
</pre>
<p>In short, this is an optimization trick. A <code>StaticString</code> is meant to represent text that is known at compile-time (and is not going to be modified), allowing you to save memory by not building the heap storage that a regular <code>String</code> would require.</p>
<p>You might already have a good idea of what this is going to look like. While a normal <code>String</code> will read the memory address of the original string in the binary and build the entire data structure around it, a <code>StaticString</code> just... stores that address:</p>
<pre>
<code>public struct StaticString: Sendable {</code>
<code></code>
<code>  /// Either a pointer to the start of UTF-8 data, represented as an integer,</code>
<code>  /// or an integer representation of a single Unicode scalar.</code>
<code>  @usableFromInline</code>
<code>  internal var _startPtrOrData: Builtin.Word</code>
<code></code>
<code>  ...</code>
<code>}</code>
</pre>
<p>This makes perfect sense -- if you're not going to modify that string, we don't really need to do anything with that address. Every string literal you write is stored in the binary in the end (which you can even reverse-engineer to extract other people's API keys and such, yuck), and a <code>StaticString</code> is simply a wrapper of a type that reads that address.</p>
<p>But how does Swift differentiate between regular strings versus static ones?</p>
<h2>How <code>StaticString</code> is built in the compiler</h2>
<p>In Swift, literals are syntax-sugars for types that implement the <code>ExpressibleBy</code> series of protocols, so this wouldn't be different for <code>StaticString</code>. <a href="https://swiftrocks.com/swift-expressibleby-protocols-how-they-work-internally-in-the-compiler">We already covered the topic of ExpressibleBy here on SwiftRocks</a>, so to avoid duplicating information, make sure to familiarize yourself with that article before continuing this one.</p>
<p>As mentioned in that article, types that empower string literals are in reality types that inherit from the <code>ExpressibleByStringLiteral</code> protocol, exposing an initializer that receives a <code>String</code> formed from that literal. <code>StaticString</code> also works by inheriting from that protocol, but I was confusing about something: If <code>ExpressibleByStringLiteral</code> gives you a normal <code>String</code>, doesn't this ruin the purpose of a static string?</p>
<p>It turns out that I was missing an important point about string literals. <code>ExpressibleByStringLiteral</code> doesn't simply give you a <code>String</code>, you can actually customize it!</p>
<pre>
<code>public protocol ExpressibleByStringLiteral {</code>
<code></code>
<code>  /// A type that represents a string literal.</code>
<code>  associatedtype StringLiteralType: _ExpressibleByBuiltinStringLiteral</code>
<code></code>
<code>  init(stringLiteral value: StringLiteralType)</code>
<code>}</code>
</pre>
<p>When inheriting from <code>ExpressibleByStringLiteral</code>, you can receive anything that inherits <code>_ExpressibleByBuiltinStringLiteral</code>, which is a protocol that defines an object that can build a string from its original memory address:</p>
<pre>
<code>public protocol _ExpressibleByBuiltinStringLiteral {</code>
<code></code>
<code>  init(</code>
<code>      _builtinStringLiteral start: Builtin.RawPointer,</code>
<code>      utf8CodeUnitCount: Builtin.Word,</code>
<code>      isASCII: Builtin.Int1</code>
<code> )</code>
<code>}</code>
</pre>
<p>As dictated by the underscore, this is an internal protocol that you shouldn't be messing with. The practice is quite interesting because you can actually inherit it, but the code won't compile because we cannot access <code>Builtin</code> types from Swift. But if we cannot create conformances to it, what <i>can</i> we use? The answer: <code>String</code> and <code>StaticString</code>.</p>
<p>These two types conform not only to <code>ExpressibleByStringLiteral</code>, but also to the protocol that defines how these strings are created in the first place. And while a <code>String</code> will implement it in order to create a proper mutable string object, a <code>StaticString</code> just stores the address.</p>
<pre>
<code>extension StaticString: _ExpressibleByBuiltinStringLiteral {</code>
<code>  public init(</code>
<code>    _builtinStringLiteral start: Builtin.RawPointer,</code>
<code>    utf8CodeUnitCount: Builtin.Word,</code>
<code>    isASCII: Builtin.Int1</code>
<code>  ) {</code>
<code>    self = StaticString(</code>
<code>      _start: start,</code>
<code>      utf8CodeUnitCount: utf8CodeUnitCount,</code>
<code>      isASCII: isASCII)</code>
<code>  }</code>
<code>}</code>
</pre>
<p>When building a string literal, the compiler reads the <code>StringLiteralType</code> type used by the <code>ExpressibleByStringLiteral</code> conformance to make sure the right string type is created and provided.</p>
<pre>
<code>literalType = ctx.Id_StringLiteralType;</code>
<code></code>
<code>literalFuncName = DeclName(ctx, DeclBaseName::createConstructor(),</code>
<code>                           {ctx.Id_stringLiteral});</code>
<code></code>
<code>builtinProtocol = TypeChecker::getProtocol(</code>
<code>    cs.getASTContext(), expr->getLoc(),</code>
<code>    KnownProtocolKind::ExpressibleByBuiltinStringLiteral);</code>
<code>builtinLiteralFuncName =</code>
<code>    DeclName(ctx, DeclBaseName::createConstructor(),</code>
<code>             {ctx.Id_builtinStringLiteral,</code>
<code>              ctx.getIdentifier("utf8CodeUnitCount"),</code>
<code>              ctx.getIdentifier("isASCII")});</code>
</pre>
<h2>Should I be using <code>StaticString</code>?</h2>
<div class="sponsor-article-ad-auto hidden"></div>
<p>As is the norm with micro-optimizations, unless you know what you're doing, probably not. You should also note that <code>StaticStrings</code> have a couple of limitations when it comes to Unicode, so you should be careful when trying to read their internal content.</p>
</div>
]]></description>
</item>
<item>
    <title>Extending / Creating Combine Publishers the Right Way</title>
    <link>https://swiftrocks.com/extending-creating-publishers-the-right-way</link>
    <guid>https://swiftrocks.com/extending-creating-publishers-the-right-way</guid>
    <pubDate>Tue, 27 Jul 2021 09:00:00 GMT-3</pubDate>
<description><![CDATA[
<!--WRITEIT_POST_NAME=Extending / Creating Combine Publishers the Right Way-->
<!--WRITEIT_POST_HTML_NAME=extending-creating-publishers-the-right-way-->

<!--Add here the additional properties that you want each page to possess.-->
<!--These properties can be used to change content in the template page or in the page itself as shown here.-->
<!--Properties must start with 'WRITEIT_POST'.-->
<!--Writeit provides and injects WRITEIT_POST_NAME and WRITEIT_POST_HTML_NAME by default.-->

<!--WRITEIT_POST_SHORT_DESCRIPTION=In this article, I'll show you how to properly extend existing publishers and how to wrap them when creating your own custom publishers.-->

<!--DateFormat example: 2021-07-27T14:00:00+02:00-->
<!--WRITEIT_POST_SITEMAP_DATE_LAST_MOD=2021-07-27T14:00:00+02:00-->
<!--WRITEIT_POST_SITEMAP_DATE=2021-07-27T14:00:00+02:00-->

<title>Extending / Creating Combine Publishers the Right Way</title>
<div class="blog-post"> 
 <div class="post-title-index">  
  <h1>Extending / Creating Combine Publishers the Right Way</h1>
 </div> 
 <div class="post-info"> 
  <div class="category category-swift">
   Swift
  </div> 
  <div class="post-info-text">
   Published on 26 Jul 2021 
  </div> 
 </div>   
<p>I've been playing around with <b>Combine</b> for a while now and had some trouble navigating all the new protocols and types, especially when it came to extensions. In this article, I'll show you how to properly extend existing publishers and how to wrap them when creating your own custom publishers.</p>
<div class="sponsor-article-ad-auto hidden"></div>
<h2>The Easy Case: Extending Basic Output Publishers</h2>
<p>One of my favorite uses of Combine is how easily composable everything is. There's no need to create custom classes unless you really need to keep track of an external object:</p>
<pre>
<code>let publisher = CurrentValueSubject&lt;Int, Never>(0)</code>
<code></code>
<code>let evenSquaredPublisher = publisher.filter {</code>
<code>    $0 % 2 == 0</code>
<code>}.map {</code>
<code>    $0 * $0</code>
<code>}</code>
<code></code>
<code>let cancellable = evenSquaredPublisher.sink { print($0) }</code>
</pre>
<p>Since all articles require a non-sense example, our example is going to be a publisher that streams the squared of even numbers. As you can see, it's trivial to develop this functionality, but what if we wanted to do this more than once around our code?</p>
<p>Surprisingly, due to limitations on the constrained extensions API, it took me a while to figure out the right way to abstract this under a function. My first idea, and what I think some people out there are doing, is to extend <code>AnyPublisher</code> and constrain it to the <code>Int</code> output used by the example:</p>
<pre>
<code>extension AnyPublisher where Output == Int {</code>
<code>    func evenSquared() -> AnyPublisher&lt;Output, Failure> {</code>
<code>        return filter {</code>
<code>            $0 % 2 == 0</code>
<code>        }.map {</code>
<code>            $0 * $0</code>
<code>        }.eraseToAnyPublisher()</code>
<code>    }</code>
<code>}</code>
</pre>
<p>This however is not the right approach, because you'll now have to erase everyone who wants to use this method, and that's not why <code>AnyPublisher</code> exists:</p>
<pre>
<code>let evenSquaredPublisher = publisher.eraseToAnyPublisher().evenSquared()</code>
</pre>
<p>To extend publishers correctly in this case, we need to extend the main <code>Publisher</code> protocol:</p>
<pre>
<code>extension Publisher where Output == Int {</code>
<code>    func evenSquared() -> AnyPublisher&lt;Output, Failure> {</code>
<code>        return filter {</code>
<code>            $0 % 2 == 0</code>
<code>        }.map {</code>
<code>            $0 * $0</code>
<code>        }.eraseToAnyPublisher()</code>
<code>    }</code>
<code>}</code>
<code></code>
<code>let evenSquaredPublisher = publisher.evenSquared()</code>
</pre>
<p>This is better, but we're still not done. Luckily for us (or not, as you'll see below), every one of these Combine operators return an actual concrete <code>Publisher</code> implementation, so with some help of the compiler we can return the correct result of the operation instead of <code>AnyPublisher</code>:</p>
<pre>
<code>extension Publisher where Output == Int {</code>
<code>    func evenSquared() -> Publishers.Map&lt;Publishers.Filter&lt;Self>, Output> {</code>
<code>        return filter {</code>
<code>            $0 % 2 == 0</code>
<code>        }.map {</code>
<code>            $0 * $0</code>
<code>        }</code>
<code>    }</code>
<code>}</code>
</pre>
<p>The signature of methods might let a little large because of this, but as far as I know, this is the correct way of approaching this problem, and you can make it better in this case with an alias:</p>
<pre>
<code>typealias EvenSquaredPublisher&lt;P: Publisher, T> = Publishers.Map&lt;Publishers.Filter&lt;P>, T></code>
<code>extension Publisher where Output == Int {</code>
<code>    func evenSquared() -> EvenSquaredPublisher&lt;Self, Output> {</code>
<code>        return filter {</code>
<code>            $0 % 2 == 0</code>
<code>        }.map {</code>
<code>            $0 * $0</code>
<code>        }</code>
<code>    }</code>
<code>}</code>
</pre>
<p>So far this seems like nothing special, but don't worry, this is going to get weird pretty soon.</p>
<h2>The Hardcore Case: Extending Publishers With Generic Outputs</h2>
<p>There's one additional case I would like to show you, which is what prompted me to write this article. <b>What if the output itself contains generics?</b></p>
<pre>
<code>enum Condition&lt;T> {</code>
<code>    case satisfied(T)</code>
<code>    case unsatisfied</code>
<code>}</code>
<code></code>
<code>let publisher = CurrentValueSubject&lt;Condition&lt;Int>, Never>(.satisfied(1))</code>
<code>let publisherB = CurrentValueSubject&lt;Condition&lt;Int>, Never>(.satisfied(2))</code>
<code></code>
<code>let combinedConditions = publisher.combineLatest(publisherB).map { tuple in</code>
<code>    guard case .satisfied(let pA) = tuple.0, case .satisfied(let pB) = tuple.1 else {</code>
<code>        return .unsatisfied</code>
<code>    }</code>
<code>    return .satisfied((pA, pB))</code>
<code>}</code>
</pre>
<p>In this example, we're merging the contents of two conditions into a single condition that contains both publisher's values. But because the result here is <code>Condition&lt;T></code>, we can't use the constrained extension syntax anymore:</p>
<pre>
<code>extension Publisher where Output == Condition</code>
<code>// Reference to generic type 'Condition' requires arguments in &lt;...></code>
</pre>
<p>I personally find it really weird that this is not possible to do, and perhaps a point of improvement with Swift in the future. Still, there's a way you can achieve this. in <i>this</i> case, the correct approach is to instead constrain <b>the method itself</b>:</p>
<pre>
<code>extension Publisher {</code>
<code>    func combineCondition&lt;A, B, P: Publisher>(</code>
<code>        _ publisher: P</code>
<code>    ) -> Publishers.Map&lt;Publishers.CombineLatest&lt;Self, P>, Condition<(A, B)>></code>
<code>    where Output == Condition&lt;A>, P.Output == Condition&lt;B>, Failure == P.Failure {</code>
<code>        return combineLatest(publisher).map { tuple in</code>
<code>            guard case .satisfied(let pA) = tuple.0, case .satisfied(let pB) = tuple.1 else {</code>
<code>                return .unsatisfied</code>
<code>            }</code>
<code>            return .satisfied((pA, pB))</code>
<code>        }</code>
<code>    }</code>
<code>}</code>
</pre>
<p>As promised, things got weird pretty fast. Besides constraining the initial publisher's output to match the desired <code>Condition</code> type through an unconstrained generic <code>A</code> type in the method's signature, we also need to make sure that the merging publisher's <code>Failure</code> type matches the one that triggered the operation. That's a really big method!</p>
<p>To wrap it up, let me show you how to achieve the same thing when a custom type is used instead. In this case, we can do the same thing in the class's initializer:</p>
<pre>
<code>final class CombinedConditionPublisher&lt;A, B, F: Error>: Publisher {</code>
<code></code>
<code>    typealias Output = Condition<(A, B)></code>
<code>    typealias Failure = F</code>
<code></code>
<code>    let combined: AnyPublisher&lt;Condition&lt;(A, B)>, F></code>
<code></code>
<code>    init&lt;PA: Publisher, PB: Publisher>(</code>
<code>        _ a: PA,</code>
<code>        _ b: PB</code>
<code>    )</code>
<code>    where PA.Failure == F, PB.Failure == F, PA.Output == Condition&lt;A>, PB.Output == Condition&lt;B></code>
<code>    {</code>
<code>        combined = a.combineLatest(b).map { tuple in</code>
<code>            guard case .satisfied(let pA) = tuple.0, case .satisfied(let pB) = tuple.1 else {</code>
<code>                return .unsatisfied</code>
<code>            }</code>
<code>            return .satisfied((pA, pB))</code>
<code>        }.eraseToAnyPublisher()</code>
<code>    }</code>
<code></code>
<code>    func receive&lt;S>(subscriber: S) where S : Subscriber, Failure == S.Failure, Output == S.Input {</code>
<code>        combined.receive(subscriber: subscriber)</code>
<code>    }</code>
<code>}</code>
<code></code>
<code>extension Publisher {</code>
<code>    func combineCondition&lt;A, B, P: Publisher>(</code>
<code>        _ publisher: P</code>
<code>    ) -> CombinedConditionPublisher&lt;A, B, Failure></code>
<code>    where Output == Condition&lt;A>, P.Output == Condition&lt;B>, Failure == P.Failure {</code>
<code>        return CombinedConditionPublisher(self, publisher)</code>
<code>    }</code>
<code>}</code>
</pre>
<p>This case is a little more complex though, because we now need to use <code>AnyPublisher</code> to cover the fact that we cannot constrain <code>PA</code> and <code>PB</code> in the class's main definition. Still, the functionality will be the same.</p>
<div class="sponsor-article-ad-auto hidden"></div>
<p>While it's unfortunate that the signatures are enormous, things will look perfect on the call site. As mentioned before, as weird as it looks, this seems to be exactly how Combine implements some of its operators.</p>
<pre>
<code>let publisher = CurrentValueSubject&lt;Condition&lt;Int>, Never>(.satisfied(1))</code>
<code>let publisherB = CurrentValueSubject&lt;Condition&lt;Int>, Never>(.satisfied(2))</code>
<code></code>
<code>let combined = publisher.combineCondition(publisherB)</code>
</pre>
</div>
]]></description>
</item>
<item>
    <title>Benchmarking Swift Code Properly with Attabench</title>
    <link>https://swiftrocks.com/benchmarking-swift-code-properly-with-attabench</link>
    <guid>https://swiftrocks.com/benchmarking-swift-code-properly-with-attabench</guid>
    <pubDate>Tue, 20 Jul 2021 09:00:00 GMT-3</pubDate>
<description><![CDATA[
<!--WRITEIT_POST_NAME=Benchmarking Swift Code Properly with Attabench-->
<!--WRITEIT_POST_HTML_NAME=benchmarking-swift-code-properly-with-attabench-->

<!--Add here the additional properties that you want each page to possess.-->
<!--These properties can be used to change content in the template page or in the page itself as shown here.-->
<!--Properties must start with 'WRITEIT_POST'.-->
<!--Writeit provides and injects WRITEIT_POST_NAME and WRITEIT_POST_HTML_NAME by default.-->

<!--WRITEIT_POST_SHORT_DESCRIPTION=Hmmmm, how fast is this piece of code? Let's find out!-->

<!--DateFormat example: 2020-04-12T14:00:00+02:00-->
<!--WRITEIT_POST_SITEMAP_DATE_LAST_MOD=2021-07-20T14:00:00+02:00-->
<!--WRITEIT_POST_SITEMAP_DATE=2021-07-20T14:00:00+02:00-->

<title>Benchmarking Swift Code Properly with Attabench</title>
<div class="blog-post">
  <div class="post-title-index">
    <h1>Benchmarking Swift Code Properly with Attabench</h1>
  </div>  
  <div class="post-info">
    <div class="category category-swift">Swift</div>
    <div class="post-info-text">Published on 20 Jul 2021</div>
  </div>
<p>Hmmmm, how fast is this piece of code? Let's find out!</p>
<div class="sponsor-article-ad-auto hidden"></div>
<p>When it comes to benchmarking the speed of code, it's common for people to boot a playground, throw in a <code>Date</code> object and calculate the time difference after a piece of code runs. That may give you a rough estimate, but it can also be very misleading. The difference between code running in debug builds versus release ones can be massive, and the size of the input (assuming we're benchmarking an algorithm) can also make a huge difference in the speed of a function. In this article, we'll see how to properly benchmark your Swift code. (Note that we're not talking about things like iOS startup time -- we're talking about the speed to run a specific piece of code.)</p>
<h2>Introducing Attabench</h2>
<p><b>Attabench</b> is an open-source benchmarking tool created by Apple engineer Karoy Lorentey back in 2017 and has been my favorite benchmarking utility ever since I found it. The tool itself is a wrapper on top of Swift Package Manager that includes a benchmarking framework in where you can set up the code you'd like to measure, accompanied by a GUI app that lets you to see and customize how the result is presented:</p>
<div class="post-image">
  <img src="https://i.imgur.com/4p4iHrb.png" alt="Attabench">                             
</div>
<p>The measuring process is similar to how one would do with a playground, but Attabench's SPM abstraction not only compiles your app in the release configuration but also runs your code multiple times with different inputs, later providing a graph showing how your code behaves in function of the size of its input.</p>
<p>The project has technically been abandoned in favor of the <a href="https://github.com/apple/swift-collections-benchmark">Swift Collections Benchmark package</a> that is roughly the same thing as Attabench, but the package is heavily command-line based which makes it a lot harder to use than Attabench. For that reason, I think that Attabench is still the superior benchmarking tool.</p>
<p>You can download Attabench's source code in <a href="https://github.com/attaswift/Attabench">its repo</a>, but since the project has been abandoned a long time ago you may have issues compiling it with newer Xcode versions. My friend Rafael Machado was able to fix the compilation issues and provide a binary, <a href="https://drive.google.com/file/d/1ItV_YGGs8puCI1vvazmlttAydK1n20iv/view?usp=sharing">which you can download here for simplicity.</a></p>
<p>Before you open Attabench, we must first create a benchmarking file. It doesn't seem like you can create this from the tool itself, so we'll do it by copying an existing one. The zip downloaded I linked earlier has a <b>Sorting.attabench</b> file -- copy it somewhere and open it with Attabench.</p>
<p>When you open the file, you'll see a benchmark that compares Swift's default sorting method with a custom Quicksort. If you click the <b>Run</b> button, Attabench will start continuously running the two methods with different input sizes and update the graph as it proceeds:</p>
<div class="post-image">
  <img src="https://i.imgur.com/Gk4PxMV.png" alt="Alt">                                    
</div>
<p>It takes a massive amount of time for Attabench to fully complete its run, but you don't need for all of it. I normally wait just a couple of seconds until the graph appears to be stable enough and stop it.</p>
<p>One interesting configuration you can play with is the <b>input size</b> in the top left of the app, which controls the minimum and maximum value that Attabench will use in its runs. In this case, the value between 1 and 1 million dictates the number of elements in the array that is going to be parsed.</p>
<p>Another important configuration is <i>how</i> is shown to you, available at the top right. By default the graph shows the average of how long it takes and on a logarithmic scale, but I'm not smart enough to understand what I'm supposed to do with that information. I personally like to disable everything and see precisely how long the code takes to run for each input size.</p>
<p>Now that you know how to use Attabench, let's see how you can create your own benchmarks. The <b>.attabench</b> file is a workspace that you can open as a folder, and inside you'll find a SPM <b>Package.swift</b> file. If you open it in Xcode, you'll be able to see and modify the benchmark:</p>
<pre>
<code>let benchmark = Benchmark&lt;[Int]>(title: "Sorting")</code>
<code>benchmark.descriptiveTitle = "Time spent sorting elements"</code>
<code>benchmark.descriptiveAmortizedTitle = "Average time spent sorting elements"</code>
<code></code>
<code>benchmark.addSimpleTask(title: "Swift.sort") { input in</code>
<code>    _ = input.sorted()</code>
<code>}</code>
<code></code>
<code>benchmark.addTimerTask(title: "Quicksort") { (input, timer) in</code>
<code>    var input = input</code>
<code>    timer.measure {</code>
<code>        input.quicksort()</code>
<code>    }</code>
<code>}</code>
<code></code>
<code>benchmark.start()</code>
</pre>
<p>As you can see from the snippet, the benchmarking process is as simple as defining a benchmark object and registering the code that you want to measure.</p>
<p>The generic argument of the <code>Benchmark</code> represents the type of the input, which in this case is an array. You can modify it to be anything you want, as long you provide a function that generates the input for a given provided size. For example, if you'd like to create a benchmark where the input is a number, here's how we could define the <code>Benchmark</code> object:</p>
<pre>
<code>let benchmark = Benchmark&lt;Int>(title: "Calculate number of digits in a number") { size in</code>
<code>    return size</code>
<code>}</code>
</pre>
<p>As you might've realized by now, <code>size</code> is a random number between the range you defined previously in Attabench.</p>
<p>To define a block of code to be measured, simply add a call to <code>addSimpleTask</code> (heh) with the measured content inside a closure:</p>
<pre>
<code>benchmark.addSimpleTask(title: "Swift.sort") { input in</code>
<code>    _ = input.sorted()</code>
<code>}</code>
</pre>
<p>By default, the entire content of the closure will be measured. If you'd like to have finer-grained control over what's being measured, you can use one of the lower-level abstractions like <code>addTimerTask</code>. In this example case, I use a timer task to make sure Quicksort's benchmarking includes only the time it takes to run the algorithm itself, and not the setup needed to run it (creating a mutable copy):</p>
<pre>
<code>benchmark.addTimerTask(title: "Quicksort") { (input, timer) in</code>
<code>    var input = input</code>
<code>    timer.measure {</code>
<code>        input.quicksort()</code>
<code>    }</code>
<code>}</code>
</pre>
<div class="sponsor-article-ad-auto hidden"></div>
<p>Finally, you can call <code>benchmark.start()</code> to run the benchmark. To update the Attabench app after changing the code, simply click the refresh button at the top-left corner.</p>
</div>
]]></description>
</item>
<item>
    <title>How Actors Work Internally in Swift</title>
    <link>https://swiftrocks.com/how-actors-work-internally-in-swift</link>
    <guid>https://swiftrocks.com/how-actors-work-internally-in-swift</guid>
    <pubDate>Tue, 6 Jul 2021 09:00:00 GMT-3</pubDate>
<description><![CDATA[
 
  
  <!--WRITEIT_POST_NAME=How Actors Work Internally in Swift--> 
  <!--WRITEIT_POST_HTML_NAME=how-actors-work-internally-in-swift--> 
  <!--Add here the additional properties that you want each page to possess.--> 
  <!--These properties can be used to change content in the template page or in the page itself as shown here.--> 
  <!--Properties must start with 'WRITEIT_POST'.--> 
  <!--Writeit provides and injects WRITEIT_POST_NAME and WRITEIT_POST_HTML_NAME by default.--> 
  <!--WRITEIT_POST_SHORT_DESCRIPTION=Lets explore how actors work under the hood, using Swift's own source code as a guide to finding out how they work inside the compiler.--> 
  <!--DateFormat example: 2020-07-06T14:00:00+02:00--> 
  <!--WRITEIT_POST_SITEMAP_DATE_LAST_MOD=2021-07-06T14:00:00+02:00--> 
  <!--WRITEIT_POST_SITEMAP_DATE=2021-07-06T14:00:00+02:00--> 
  <title>How Actors Work Internally in Swift</title>  
 

<div class="blog-post"> 
 <div class="post-title-index">  
  <h1>How Actors Work Internally in Swift</h1>
 </div> 
 <div class="post-info"> 
  <div class="category category-compiler">
   Compiler
  </div> 
  <div class="category category-swift">
   Swift
  </div> 
  <div class="post-info-text">
   Published on 06 Jul 2021 
  </div> 
 </div>   
 <p><b>Actors</b> is a feature that is part of Swift's <i>Structured Concurrency</i>, bringing a brand new format to write and deal with asynchronous code. Although what Swift brings is new to the language, it's not new to tech itself. Many languages supported actors and async/await before Swift, but one interesting thing is that they are all implemented similarly. By having these features now in Swift, there's much we can learn from what developers experienced by using them in other languages.</p>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>Just like other "How X works internally in Swift" SwiftRocks articles, the purpose of this article is to explore how actors work under the hood, using Swift's own source code as a guide to finding out how they work inside the compiler.</p>
 <h2>What's an actor?</h2>
 <p>The purpose of the actor feature is to help prevent race conditions in the state of asynchronous classes. Although this is not a new concept, actors are part of a much bigger investment. While in theory you can reproduce everything an actor is doing by simply adding <code>NSLocks</code> to your classes' properties/methods, in practice they have a couple of important bonuses. First of all, the synchronization mechanism used by actors is not the locks we know, but async/await's new <b>Cooperative Threading Model</b> in which threads can seamlessly "change" contexts to execute other pieces of code to avoid ever having idle threads, and second of all, the presence of actors allow the compiler to check for many concurrency issues in <b>compile time</b>, letting you know right off the beat if something is potentially dangerous:</p>
 <pre>
<code>actor MyActor {</code>
<code>    var myProp = 0</code>
<code>}</code>
<code></code>
<code>MyActor().myProp</code>
<code>// error: actor-isolated property 'myProp' can only be referenced from inside the actor</code>
</pre>
 <p>In this case, one of the reasons why <code>myProp</code> can only be accessed from within the actor is that you can only use actors from within an <b>async</b> context, because the actor's synchronization implies that there's no guarantee that your code will be executed synchronously. Because of that, every actor method is implicitly <code>async</code> unless stated otherwise (shown later on).</p>
 <pre>
<code>Task {</code>
<code>    await actor.getMyProp()</code>
<code>}</code>
</pre>
 <h2>How do actors work?</h2>
 <p>One thing I like to mention is how most Swift language features are based on actual Swift code, and this is partially the case with actors too. In practice, actors are a syntax sugar for classes that inherit the <code>Actor</code> protocol:</p>
 <pre>
<code>public protocol Actor: AnyObject, Sendable {</code>
<code>  nonisolated var unownedExecutor: UnownedSerialExecutor { get }</code>
<code>}</code>
</pre>
 <p>This relation is automatically generated when the actor class is compiled, and like some other Swift features, you can actually reproduce this yourself:</p>
 <pre>
<code>final class MyCustomActor: Actor {}</code>
</pre>
 <p>In practice however, this won't work as a regular actor. Although this code works, the compiler will ask you to manually implement the <code>unownedExecutor</code> requirement and its synchronization mechanisms. This was a bit surprising to be honest, because some other features like the automatic <code>Codable</code> synthesis can automatically fill the gaps when you provide part of the implementation like in this example. Regardless of the intention, in the current Swift 5.5 build you can only have the complete actor implementation by using the <code>actor</code> keyword.</p>
 <p>The protocol states that all actors must also be <code>Sendable</code>, which is another new important piece of the concurrency proposal. This protocol has no actual code, and its purpose is to "mark" which types are safe to use in a concurrent environment. Even though actors by themselves are "safe", you could still have race condition issues if you, for example, used reference types as your state and leaked it outside the actor. To avoid this, Swift uses <code>Sendable</code> to indicate which types are thread-safe by design, which actually ends up being the backbone of the compile-time errors we saw before. Only immutable content like structs and final classes can inherit from <code>Sendable</code>, with <code>UnsafeSendable</code> being available as a workaround that skips all compile-time static analysis. As far I could tell however it appears that the implementation of <code>Sendable</code> is not yet complete, as it was stated in WWDC 2021 that a future intention is to stop actors from being able to leak non-Sendable types.</p>
 <h2>Executors</h2>
 <p>The most important aspect of the <code>Actor</code> protocol however is its required property: a nonisolated <code>unownedExecutor</code>. The <code>Executor</code> protocol was added in Swift 5.5 to define an object that can perform a "job", which in the case of actors are the methods themselves:</p>
 <pre>
<code>/// A service which can execute jobs.</code>
<code>@available(SwiftStdlib 5.5, *)</code>
<code>public protocol Executor: AnyObject, Sendable {</code>
<code>  func enqueue(_ job: UnownedJob)</code>
<code>}</code>
</pre>
 <p>In the same fashion, a <code>SerialExecutor</code> defines an object that performs jobs serially:</p>
 <pre>
<code>/// A service which can execute jobs.</code>
<code>@available(SwiftStdlib 5.5, *)</code>
<code>public protocol SerialExecutor: Executor {</code>
<code>  /// Convert this executor value to the optimized form of borrowed</code>
<code>  /// executor references.</code>
<code>  func asUnownedSerialExecutor() -&gt; UnownedSerialExecutor</code>
<code>}</code>
</pre>
 <p>Finally, an <code>UnownedSerialExecutor</code>, which is the <code>Actor</code> protocol's actual requirement, is simply an unowned reference to a <code>SerialExecutor</code>. As far as I could tell, this exists for optimization reasons.</p>
 <pre>
<code>let myExecutor = MySerialExecutor()</code>
<code>let unownedSerialExecutor = UnownedSerialExecutor(ordinary: myExecutor)</code>
</pre>
 <p>You might have noticed that this property contains a new keyword: <code>nonisolated</code>, which is what allows you to "override" Swift's compile-time checks for actors. Like we mentioned before with <code>Sendable</code>, Swift will try to make sure your actors are safe as possible, but there might be cases where this is a mistake. If something is truly meant to be accessed concurrently and on-demand, you can use the <code>nonisolated</code> keyword to detach it from Swift's checks. In this case, the executor needs to be detached from the protections so that we have an actual entry-point to the actor.</p>
 <p>Swift automatically generates an executor for your actors, but before seeing how that works, we should see executors in action in another new feature: <b>Global Actors</b>.</p>
 <h2>Executors in Global Actors</h2>
 <p>Global Actors exisst to cover the fact that state synchronization is not limited to local variables, meaning that you might need to have global access to an actor. Instead of forcing everyone to write singletons everywhere, Swift 5.5's Global Actors feature allows you to easily indicate that a certain piece of code should be executed within the bounds of a specific global actor. Perhaps the most important example of this is <code>MainActor</code>, which is a global actor that makes sure all code is executed in the main thread.</p>
 <pre>
<code>@MainActor doSomethingInMain() {</code>
<code>    something() // Will always be executed in main</code>
<code>}</code>
</pre>
 <p>It's possible to create your own global actors by adding the <code>@globalActor</code> attribute to an actor. By default, Swift will treat your actor as a regular one and generate a default executor for you, but since this is a protocol requirement, you actually override it and create your own synchronization mechanism! In fact, this is exactly how <code>MainActor</code> works -- async/await's threading is based not on <code>DispatchQueues</code>, but the new <i>Cooperative Threading Model</i> runtime feature mentioned in the beginning of this article. We shall explore this in a separate article about async/await, but in short, the main thread is not part of this new model, so actors cannot execute code in the main thread by default. In practice, the way <code>MainActor</code> achieves this is by defining a custom <code>SerialExecutor</code>, which in Swift's source code is the <code>MainActor</code> itself.</p>
 <pre>
<code>/// A singleton actor whose executor is equivalent to the main</code>
<code>/// dispatch queue.</code>
<code>@available(SwiftStdlib 5.5, *)</code>
<code>@globalActor public final actor MainActor: SerialExecutor {</code>
<code>  public static let shared = MainActor()</code>
<code></code>
<code>  @inlinable</code>
<code>  public nonisolated var unownedExecutor: UnownedSerialExecutor {</code>
<code>    return asUnownedSerialExecutor()</code>
<code>  }</code>
<code></code>
<code>  @inlinable</code>
<code>  public nonisolated func asUnownedSerialExecutor() -&gt; UnownedSerialExecutor {</code>
<code>    return UnownedSerialExecutor(ordinary: self)</code>
<code>  }</code>
<code></code>
<code>  @inlinable</code>
<code>  public nonisolated func enqueue(_ job: UnownedJob) {</code>
<code>    _enqueueOnMain(job)</code>
<code>  }</code>
<code>}</code>
</pre>
 <p>When you call an actor method, Swift will replace your code with a call to the actor's executor's <code>enqueue(_:)</code> method. This is why actors can only be used in <code>async</code> contexts -- you're essentially doing the equivalent of a <code>DispatchQueue.async</code> in the old world! This is how a call to <code>MainActor</code> looks in practice:</p>
 <pre>
<code>Task {</code>
<code>    await myMainActorMethod()</code>
<code>}</code>
</pre>
 <p>Under the scenes however, Swift will process this as something akin to this:</p>
 <pre>
<code>Task {</code>
<code>    MainActor.shared.unownedExecutor.enqueue {</code>
<code>        myMainActorMethod()</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>Which, in the case of MainActor, is essentially a call to <code>DispatchQueue.main</code>.</p>
 <pre>
<code>DispatchQueue.main.async {</code>
<code>    myMainActorMethod()</code>
<code>}</code>
</pre>
 <p>I should let you know that this is not entirely accurate because the functionality of actors (and the executors specifically) are in practice tightly connected to async/await and its new <code>Task</code> model, but I shall ignore this for now and explore the details of that in a separate article about how async/await itself works.</p>
 <p>In short, what we're looking at here is that though Swift generates all the implementation of an actor for you, it's still possible for you to override its behavior. In my opinion though I can't see a single reason why someone would need to do this besides the main thread case that Swift already provides to you, so you should probably never attempt to do this yourself.</p>
 <h2>Swift's Default Actor</h2>
 <p>Now that we understand how executors are used, we're ready to investigate how actors actually work. Swift's actor behavior is based on something called a <b>default actor</b>, which could be explained as a base class that handles all the synchronization needs of the actor. When you define an empty actor, this is how it'll look like after the code is compiled:</p>
 <pre>
<code>actor MyActor {}</code>
<code></code>
<code>// Compiled:</code>
<code></code>
<code>final class MyActor: Actor {</code>
<code>    var unownedExecutor: UnownedSerialExecutor {</code>
<code>        return Builtin.buildDefaultActorExecutorRef(self)</code>
<code>    }</code>
<code></code>
<code>    init() {</code>
<code>        _defaultActorInitialize(self)</code>
<code>    }</code>
<code></code>
<code>    deinit {</code>
<code>        _defaultActorDestroy(self)</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>In this case, the implementation of the executor is not a separate object like with <code>MainActor</code>, but a reference to the actor itself. This is where things differ from other features we covered in the past: The actual functionality of the actor is not Swift code, but a C++ class:</p>
 <pre>
<code>class DefaultActorImpl : public HeapObject {</code>
<code>public:</code>
<code>  void initialize();</code>
<code>  void destroy();</code>
<code>  void enqueue(Job *job);</code>
<code>  bool tryAssumeThread(RunningJobInfo runner);</code>
<code>  void giveUpThread(RunningJobInfo runner);</code>
<code>}</code>
</pre>
 <p>The reason for this is that, as mentioned before, threading in actors is not done by <code>DispatchQueues</code>, but a new language and runtime feature that was introduced alongside async/await. This is why you need iOS 15 to use actors or async/await -- these are not simply Swift improvements, they required changes in iOS itself.</p>
 <p>The functionality of the default actor is heavily connected to the functionality of async/await, so we shall skip some concepts for now. But in regards to queueing, the default actor is mostly a state machine that holds a linked list of jobs:</p>
 <pre>
<code>enum class Status {</code>
<code>  Idle,</code>
<code>  Scheduled,</code>
<code>  Running,</code>
<code>};</code>
<code></code>
<code>struct alignas(2 * sizeof(void*)) State {</code>
<code>  JobRef FirstJob;</code>
<code>  struct Flags Flags;</code>
<code>};</code>
<code></code>
<code>swift::atomic&lt;State&gt; CurrentState;</code>
<code></code>
<code>static void setNextJobInQueue(Job *job, JobRef next) {</code>
<code>  *reinterpret_cast&lt;JobRef*&gt;(job-&gt;SchedulerPrivate) = next;</code>
<code>}</code>
</pre>
 <p>When a job is enqueued, the default actor grabs its old state and appends the new job.</p>
 <pre>
<code>// The actual implementation of this method is considerably more complicated.</code>
<code>// This is simplified for educational purposes.</code>
<code>void DefaultActorImpl::enqueue(Job *job) {</code>
<code>  auto oldState = CurrentState.load(std::memory_order_relaxed);</code>
<code>  setNextJobInQueue(job, oldState.FirstJob);</code>
<code>}</code>
</pre>
 <p>The actual execution of these jobs is what's heavily connected to async/await, but we can still take a quick look at it. First of all, the execution of a job inside an actor has a priority attached to it, which comes from async/await's <code>Task</code> object. When a job is enqueued, its priority is adjusted to make sure it's executed before other less prioritized events.</p>
 <pre>
<code>auto oldPriority = oldState.Flags.getMaxPriority();</code>
<code>auto newPriority =</code>
<code>  wasIdle ? job-&gt;getPriority()</code>
<code>  : std::max(oldPriority, job-&gt;getPriority());</code>
<code>newState.Flags.setMaxPriority(newPriority);</code>
</pre>
 <p>When a job is enqueued, the actor registers the job is something called a <b>global executor</b>, which is essentially the C++ implementation of the class that handles async/await's <i>Cooperative Threading Model</i>. In short, actors can own and yield threads, and the global executor will notify an actor when it's allowed to own a specific thread. When this happens, the default actor will execute the first job in the queue and yield the thread.</p>
 <pre>
<code>// Note that this is not the actual implementation but an oversimplification of it.</code>
<code>static void processDefaultActor() {</code>
<code>    auto job = claimNextJobOrGiveUp();</code>
<code>    runJobInEstablishedExecutorContext(job);</code>
<code>    giveUpThread();</code>
<code>}</code>
</pre>
 <p>Additionally, when an actor's method contains an <code>await</code> call, the actor will actually yield the thread in the middle of the execution of the job, allowing other actors to be executed while this one is waiting. When a result is available, a new job will be enqueued for the actor to pick up later on in a (possibly) different thread. This is what the concurrency model describes as <b>Actor Reentrancy</b>, and is why you should be careful with thread-sensitive content like <code>DispatchSemaphores</code> in async/await code -- <b>there's no guarantee that the thread that started a job will be the one that continues it.</b></p>
 <div class="sponsor-article-ad-auto hidden"></div>
 <h2>Conclusion</h2>
 <p>As we've seen, the execution side of Swift's concurrency model centers around scheduling work onto various execution services. Although this execution is available as a high-level Swift protocol, the actual implementation of an actor needs to be a lower-level C++ mechanism due to the new runtime features required by async/await. In a future article, we shall explore async/await and its <i>Cooperative Threading Model</i>.</p>
 <h2>References and Good Reads</h2>
 <a href="https://github.com/apple/swift/blob/main/stdlib/public/Concurrency/Actor.swift">Actor.swift</a>
 <br>
 <a href="https://github.com/apple/swift/blob/main/stdlib/public/Concurrency/Actor.cpp">Actor.cpp</a>
 <br>
 <a href="https://github.com/apple/swift/blob/main/stdlib/public/Concurrency/Executor.swift">Executor.swift</a>
 <br>
 <a href="https://github.com/apple/swift/blob/main/stdlib/public/Concurrency/GlobalExecutor.cpp">GlobalExecutor.cpp</a>
 <br>
</div>]]></description>
</item>
<item>
    <title>Creating 3D Models from Photographs with RealityKit in Swift</title>
    <link>https://swiftrocks.com/creating-3d-models-out-of-anything-with-realitykit-in-swift</link>
    <guid>https://swiftrocks.com/creating-3d-models-out-of-anything-with-realitykit-in-swift</guid>
    <pubDate>Tue, 22 Jun 2021 09:00:00 GMT-3</pubDate>
<description><![CDATA[
 
  
  <!--WRITEIT_POST_NAME=Creating 3D Models from Photographs with RealityKit in Swift--> 
  <!--WRITEIT_POST_HTML_NAME=creating-3d-models-out-of-anything-with-realitykit-in-swift--> 
  <!--Add here the additional properties that you want each page to possess.--> 
  <!--These properties can be used to change content in the template page or in the page itself as shown here.--> 
  <!--Properties must start with 'WRITEIT_POST'.--> 
  <!--Writeit provides and injects WRITEIT_POST_NAME and WRITEIT_POST_HTML_NAME by default.--> 
  <!--WRITEIT_POST_SHORT_DESCRIPTION=RealityKit Object Capture is a feature introduced in Xcode 13 that allows you to create 3D objects from photographs using a process called photogrammetry.--> 
  <!--DateFormat example: 2020-04-12T14:00:00+02:00--> 
  <!--WRITEIT_POST_SITEMAP_DATE_LAST_MOD=2021-06-22T14:00:00+02:00--> 
  <!--WRITEIT_POST_SITEMAP_DATE=2021-06-22T14:00:00+02:00--> 
  <title>Creating 3D Models from Photographs with RealityKit in Swift</title>  
 

<div class="blog-post"> 
 <div class="post-title-index">  
  <h1>Creating 3D Models from Photographs with RealityKit in Swift</h1>
 </div> 
 <div class="post-info"> 
  <div class="category category-ios">
   iOS
  </div> 
  <div class="post-info-text">
   Published on 22 Jun 2021 
  </div> 
 </div>  
 <p><i>RealityKit Object Capture</i> is a feature introduced in Xcode 13 that allows you to create 3D objects from photographs using a process called photogrammetry. Although intended for retailers to enhance their online shopping experience by creating models out of things like furniture and using them in augmented reality experiences, RealityKit is incredibly easy to use for anything you may want, like 3D printing random things from your house.</p>
 <div class="post-image"> 
  <img style="height: 300px;" src="https://i.imgur.com/sp4LypF.gif" alt="Mug"> 
 </div>
 <p>To use Object Capture, you must:</p>
 <ul> 
  <li>Be running macOS 12 (this feature is not available in iOS!)</li> 
  <li>Provide photographs of the object you want to capture</li> 
 </ul>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>Capturing photographs of the object is not hard, although you may have to fine-tune your environment to get better results. The idea is to place your object in a well-lit place and continuously take pictures as you round the object. You can also take pictures of the bottom of the object if you'd like that to be modeled as well, by taking pictures of the object flipped upside-down in the same environment.</p>
 <p>Your pictures don't need to have any particular ordering or naming for Object Capture to work and there's no minimum number of pictures you need to take, although you might better results the more you do. I've found that ~30ish pictures already give a nice result. Quite easy!</p>
 <div class="post-image"> 
  <img style="height: 300px;" src="https://i.imgur.com/9ZiPV1Y.gif" alt="Pictures example"> 
 </div>
 <h2>Creating a Photogrammetry CLI App</h2>
 <p>To use Object Capture, start by creating a new Command Line App in Xcode and add new a class named <code>Session</code>:</p>
 <pre>
<code>import Foundation</code>
<code>import RealityKit</code>
<code>import Combine</code>
<code></code>
<code>final class Session {</code>
<code>    </code>
<code>    let inputFolder = URL(fileURLWithPath: "/Users/myUser/myPictures", isDirectory: true)</code>
<code>    let outputFile = URL(fileURLWithPath: "/Users/myUser/result.usdz")</code>
<code>    var subscriber: AnyCancellable?</code>
<code></code>
<code>    func run() throws {</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>Object Capture works by creating a <code>PhotogrammetrySession</code> object, configuring it, passing the folder that contains our pictures and waiting for the result. The result comes asynchronously through Combine, so make sure to create a <code>subscriber</code> object like in the snippet.</p>
 <p>In the <code>run()</code> method, create a <code>PhotogrammetrySession</code> with the default configuration:</p>
 <pre>
<code>let configuration = PhotogrammetrySession.Configuration()</code>
<code>let session = try PhotogrammetrySession(</code>
<code>    input: inputFolder,</code>
<code>    configuration: configuration</code>
<code>)</code>
</pre>
 <p>It's possible to fine-tune the final model, which we'll see further on. For now, let's use the default settings.</p>
 <p>With a session, we should now create a request to fabricate a model from our photographs:</p>
 <pre>
<code>let request = PhotogrammetrySession.Request.modelFile(url: outputFile)</code>
</pre>
 <p>To wrap it up, we should observe the progress of the request and wait for it to end. As mentioned before, this process is done asynchronously with Combine, so we should attach a subscriber to the session's <code>output</code> property.</p>
 <p>Additionally, since this is a CLI app, we need to make sure the app stays alive while the model is being created. For simplicity, I've decided to attach a semaphore to the operation:</p>
 <pre>
<code>let semaphore = DispatchSemaphore(value: 0)</code>
<code></code>
<code>subscriber = session.output.sink(receiveCompletion: { completion in</code>
<code>    print(completion)</code>
<code>    exit(0)</code>
<code>}, receiveValue: { output in</code>
<code>    switch output {</code>
<code>    case .processingComplete:</code>
<code>        print("Processing is complete.")</code>
<code>        semaphore.signal()</code>
<code>    case .requestComplete(let request, let result):</code>
<code>        print("Request complete.")</code>
<code>        print(request)</code>
<code>        print(result)</code>
<code>        semaphore.signal()</code>
<code>    case .requestProgress(let request, let fractionComplete):</code>
<code>        print("Request in progress: \(fractionComplete)")</code>
<code>    default:</code>
<code>        print(output)</code>
<code>    }</code>
<code>})</code>
<code></code>
<code>try session.process(requests: [request])</code>
<code></code>
<code>semaphore.wait()</code>
</pre>
 <p>As you can see, many aspects of the process can be observed. In this case, I'm only interested in the actual progress.</p>
 <p>Before running the app, edit your <code>main.swift</code> file to call our <code>run()</code> method:</p>
 <pre>
<code>try! Session().run()</code>
</pre>
 <p>The process takes a while to start and may take several minutes to finish, so don't worry if you get a bunch of prints but not progress at first. Wait a bit and it will start!</p>
 <div class="post-image"> 
  <img style="height: 300px;" src="https://i.imgur.com/QvvOiYE.gif" alt="Pictures result"> 
 </div>
 <h2>Configuring PhotogrammetrySessions</h2>
 <p>To fine-tune your results, there are two aspects of Object Capture that can be configured. The first one is the detail of the output, which you can control to determine the number of polygons in the final model:</p>
 <pre>
<code>let request = PhotogrammetrySession.Request.modelFile(</code>
<code>    url: outputFile,</code>
<code>    detail: .preview</code>
<code>)</code>
</pre>
 <p>Details range from the lower quality <code>preview</code> to the high-end <code>full</code>. Try playing with lower-quality settings before trying to generate a higher-quality one.</p>
 <p>The second aspect that can be configured in the input itself:</p>
 <pre>
<code>var configuration = PhotogrammetrySession.Configuration()</code>
<code>configuration.sampleOverlap = .low</code>
<code>configuration.sampleOrdering = .unordered</code>
<code>configuration.featureSensitivity = .high</code>
</pre>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>The configuration struct allows you to provide more information about your photographs, which may result in a better model. <code>sampleOverlap</code> allows you to describe how much overlap there is between each photograph, <code>sampleOrdering</code> allows you to indicate whether or not your photographs are ordered (which will speed the process), and <code>featureSensitivity</code> indicates how hard RealityKit should try to search for features in your object, which should be used in cases where the object doesn't have a lot of discernible structures, edges or textures.</p>
</div>]]></description>
</item>
<item>
    <title>How necessary are the programming fundamentals?</title>
    <link>https://swiftrocks.com/how-necessary-are-the-programming-fundamentals</link>
    <guid>https://swiftrocks.com/how-necessary-are-the-programming-fundamentals</guid>
    <pubDate>Tue, 18 May 2021 09:00:00 GMT-3</pubDate>
<description><![CDATA[
 
  
  <!--WRITEIT_POST_NAME=How necessary are the programming fundamentals?--> 
  <!--WRITEIT_POST_HTML_NAME=how-necessary-are-the-programming-fundamentals--> 
  <!--Add here the additional properties that you want each page to possess.--> 
  <!--These properties can be used to change content in the template page or in the page itself as shown here.--> 
  <!--Properties must start with 'WRITEIT_POST'.--> 
  <!--Writeit provides and injects WRITEIT_POST_NAME and WRITEIT_POST_HTML_NAME by default.--> 
  <!--WRITEIT_POST_SHORT_DESCRIPTION=In this article, we'll introduce the field of algorithms and data structures in a neutral way, show how this knowledge is applied in practice using an analogy, and finally use all of that to clarify why large companies like Google and Apple are so focused on it.--> 
  <!--DateFormat example: 2021-05-18T14:00:00+02:00--> 
  <!--WRITEIT_POST_SITEMAP_DATE_LAST_MOD=2021-05-20T23:00:00+02:00--> 
  <!--WRITEIT_POST_SITEMAP_DATE=2021-05-18T14:00:00+02:00--> 
  <title>How necessary are the programming fundamentals?</title> 
 

<div class="blog-post"> 
 <div class="post-title-index">  
  <h1>How necessary are the programming fundamentals?</h1>
 </div> 
 <div class="post-info"> 
  <div class="category category-theory">
   Theory
  </div> 
  <div class="post-info-text">
   Published on 18 May 2021 
  </div> 
 </div>   
 <p>I've been meaning to write an article about computer science fundamentals and how it can improve a programmer's career for a long time, but I always had trouble finding a good way of introducing this topic. The reason I'd like to talk about this is first that, well, I really like this field and I feel that most of my programming ability today is a result of having studied this, but also because this topic has been a constant source of frustration for me, and I've been hoping I could address that.</p>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>The reason? There's a part of the tech community that absolutely <i>despises</i> this topic, especially when it shows up in interview processes. To be specific, this part of the community is <b>really</b> against the fact that large companies like Google and Apple base their interview processes around a person's knowledge of programming theory, to the point where they actively fight against this practice. This has since evolved in a way where mentioning theory at all in certain places is met with severe backlash, immediately turning it into a holy war.</p>
 <p>What do I think about this? Well, I was actually one of these people at one point. I too had my share of bashing this practice, but as my career progressed and I started learning more about programming in general I started to realize that not only things weren't so black and white, but also that there was an important reason for them to be doing that. Today I think that people misunderstand the purpose of this field, especially on <b>why</b> these companies are choosing to give it importance.</p>
 <p>Everyone is free to study and specialize in what they want, but I think we as a community should be really careful when we advocate that others should be <i>against</i> something. I honestly believe that these misunderstandings can hurt the careers of those who believe in them and limit what we can achieve as a tech community, and I would like to give you a different point of view as an attempt to give you the full picture and resolve this misunderstanding.</p>
 <p>In this article, we'll introduce the field of algorithms and data structures, show how this knowledge is applied in practice using an analogy, and finally use all of that to clarify <b>why</b> large companies like Google and Apple are so focused on it. I hope that this will give you the tools to make your own conclusions about this topic, allowing you to not only understand why they do what they do but also to help you determine if this is something you should be studying to achieve your goals.</p>
 <blockquote>
  Before we continue, an important distinction must be made: 
  <b>The purpose of this article is not to defend these companies' practices of applying difficult whiteboard puzzles in their interviews</b>, but to clarify 
  <b>the concept of <i>why</i></b> they do so. Whether or not these companies are applying this concept efficiently however, especially when it comes to fairness and inclusion, is a separate issue that will not be touched here. Our objective is to focus solely on the 
  <i>engineering aspect</i> of these interviews.
 </blockquote>
 <h2>What's the confusion about?</h2>
 <p>The most common source of discussions and main source of misunderstandings is how the interview process of large tech companies like Google, Apple and Facebook work.</p>
 <p>When regular-sized companies hire programmers, they usually look for people to perform a specific role at a specific platform (for example, iOS Developer). In this case, it's very common for the interview processes to focus on the <i>practical</i> aspects of these platforms, such as understanding how the platform works, the details of certain APIs, and the person's overall ability to work with that specific platform.</p>
 <p>Larger companies, however, focus more on the <i>theory</i> of programming, asking questions not about what you can do in a specific platform, but about your understanding of the building blocks that allow such platforms to exist in the first place. This includes understanding the functionality of basic data structures like <code>Arrays</code> and <code>Sets</code>, your ability to predict, often in an academic fashion, the performance of your code, and your knowledge of fundamental algorithms like a binary search, often in the shape of a programming puzzle. The field that composes all of this knowledge can have multiple names, with the most common ones being <i>Algorithms and Data Structures</i> and <i>CS Fundamentals</i>.</p>
 <p>When you study computer science at a more traditional college, these fundamentals are often introduced as the very introduction to programming. There, while you learn how to code, you will also be studying the fundamentals that will allow you to understand how computer science in general works, and instead of learning how to code for a specific platform, you'll often study programming from a <i>generic</i> and theoretical point of view that can be applied to any field you wish to specialize in the future.</p>
 <p>At the same time, it's very common for people to learn programming through bootcamps and online courses. In these mediums, programming is often taught from a more practical perspective. Instead of learning the theory, you go straight to coding on a specific platform of your choice, learning the concepts of programming by seeing them work in practice. As we've seen above, because regular companies put more value on the practical aspects of programming, this is a perfectly fine learning path. In fact, this is how I got into programming!</p>
 <p>When a person with the non-traditional background decides that it's time to apply at one of the world's main tech companies, the difference between covered topics in the interview process often catches them by surprise. Even though they have great practical programming experience, nothing they worked on could possibly answer the difficult theoretical content the companies are asking. After a very frustrating interview, the now disappointed person expresses their discomfort with the format and claims that a programmer doesn't need to know these things to perform their job. As I mentioned previously, I was this person at one point.</p>
 <p>Here are some common complaint points from those who go through this experience:</p>
 <ul> 
  <li>The questions don't reflect what the person will actually do in their job.</li> 
  <li>The questions are not indicative of the person's skill in the role being interviewed for. (the job is often for a specific platform, but the questions are almost always completely unrelated to it)</li> 
  <li>The questions, in general, are pointless. Why does an iOS developer need to know how sorting functions work?</li> 
 </ul>
 <p>People who feel this way then claim that this field is something that only academics should worry about, and a practical programmer should not have to deal with this in a job interview.</p>
 <p>I think anyone can see why someone would have these views. If you have never been introduced to this field, it can definitely look like it's all about pieces of obscure knowledge that aren't relevant to the actual role. They are called fundamentals, but you can learn how to code without them. Are they really that fundamental? Why do these companies care about them?</p>
 <p>What these points misunderstand is <b>the role</b> this knowledge plays in your programming ability. Let's take a look at the third point again:</p>
 <ul> 
  <li>The questions, in general, are pointless. Why does an iOS developer need to know how sorting functions work?</li> 
 </ul>
 <p>Our first impression is to think that these companies are insinuating that you as a programmer need to know these things because that's what your job is going to be about, but that's just not how any of this works. Seriously, <b>nobody</b> is coding custom sorting functions in their apps. Stop thinking that's what the fundamentals are for!</p>
 <p>In reality, people use what they know about these sorting functions as a <i>reference</i> to determine how a certain piece of code they're writing should be designed. If this sounds familiar to you, then it's because that's how most of programming works! This is certainly something you do all the time, the difference is just what you're using as a reference.</p>
 <p>This implicitness gives people the impression that the fundamentals are useless, while in reality, they're using them all the time! They just probably never made the distinction between what part of their knowledge is platform-specific (like knowing UIKit APIs in iOS) and what is actually fundamental knowledge (like knowing the difference between an <code>Array</code> and a <code>Set</code>) that they picked up in practice. In short, even if you never studied CS Fundamentals, you as a professional programmer probably already know part of it, you just skipped the part where you learn how to describe them in a more generic fashion.</p>
 <p>What about the other part though? Even though everyone can learn about things like <code>Arrays</code> in practice, the fundamentals often go much deeper than that. When would knowing the ultra-complicated details of something like an index tree ever be useful for a mobile developer?</p>
 <h2>Analogy: Becoming a professional musician</h2>
 <p>To explain this, I would like to draw an analogy with a person's journey of learning a musical instrument. This is because musical instruments are accompanied by <b>music theory</b>, and I find the relation between them to be very similar to the one between programming and algorithms.</p>
 <blockquote>
  <i>21-05-2021 Update</i>: I initially wrote this article comparing FAANG companies to accomplished rock bands, but actual musicians commented saying that a classical orchestra would be a better comparison. I updated the analogy -- thank you for your inputs!
 </blockquote>
 <p>In music, music theory is the study of the practices and possibilities of music. It seeks to define the processes and general principles of music, but also the concepts that define what <i>music</i> itself is, defining exactly what is a note, the theoretical definition of a chord and how it can be manipulated, how chords can be grouped into keys and how musical progression works.</p>
 <p>A person who wants to learn an instrument like the electric guitar and is doing music lessons will be introduced to the concept of music theory, but also be told that they don't really <i>need</i> to learn it to learn how to play the guitar. Although they will need to learn the basics of notes and chords, there's no need to get into the deeper complicated details unless the person happens to be interested in that. The learner will be perfectly capable to learn how to play their favorite songs, and maybe even play in a cover band with their friends. As we've seen above, this is exactly the same scenario we see in programming.</p>
 <p>In the case of music, the details of music theory start becoming more relevant when the person starts wanting to compose <b>their own songs</b>. Although not an impossible task, if the person doesn't understand the theory, it's likely that these songs are going to be flawed in a way or two. As this person doesn't know chord theory, they will probably have a really hard time figuring out the correct way of achieving sounds that they have never played before -- assuming that they can even determine which sounds they should use. That person is perfectly capable of playing the chords and songs composed by <i>other people</i>, but if they never studied the theory of how that works, they will be hindered when trying to compose their own material. To make it worse, musical progression is not a thing you just come up with -- there are multiple reasons why your favorite songs are your favorite songs, and the concepts that make a song sound pleasant are explained in great detail in music theory. We can say that composing songs is the more <i>explicit</i> application of music theory, which could be comparable to a programmer actually being tasked to code a complicated algorithm.</p>
 <p>However, music theory has also an <b>implicit</b> application, which is that <b>people who learn music theory are great musicians in general.</b> Even though the person might not be composing their own songs, their understanding of music likely makes them very comfortable playing and improvising any kind of song. These people are usually extremely skilled, being able to learn how to play new songs by ear without ever needing to check how the band that made the song actually plays it. The logic is simple: <b>they don't need to, because they know what they're doing.</b></p>
 <p>Another implicit benefit of music theory is that <b>it applies to every instrument.</b> People who understand music theory usually have a very easy time mastering different instruments because most of what they know also applies to this new instrument. All they need to learn is how the instrument is played.</p>
 <p>These are exactly the benefits that learning CS Fundamentals provide you in everyday programming. Even though you're not "composing your own algorithms", your knowledge of how computer science works provides a serious boost to your programming ability in general. The difference between music and programming is what exactly is "boosted": While a musician that knows the theory will be better at designing and understanding music, a programmer who knows the theory will be better at designing and understanding <b>systems</b>. A person who doesn't know programming theory is perfectly capable of creating a good product from the user point of view, but it's likely that they will be severely hindered from a <i>system design</i> point of view.</p>
 <p>It's important to understand however what it's <i>meant</i> by system design in this case; We are not talking about concepts like clean code and SOLID, but how <b>correct</b> your code is from a design, performance and resource management point of view. Note that <i>correct</i> doesn't mean "this code must use this ultra-fast obscure algorithm a Russian man published in 1970, otherwise it's wrong", it simply means that the code you're writing <b>makes sense</b> from an engineering standpoint. I'm gonna say it again: Stop thinking that the fundamentals are only about coding obscure algorithms!</p>
 <p>If this doesn't click for you, think how correctness applies in the musician's example: Even though two musicians might be playing the exact same song, one of them might have really bad posture and a choice of chords that is all over the fretboard. The other musician however has learned the proper posture, and their knowledge of theory allows them to find the exact same chords in much more comfortable positions. It's the same song with the same result, but one of the musicians will have a much easier time playing it, while the other one will struggle and likely end up with tendonitis.</p>
 <h2>Who <i>really</i> needs to learn the theory?</h2>
 <p>I hope that by now you have a clear view of how a programmer can benefit from studying the fundamentals, but before clarifying why companies like Google actually require them in their interviews, let's first evaluate this knowledge from a <b>career necessity</b> standpoint.</p>
 <p>If we go back to the music example, we can say that the <i>necessity</i> of studying music theory in a musician's career will heavily depend on what the musician wishes to achieve:</p>
 <ul> 
  <li>Do I want to learn it as a hobby, and never go beyond playing in my couch for fun?</li> 
  <li>Do I want to play in a band, and solidify myself as a musical artist?</li> 
  <li>Do I aspire to go beyond the mere title of a "musical artist" by living and breathing classical music, becoming an integral part of the Vienna Philharmonic, traveling the world, and going down as a legend that literally shaped the concept of music itself?</li> 
 </ul>
 <p>It should be clear that our non-orchestra-dreamer-fanatics don't need music theory, as they can definitely achieve everything they want without it. They can still benefit from it if they want -- learning it would allow them to master their instrument, as well as open the door to every other musical instrument. However, from a pure <i>career necessity</i> standpoint, we can safely say that the theory is just a bonus thing they could learn to be a better musician.</p>
 <p>The dreamer, however, has a completely different objective. This person is not looking to simply have fun, they want to be part of a group of people who dedicate their entire lives to perfecting music as an art form. A famous orchestra will obviously not accept some random joe who picked up a violin weeks ago -- you must at very least be exceptionally good and versatile as a musician. Even though some professional musicians might argue that even in this case it's technically possible for the person to achieve this goal without formally studying the theory, it's clear that not having a deeper level of knowledge about music would be a major setback in this person's career. In fact, orchestras are so serious that having formally studied music is often a minimum requirement.</p>
 <p>Just like in this analogy, the necessity of studying algorithms in your career depends on what you as a programmer want to achieve. If you learned programming as a hobby and don't really want to work with it, then the fundamentals are not necessary at all. Similarly, if you see yourself working at a regular and more practical company, then it's also likely that you will never face a situation where the fundamentals would make a big difference. You could learn it to improve your ability in general, but from a pure <i>necessity</i> standpoint, you can surely live without them.</p>
 <p>However, if you aspire to learn multiple platforms, work in a global tech company with amazing salaries and perks, working with incredibly smart people who are at the top of their field helping them <i>literally</i> define what tech is, then it should be clear that even though it's technically possible for you to land this job with 100% practical experience, you as a programmer would seriously benefit from having a deeper level of understanding of the field.</p>
 <h2>Why are the top-tier companies so focused on the fundamentals?</h2>
 <p>To understand why larger companies are so obsessed with the theory, we'll focus on one of the other points:</p>
 <ul> 
  <li>The questions don't reflect what the person will actually do in their job.</li> 
 </ul>
 <p>I actually agree with this point, because these companies really do a bad job with their questions. However, what's incorrect with this point is that it misses an important detail of how these companies operate -- a common misunderstanding that we should probably be blaming bad job descriptions for.</p>
 <p>While in regular companies you are likely to be hired to perform a very specific role as a specialist, larger companies like Google are almost always focused on engineering T-shapedness and generalism. This means that even though you might be hired to do something specific like iOS development, it's still expected that you the ability to work with different platforms if needed. I work in one of these companies -- even though I work primarily with iOS, there were many cases where a task I was doing involved checking code that was outside of iOS, like a relevant piece of Android code, the functionality of a C++ library, or even writing a new data pipeline inside our backend. This is expected, and as a generalist myself, this is something that I personally really enjoy doing.</p>
 <p>I'd say that the reason why this happens is the nature of these companies -- while a regular company is trying to solve a small scale problem that has likely been done before, top-tier companies have to deal with enormous problems that nobody has ever faced, which often requires them to be masters in multiple platforms. It's not interesting for a company like Google to hire someone who dedicated their life to understand all about UIKit in iOS -- their problem is not that they don't know which UIKit APIs to use, is that the APIs they need <b>don't exist at all</b>. These problems are not solved by a person's platform knowledge, but by their understanding of computer science and their ability to craft new and efficient solutions.</p>
 <p>Just like how music theory applies to all instruments, the fundamentals apply to all platforms. A reason why these companies focus on them is that it essentially proves that you can work with anything -- even if you never worked with a different platform, knowing the fundamentals will likely make it very easy for you to pick them up. A generalist might not know some random trivia about <code>UITableView</code> APIs that a specialist would, but they don't need to because this is the programming equivalent of the musician who can learn how to play a song by just listening to it. It's easy for a generalist to learn programming languages and platforms -- what's difficult to learn are programming skills you need to have to use these languages and platforms, which is exactly what the fundamentals prepare you for.</p>
 <p>This is why these companies choose to focus on this topic -- while in a regular company you can prove your ability by answering questions about a specific platform, in the larger companies' world of generalists it's your understanding of programming as a concept that proves you're the type of programmer they need.</p>
 <p>It sucks to be rejected from a dream company, <i>especially</i> when their process is stressful and difficult, but you must understand what you're getting yourself into -- top-tier companies that have amazing salaries, benefits, free food, off-sites and all have <b>thousands</b> of people applying for the same role. What makes you think you're so good that these companies should drop thousands of candidates and hire you with no questions asked? Are you really sure you have absolutely <b>no room</b> for improvement as a programmer?</p>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>I can't help but point out that when people express discontent with interviews they almost always do so from an emotional point of view, almost like a coping mechanism where they blame the company to hide the possibility that there is something that they could improve. I certainly am one to know how that feels -- I got rejected from many companies before landing my current job, and I definitely blamed them too at first when it happened. However, you can't let this overwhelm you because this is simply how the game works -- <i>of course</i> their process is going to be extremely difficult and specific, just look at how many people you're competing with!</p>
 <p>If your goal is to work for one of these companies, I think it's really important for you to ground yourself emotionally and consider that there might be many areas you'll need to study to be able to compete for a role. Although this is daunting, it can also be beneficial to you -- considering this possibility will give you a better vision of where you want to go in your career, which could very well be that these companies don't actually suit the roles you want to have. If they do suit it, then consider how important these areas are for them and how they could also benefit you. You're capable, but are you the <i>type</i> of capable they're looking for? They're asking for something that you might not know. What are you willing to do to reach your goals?</p>
</div>]]></description>
</item>
<item>
    <title>Thread Safety in Swift</title>
    <link>https://swiftrocks.com/thread-safety-in-swift</link>
    <guid>https://swiftrocks.com/thread-safety-in-swift</guid>
    <pubDate>Tue, 11 May 2021 09:00:00 GMT-3</pubDate>
<description><![CDATA[
 
  
  <!--WRITEIT_POST_NAME=Thread Safety in Swift--> 
  <!--WRITEIT_POST_HTML_NAME=thread-safety-in-swift--> 
  <!--Add here the additional properties that you want each page to possess.--> 
  <!--These properties can be used to change content in the template page or in the page itself as shown here.--> 
  <!--Properties must start with 'WRITEIT_POST'.--> 
  <!--Writeit provides and injects WRITEIT_POST_NAME and WRITEIT_POST_HTML_NAME by default.--> 
  <!--WRITEIT_POST_SHORT_DESCRIPTION=Concurrency is the entry point for the most complicated and bizarre bugs a programmer will ever experience. In this article, I'll share my favorite methods of ensuring thread-safety, as well as analyzing the performance of the different mechanisms.--> 
  <!--DateFormat example: 2020-04-12T14:00:00+02:00--> 
  <!--WRITEIT_POST_SITEMAP_DATE_LAST_MOD=2021-05-11T14:00:00+02:00--> 
  <!--WRITEIT_POST_SITEMAP_DATE=2021-05-11T14:00:00+02:00--> 
  <title>Thread Safety in Swift</title>  
 

<div class="blog-post"> 
 <div class="post-title-index">  
  <h1>Thread Safety in Swift</h1>
 </div> 
 <div class="post-info"> 
  <div class="category category-swift">
   Swift
  </div> 
  <div class="post-info-text">
   Published on 11 May 2021 
  </div> 
 </div>  
 <div class="post-image"> 
  <img src="https://i.imgur.com/2PDjXPQ.png" alt="Lock times"> 
 </div> 
 <p>Concurrency is the entry point for the most complicated and bizarre bugs a programmer will ever experience. Because we at the application level have no real control over the threads and the hardware, there's no real way of creating unit tests that guarantee your systems behave correctly when used by multiple threads at the same time. In this article, I'll share my favorite methods of ensuring thread safety, as well as analyzing the performance of the different mechanisms.</p>
 <h2>What is Thread Safety?</h2>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>I personally define thread safety as a class's ability to ensure "correctness" when multiple threads attempt to use it at the same time. If different threads accessing some piece of shared state at very specific moments at the same time cannot result in your class ending up in an unexpected/broken state, then your code is thread-safe. If that's not the case, you can use the OS's synchronization APIs to orchestrate <i>when</i> the threads can access that information, making so your class's shared state is always correct and predictable.</p>
 <h2>Thread Safety costs</h2>
 <p>Before going further, it's good to be aware that any form of synchronization comes with a performance hit, and this hit can sometimes be quite noticeable. On the other hand, I'd argue that this trade-off is always worth it. The worst issues I had to debug were always related to code that is not thread-safe, and because we cannot unit-test for it, you never know what kind of bizarre situation you'll get.</p>
 <p>For that reason, my main tip for you is to stay away from any form of state that can be accessed in parallel in exchange for having a nice and simple atomic serial queue of events. If you truly need to create something that can be used in parallel, then I suggest you put extra effort into understanding all possible usage scenarios. Try to describe every possible bizarre thread scenario that you would need to orchestrate, and what should happen in each of them. If you find this task to be too complicated, then it's possible that your system is too complex to be used in parallel, and having it run serially would save you a lot of trouble.</p>
 <h2>Goal: A thread-safe queue of events</h2>
 <p>Before using our tools, we'll define the objective of creating a <i>thread-safe event queue</i>. We would like to define a class that can process a queue of "events", with each event being processed serially one after the other. If multiple threads try to run events at the same time, the one that came later will <b>wait</b> for the previous one to finish before being executed.</p>
 <p>If a class exclusively uses this event queue to manage its state, then it'll be impossible for different threads to access the state at the same time, making the state always predictable and correct. Thus, that class can be considered <b>thread-safe</b>.</p>
 <pre>
<code>final class EventQueue {</code>
<code>    func synchronize(action: () -&gt; Void) {</code>
<code>        // Missing: thread orchestration!</code>
<code>        action()</code>
<code>    }</code>
<code>}</code>
</pre>
 <h2>Serial DispatchQueues</h2>
 <p>If our intention is to have the events be processed <b>asynchronously</b> in a different thread, then a serial <code>DispatchQueue</code> is a great choice.</p>
 <pre>
<code>let queue = DispatchQueue(label: "my-queue", qos: .userInteractive)</code>
<code></code>
<code>func synchronize(action: @escaping () -&gt; Void) {</code>
<code>    queue.async {</code>
<code>        action()</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>The greatest thing about <code>DispatchQueue</code> is how it completely manages any threading-related task like locking and prioritization for you. Apple advises you to never create your own <code>Thread</code> types for resource management reasons -- threads are not cheap, and they must be prioritized between each other. <code>DispatchQueues</code> handle all of that for you, and in the case of a serial queue, the state of the queue itself and the execution order of the tasks will also be managed for you, making it perfect as a thread safety tool.</p>
 <p>However, we don't want our <code>EventQueue</code> class to be asynchronous. In our case, we'd like the thread that registered the event to actually <b>wait</b> until it got executed.</p>
 <p>In that case, a <code>DispatchQueue</code> will not be the best choice. Not only running code synchronously means that we have no use for its threading features, resulting in wasted precious resources, but the <code>DispatchQueue.sync</code> synchronous variant is also a relatively dangerous API as it cannot deal with the fact that you might <b>already</b> be inside the queue:</p>
 <pre>
<code>func synchronize(action: @escaping () -&gt; Void) {</code>
<code>    queue.sync {</code>
<code>        action()</code>
<code>    }</code>
<code>}</code>
<code></code>
<code>func logEntered() {</code>
<code>    synchronize {</code>
<code>        print("Entered!")</code>
<code>    }</code>
<code>}</code>
<code></code>
<code>func logExited() {</code>
<code>    synchronize {</code>
<code>        print("Exited!")</code>
<code>    }</code>
<code>}</code>
<code></code>
<code>func logLifecycle() {</code>
<code>    synchronize {</code>
<code>        logEntered()</code>
<code>        print("Running!")</code>
<code>        logExited()</code>
<code>    }</code>
<code>}</code>
<code></code>
<code>logLifecycle() // Crash!</code>
</pre>
 <p>Recursively attempting to enter the serial <code>DispatchQueue</code> will result in two threads simultaneously waiting on each other, making the app freeze forever. This is the classic <b>deadlock</b>.</p>
 <p>There are ways to fix this, including using the <code>DispatchQueue.getSpecific</code> API I mentioned here at SwiftRocks some time ago, but a <code>DispatchQueue</code> is still not the best tool for this case. For synchronous execution, we can have better performance by using an old-fashioned mutex.</p>
 <h2>os_unfair_lock</h2>
 <p><b>Note: @tclementdev has kindly shared with me that's not a good idea to use this lock in Swift because the ampersand in Swift actually copies the lock instead of referencing it, and this can cause an infinite number of problems. I'll keep this section because I think it's interesting knowledge, but I'll spoil a bit and say that this is not the solution to the problem and you should probably not use it.</b></p>
 <p>The <code>os_unfair_lock</code> mutex (mutual exclusion) lock is currently the fastest lock in iOS. If your intention is to simply prevent two threads from accessing some piece of code at the same time (called a <i>critical section</i>) like in our <code>EventQueue</code> example, then this lock will get the job done with great performance.</p>
 <pre>
<code>var lock = os_unfair_lock_s()</code>
<code></code>
<code>func synchronize(action: () -&gt; Void) {</code>
<code>    os_unfair_lock_lock(&amp;lock)</code>
<code>    action()</code>
<code>    os_unfair_lock_unlock(&amp;lock)</code>
<code>}</code>
</pre>
 <div class="post-image"> 
  <img src="https://i.imgur.com/VR72J4H.png" alt="Alt"> 
 </div>
 <p>It's not a surprise that it's faster than a <code>DispatchQueue</code> -- despite being low-level C code, the fact that we are not dispatching the code to a different thread saves us a lot of time.</p>
 <p>A downside of this lock is that it's really nothing more than this. Although the API contains does contain some additional utilities like <code>os_unfair_lock_trylock</code> and <code>os_unfair_lock_assert_owner</code>, some of the other locks have additional features that I find very useful. But if you don't need more features, then this will solve your problem nicely.</p>
 <p>This lock is technically enough to implement our thread-safe serial queue of events, but it also cannot handle recursion. If we try to claim this lock recursively, we'll get a deadlock. As we'd like to have this ability, we will need to use bigger guns.</p>
 <h2>NSLock</h2>
 <p>Like <code>os_unfair_lock</code>, <code>NSLock</code> is also a mutex. Deep down the difference between the two is that <code>NSLock</code> is an Obj-C abstraction for another mutex called <code>pthread_mutex</code> lock, but <code>NSLock</code> contains an additional feature that I find really useful -- <b>timeouts</b>:</p>
 <pre>
<code>let nslock = NSLock()</code>
<code></code>
<code>func synchronize(action: () -&gt; Void) {</code>
<code>    if nslock.lock(before: Date().addingTimeInterval(5)) {</code>
<code>        action()</code>
<code>        nslock.unlock()</code>
<code>    } else {</code>
<code>        print("Took to long to lock, avoiding deadlock by ignoring the lock")</code>
<code>        action()</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>When you deadlock yourself with a <code>DispatchQueue</code> the class will detect it and immediately crash the app, but these lower-level locks will do nothing and leave you with a completely unresponsive app. Yikes!</p>
 <p>However, in the case of <code>NSLock</code>, I actually find this to be a good thing! Because it contains a timeout feature, you have the opportunity to implement a fallback and save yourself from a deadlock. In the case of our event queue, a fallback could be to simply ignore the lock -- removing the deadlock and restoring the app's healthy state. This scenario could also happen if the queue is running some really slow piece of code, allowing you to detect these cases so they can be improved.</p>
 <div class="post-image"> 
  <img src="https://i.imgur.com/CSNvtKc.png" alt="Alt"> 
 </div>
 <p>Despite being the same kind of lock as <code>os_unfair_lock</code>, you'll find <code>NSLock</code> to be slightly slower due to the additional cost of having to go through Obj-C's messaging system.</p>
 <p><code>NSLock</code> is great when we need a lock with more features, but it still cannot properly handle recursion. In this case, although the code <i>would</i> work, we would find ourselves waiting for the timeout every time. What we're looking for is the ability to <i>ignore</i> the lock when claiming it recursively, and for this, we'll need yet another special kind of lock.</p>
 <h2>NSRecursiveLock</h2>
 <p><code>NSRecursiveLock</code> is exactly like <code>NSLock</code>, but it can handle recursion. ...Not so impressive, right?</p>
 <p>Jokes aside, this is exactly what we are looking for! Regular looks will cause a deadlock when recursively attempting to claim the lock in the same thread, but a recursive lock allows the owner of the lock to repeatedly claim it. As you might know by now, this is intended to be used in scenarios where the critical section might call itself:</p>
 <pre>
<code>let recursiveLock = NSRecursiveLock()</code>
<code></code>
<code>func synchronize(action: () -&gt; Void) {</code>
<code>    recursiveLock.lock()</code>
<code>    action()</code>
<code>    recursiveLock.unlock()</code>
<code>}</code>
<code></code>
<code>func logEntered() {</code>
<code>    synchronize {</code>
<code>        print("Entered!")</code>
<code>    }</code>
<code>}</code>
<code></code>
<code>func logExited() {</code>
<code>    synchronize {</code>
<code>        print("Exited!")</code>
<code>    }</code>
<code>}</code>
<code></code>
<code>func logLifecycle() {</code>
<code>    synchronize {</code>
<code>        logEntered()</code>
<code>        print("Running!")</code>
<code>        logExited()</code>
<code>    }</code>
<code>}</code>
<code></code>
<code>logLifecycle() // No crash!</code>
</pre>
 <p>If the thread entering the critical section <b>already</b> owns the lock, then we can safely enter the critical section again. The only requirement is that multiple lock calls need to be followed by multiple unlock calls, and due to the additional thread checks, recursive locks are slightly slower than the normal <code>NSLock</code>.</p>
 <div class="post-image"> 
  <img src="https://i.imgur.com/2PDjXPQ.png" alt="Alt"> 
 </div>
 <h2>DispatchSemaphore</h2>
 <p>Semaphores don't fit our problem scenario, but I thought it would be interesting to mention them as well. In short, a semaphore is a lock that you use when the locking and unlocking need to happen in different threads:</p>
 <pre>
<code>let semaphore = DispatchSemaphore(value: 0)</code>
<code></code>
<code>mySlowAsynchronousTask {</code>
<code>    semaphore.signal()</code>
<code>}</code>
<code></code>
<code>semaphore.wait()</code>
<code>print("Task done!")</code>
</pre>
 <p>Like in this example, semaphores are commonly used to lock a thread until a different event in another thread has finished. The most common example of a semaphore in iOS is <code>DispatchQueue.sync</code> itself -- we have some code running in another thread, but we want to wait for it to finish before continuing our thread. The example here is exactly what <code>DispatchQueue.sync</code> does, except we're building the semaphore ourselves.</p>
 <p><code>DispatchSemaphore</code> is quick, and contains the same features that <code>NSLock</code> has.</p>
 <h2>DispatchGroup</h2>
 <p>A <code>DispatchGroup</code> is exactly like a <code>DispatchSemaphore</code>, but for <b>groups</b> of tasks. While a semaphore waits for one event, a group can wait for an infinite number of events:</p>
 <pre>
<code>let group = DispatchGroup()</code>
<code></code>
<code>for _ in 0..&lt;6 {</code>
<code>    group.enter()</code>
<code>    mySlowAsynchronousTask {</code>
<code>        group.leave()</code>
<code>    }</code>
<code>}</code>
<code></code>
<code>group.wait()</code>
<code>print("ALL tasks done!")</code>
</pre>
 <p>In this case, the thread will only be unlocked when <b>all</b> 6 tasks have finished.</p>
 <p>One really neat feature of <code>DispatchGroups</code> is that you have the ability to wait <b>asynchronously</b> by calling <code>group.notify</code>:</p>
 <pre>
<code>group.notify(queue: .main) {</code>
<code>    print("ALL tasks done!")</code>
<code>}</code>
</pre>
 <p>This lets you be notified of the result in a <code>DispatchQueue</code> instead of blocking the thread, which can be extremely useful if you don't need the result synchronously.</p>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>Because of the group mechanism, you'll find groups to be usually slower than plain semaphores:</p>
 <div class="post-image"> 
  <img src="https://i.imgur.com/V1S7N2y.png" alt="Alt"> 
 </div>
 <p>In general this means you should always use <code>DispatchSemaphore</code> if you're only waiting for a single event, but unfortunately <code>DispatchSemaphore</code> doesn't have the <code>notify</code> API and lots of people end up using <code>DispatchGroup</code> also for individual events for this reason.</p>
</div>]]></description>
</item>
<item>
    <title>Adding Intelligent Code Generation to Swift Projects with SourceKit</title>
    <link>https://swiftrocks.com/code-generation-with-sourcekit</link>
    <guid>https://swiftrocks.com/code-generation-with-sourcekit</guid>
    <pubDate>Mon, 12 Apr 2021 09:00:00 GMT-3</pubDate>
<description><![CDATA[
<!--WRITEIT_POST_NAME=Adding Intelligent Code Generation to Swift Projects with SourceKit-->
<!--WRITEIT_POST_HTML_NAME=code-generation-with-sourcekit-->

<!--Add here the additional properties that you want each page to possess.-->
<!--These properties can be used to change content in the template page or in the page itself as shown here.-->
<!--Properties must start with 'WRITEIT_POST'.-->
<!--Writeit provides and injects WRITEIT_POST_NAME and WRITEIT_POST_HTML_NAME by default.-->

<!--WRITEIT_POST_SHORT_DESCRIPTION=I've been playing with intelligent code generation for a couple of years now, and I'd like to show you how to achieve this with SourceKit.-->

<!--DateFormat example: 2021-04-12T14:00:00+02:00-->
<!--WRITEIT_POST_SITEMAP_DATE_LAST_MOD=2021-04-12T14:00:00+02:00-->
<!--WRITEIT_POST_SITEMAP_DATE=2021-04-12T14:00:00+02:00-->

<title>Adding Intelligent Code Generation to Swift Projects with SourceKit</title>
<div class="blog-post">
  <div class="post-title-index">
    <h1>Adding Intelligent Code Generation to Swift Projects with SourceKit</h1>
  </div>  
  <div class="post-info">
    <div class="category category-compiler">iOS</div>
    <div class="category category-swift">Swift</div>
    <div class="post-info-text">Published on 10 Aug 2021</div>
  </div>
<p><a href="https://www.youtube.com/watch?v=sZuI6z8qSmc">I gave a talk about scalable iOS apps at SwiftHeroes 2021</a> in which I speak about an app's four "levels" of complexity, ending by stating that we still don't know what the "fifth level" would be.</p>
<p>I do have one guess though: I believe a "level five" iOS app will be an app that contains so many modules and architectural components that any small addition will require writing massive amounts of boilerplate code. In an app like this, the jump from level four to level five would be defined by the app's ability to generate most of its boilerplate and requirements.</p>
<div class="sponsor-article-ad-auto hidden"></div>
<p>Note that I'm not talking about code generation in the sense of tools like Sourcery where you define templates for common actions, push an input and get an output -- I'm talking about generating code for things you <b>don't even know what the inputs are.</b> Yes, that's possible! I've been playing with "intelligent code generation" for a couple of years now, and I'd like to show you how to achieve this with <b>SourceKit</b>.</p>
<h2>Example: Generating a dependency injection library's dependency list</h2>
<p>For this article, I'd like to use <a href="https://github.com/rockbruno/RouterService">RouterService</a> as an example. This is a type-safe dependency injection library in which your app is defined as a series of "features" that can depend on each other, creating a dependency graph that is then fed into a main <code>RouterService</code> object that does all the magic:</p>
<pre>
<code>struct ProfileFeature: Feature {</code>
<code></code>
<code>    @Dependency var client: HTTPClientProtocol</code>
<code></code>
<code>    func build(fromRoute route: Route?) -> UIViewController {</code>
<code>        return ProfileViewController(client: client)</code>
<code>    }</code>
<code>}</code>
</pre>
<p>There's one thing that is slightly annoying about it though -- because type-safety is an important aspect of the library, you need to manually inform <code>RouterService</code> of all available features in your app:</p>
<pre>
<code>routerService.register(feature: ProfileFeature.self)</code>
<code>routerService.register(feature: SomeOtherFeature.self)</code>
</pre>
<p>(The actual registration is a bit different from this, but I simplified it too avoid skewing the subject too much.)</p>
<p>This means that every time a new feature is added, the pull request must also contain a change to the file where these registrations are being made. If you forget to do that, the library will crash when attempting to reference that feature.</p>
<p>We can improve this by automating this step with code generation. If you're maintaining a list of features somewhere in a file you <i>could</i> use Sourcery to generate this boilerplate, but what I'd like to show you is <b>how to generate this code without having any prior information on the app's feature list.</b> No special yaml files, no special calls, just run a tool and get this code generated.</p>
<h2>Introducing SourceKit</h2>
<p><b>SourceKit</b> is Swift's syntax highlighting engine. Well, I suppose technically the engine is Swift itself, but SourceKit is how Xcode is able to implement all of its Swift IDE features like formatting, jumping to specific symbols, and of course, the syntax highlighting itself. Part of the Swift umbrella of tools, SourceKit is a C library that abstracts the Swift compiler, and it's shipped inside the Swift toolchain when you download Xcode. This means that you don't need to download a special binary to follow this tutorial -- if you have Xcode, you also have SourceKit.</p>
<p>Like Swift, SourceKit is open-source, and you can use it outside of Xcode to give any project the capabilities of a Swift IDE. SourceKit-powered projects were actually sort of common a couple of years ago, with the most notorious one being JP Simard's <a href="https://github.com/jpsim/SourceKitten">SourceKitten</a> framework which allowed you to use SourceKit directly in Swift. In fact, many popular code-related tools like SwiftLint, Jazzy and even Sourcery itself are still using SourceKitten under the hood. I haven't seen any more SourceKit-related projects being developed in recent times, but you can still use it to create intelligent projects.</p>
<p>SourceKit works through a request/response format. The tool can receive many types of IDE-related requests like opening files, indexing content, auto-completion, looking up the definition of a symbol, formatting and so on, and by sending a structured request object you'll get a structured response with the result of what you're asking for.</p>
<p>You can actually see SourceKit in action by launching Xcode with SourceKit logging enabled:</p>
<pre>
<code>export SOURCEKIT_LOGGING=3 && /Applications/Xcode.app/Contents/MacOS/Xcode > log.txt</code>
</pre>
<p>With the <code>SOURCEKIT_LOGGING</code> flag, Xcode will start dumping every request done to SourceKit. Try doing some common actions like waiting for auto-complete and see how SourceKit makes it happen! The logs will contain a lot of noise, but if you want a pointer, search for calls to the <code>editor_open</code> request, which is the request done whenever you open a file:</p>
<pre>
<code>final class TestService {</code>
<code>    init() {}</code>
<code>}</code>
</pre>
<pre>
<code>{</code>
<code>  key.request: source.request.editor.open,</code>
<code>  key.name: "/myFolder/myFile.swift",</code>
<code>  key.sourcefile: "/myFolder/myFile.swift"</code>
<code>}</code>
</pre>
<pre>
<code>{</code>
<code>  key.substructure: [</code>
<code>    {</code>
<code>      key.kind: source.lang.swift.decl.class,</code>
<code>      key.accessibility: source.lang.swift.accessibility.internal,</code>
<code>      key.name: "TestService",</code>
<code>      key.offset: 6,</code>
<code>      key.length: 35,</code>
<code>      key.nameoffset: 12,</code>
<code>      key.namelength: 11,</code>
<code>      key.bodyoffset: 25,</code>
<code>      key.bodylength: 15,</code>
<code>      key.attributes: [</code>
<code>        {</code>
<code>          key.offset: 0,</code>
<code>          key.length: 5,</code>
<code>          key.attribute: source.decl.attribute.final</code>
<code>        }</code>
<code>      ],</code>
<code>      key.substructure: [</code>
<code>        {</code>
<code>          key.kind: source.lang.swift.decl.function.method.instance,</code>
<code>          key.accessibility: source.lang.swift.accessibility.internal,</code>
<code>          key.name: "init()",</code>
<code>          key.offset: 30,</code>
<code>          key.length: 9,</code>
<code>          key.nameoffset: 30,</code>
<code>          key.namelength: 6,</code>
<code>          key.bodyoffset: 38,</code>
<code>          key.bodylength: 0</code>
<code>        }</code>
<code>      ]</code>
<code>    }</code>
<code>  ]</code>
<code>}</code>
</pre>
<p>As you can see, the response to this request contains the tokenized structure of a Swift file. With it, we can determine that this file is declaring <code>TestPrivate</code>, that <code>TestPrivate</code> is a <code>final private class</code>, that <code>final class</code> are builtin Swift keywords, <i>where</i> they were defined, the length of each code block and so on. That's what Xcode uses to give keywords a special color before your file is properly indexed, and that's the most basic request it has!</p>
<p>In short, we can use this tokenized structure to automatically generate a feature's declaration code. If we know that a file contains the declaration of a feature, we can extract its name and automatically generate its setup boilerplate.</p>
<h2>Creating a project with SourceKit</h2>
<p>SourceKit is easy to use, but a bit annoying to configure. This is because we're dealing with a C library, so some setup needs to be done in your Xcode project before you can actually use it. I suppose that for simple endeavors you can use <a href="https://github.com/jpsim/SourceKitten">SourceKitten</a>, but I'll teach you how to manually use SourceKit so you have access to its full capabilities.</p>
<p>To start, download <a href="https://github.com/rockbruno/SourceKitSampleProject">this sample SourceKit-powered Swift Package Manager project</a> that contains everything you need to get started.</p>
<p>The project contains two targets: <code>Csourcekitd</code> and <code>MyProject</code>, which is where the project itself resides. The reason we need to define a target for SourceKit is that although we have access to SourceKit in the toolchain, we don't know <i>how</i> to call it. This target has a header file that contains all functions supported by SourceKit, alongside the minimum setup necessary to abstract a C library into a Swift module.</p>
<p>Additionally, <code>MyProject</code> contains Swift abstractions that can handle initializing and using SourceKit. It defines for example the data structures that you need to pass, the constants for every relevant string in SourceKit (requests, keys and values), and small utilities on handling these types. If you're wondering where all of that comes from, all of these files come from Swift itself! The abstractions specifically were snatched from <a href="https://github.com/apple/sourcekit-lsp">SourceKit-LSP</a>, which is a Swift abstraction of SourceKit for IDEs that support the Language Server Protocols. Before continuing, I recommend you to take a quick glimpse at the contents of the files in the sample project so you can get familiarized with why they're there.</p>
<h2>Extracting features and generating the boilerplate</h2>
<p>If we assume that the purpose of this tool is to read the sources of a project, find <code>Feature</code> definitions and dump the generated code somewhere, we could define something like this:</p>
<pre>
<code>let sourceKit = SourceKit()</code>
<code>let keys = sourceKit.keys!</code>
<code>let requests = sourceKit.requests!</code>
<code>let values = sourceKit.values!</code>
<code></code>
<code>func process(files: [String]) {</code>
<code>    var features = [String]()</code>
<code>    for file in files {</code>
<code>        features.append(contentsOf: findFeatures(inFile: file))</code>
<code>    }</code>
<code>    process(result: features)</code>
<code>}</code>
<code></code>
<code>func findFeatures(inFile file: String) -> [String] {</code>
<code>    return []</code>
<code>}</code>
</code>
<code>func process(result: [String]) {</code>
<code></code>
<code>}</code>
<code></code>
<code>process(files: []) // Add here the list of file paths you'd like to process</code>
</pre>
<p>(I'm assuming you know how to provide the <code>files</code> array, but if you don't, you could search for .swift files with <code>FileManager</code> or receive an input directly with <b>swift-argument-parser</b>. For this tutorial, you could also simply hardcode a file path string.)</p>
<p>In short, the intention of this code is to iterate a files array, search for <code>Feature</code> declarations in each of them and report this result back to another method.</p>
<p>To implement <code>findFeature(inFile:)</code>, let's start by defining a <code>editor_open</code> request to SourceKit:</p>
<pre>
<code>func findFeature(inFile: String) -> [String] {</code>
<code>    let req = SKRequestDictionary(sourcekitd: sourceKit)</code>
<code></code>
<code>    req[keys.request] = requests.editor_open</code>
<code>    req[keys.name] = servicePath</code>
<code>    req[keys.sourcefile] = servicePath</code>
<code></code>
<code>    print(req)</code>
<code>    let response = sourceKit.sendSync(req)</code>
<code>    print(req)</code>
<code></code>
<code>    return []</code>
<code>}</code>
</pre>
<p>Both the request and response objects are <code>CustomStringConvertible</code>, so printing them will show you all their details. If you run this for a given file, you'll see an output similar to the one I showed above. If you're wondering how I know which arguments to pass to the request, it's because I looked at how Xcode is calling it using the tips mentioned above. Unfortunately, I don't think there's any actual documentation for these requests besides checking the Xcode logs, but if you try to perform a request with something missing, SourceKit will tell you.</p>
<p>In short, what we need to do is traverse the tokens of a file and determine if it contains one or more <code>enums</code> that inherit from the <code>Feature</code> protocol. To figure out how to do that, it helps to feed SourceKit a file that matches our needs and see what SourceKit responds with:</p>
<pre>
<code>enum MyFeature: Feature {}</code>
</pre>
<pre>
<code>{</code>
<code>  key.substructure: [</code>
<code>    {</code>
<code>      key.kind: source.lang.swift.decl.enum,</code>
<code>      key.accessibility: source.lang.swift.accessibility.internal,</code>
<code>      key.name: "MyFeature",</code>
<code>      key.offset: 0,</code>
<code>      key.length: 26,</code>
<code>      key.nameoffset: 5,</code>
<code>      key.namelength: 9,</code>
<code>      key.bodyoffset: 25,</code>
<code>      key.bodylength: 0,</code>
<code>      key.inheritedtypes: [</code>
<code>        {</code>
<code>          key.name: "Feature"</code>
<code>        }</code>
<code>      ],</code>
<code>      key.elements: [</code>
<code>        {</code>
<code>          key.kind: source.lang.swift.structure.elem.typeref,</code>
<code>          key.offset: 16,</code>
<code>          key.length: 7</code>
<code>        }</code>
<code>      ]</code>
<code>    }</code>
<code>  ]</code>
<code>}</code>
</pre>
<p>From this response, we can determine that we need to:</p>
<ul>
<li>Iterate <code>key.substructure</code> (recursively, because the declaration could be deeper down the structure)</li>
<li>Check if <code>kind</code> is <code>source.lang.swift.decl.enum</code></li>
<li>Check if <code>inheritedtypes</code> contains <code>Feature</code></li>
<li>If yes, record the name of the feature.</li>
</ul>
<p>Luckily for us, the Swift abstraction of SourceKit has some methods that can help us with the above. This is how we can iterate <code>key.substructure</code> and check if the element represents the declaration of an enum:</p>
<pre>
<code>var features = [String]()</code>
<code>response.recurse(uid: keys.substructure) { dict in</code>
<code>    let kind: SKUID? = dict[keys.kind]</code>
<code>    guard kind?.uid == values.decl_enum else {</code>
<code>        return</code>
<code>    }</code>
<code>}</code>
</pre>
<p>With that out of the picture, we can check <code>inheritedtypes</code> by reading its value as a <code>SKResponseArray</code>:</p>
<pre>
<code>guard let inheritedtypes: SKResponseArray = dict[keys.inheritedtypes] else {</code>
<code>    return</code>
<code>}</code>
<code>for inheritance in (0..&lt;inheritedtypes.count).map({ inheritedtypes.get($0) }) {</code>
<code></code>
<code>}</code>
</pre>
<p>And from each element in the array, we can check if its name is <code>Feature</code> and add it to our response array if true. This is how the full code looks like:</p>
<pre>
<code>func findFeatures(inFile file: String) -> [String] {</code>
<code>    let req = SKRequestDictionary(sourcekitd: sourceKit)</code>
<code></code>
<code>    req[keys.request] = requests.editor_open</code>
<code>    req[keys.name] = file</code>
<code>    req[keys.sourcefile] = file</code>
<code></code>
<code>    let response = try! sourceKit.sendSync(req)</code>
<code></code>
<code>    var features = [String]()</code>
<code>    response.recurse(uid: keys.substructure) { dict in</code>
<code>        let kind: SKUID? = dict[keys.kind]</code>
<code>        guard kind?.uid == values.decl_enum else {</code>
<code>            return</code>
<code>        }</code>
<code>        guard let inheritedtypes: SKResponseArray = dict[keys.inheritedtypes] else {</code>
<code>            return</code>
<code>        }</code>
<code>        for inheritance in (0..&lt;inheritedtypes.count).map({ inheritedtypes.get($0) }) {</code>
<code>            if let name: String = inheritance[keys.name], name == "Feature" {</code>
<code>                features.append(name)</code>
<code>            }</code>
<code>        }</code>
<code>    }</code>
<code></code>
<code>    return features</code>
<code>}</code>
</pre>
<p>From here you could probably export this result and use Sourcery to generate the actual code, but since we already created a project for this I think it's easier to just generate the code yourself:</p>
<pre>
<code>func process(result: [String]) {</code>
<code>    let declaration = result.map {</code>
<code>        "    routerService.register(feature: \($0).self"</code>
<code>    }.joined(separator: "\n")</code>
<code>    let result = """</code>
<code>    func registerFeatures(_ routerService: RouterService) {</code>
<code>    \(declaration)</code>
<code>    }</code>
<code>    """</code>
<code></code>
<code>    print(result)</code>
<code>    // Save this result to a file</code>
<code>}</code>
</pre>
<p>In this example, we're generating a <code>registerFeatures</code> method that contains all the registration code inside of it. We could replace our current code with a call to this method, and setup a script that would run this tool every time a new service is added.</p>
<h2>What about more complicated cases?</h2>
<p>One thing you might've noticed is that this code doesn't take the module of the file into consideration, so this wouldn't work for apps with multiple modules, and we're also not doing any sort of caching. These however are problems that you can solve without using SourceKit directly, so we won't go into their details here. It should show to you however how this is a difficult thing to do properly and is why this should probably only be a concern of apps in a very advanced state.</p>
<p>In regards to the more advanced uses of SourceKit itself, one of my favorite requests is the <code>index_source</code> request which provides you the "indexed" version of your file. This is similar to the <code>editor_open</code> request, but instead of simply printing you the names of the tokens, it shows you the <b>symbol</b> of each reference. For example, if you're looking at a type reference like <code>let type: MyType</code>, SourceKit will tell you which module <code>MyType</code> belongs to, the name of the file in which it's defined, the specific line/column where the type is declared, and much more. This is what powers the "jump to definition" feature of Xcode, and is why the color of your files changes after a while -- Xcode has finished indexing it, and it now knows where each reference is coming from.</p>
<div class="sponsor-article-ad-auto hidden"></div>
<p>Unfortunately, these more advanced requests are also more difficult to use because their requests require you to pass your app's full list of compiler arguments. This would be easy if Xcode allowed you to export that information, but it doesn't, so you will have to mess with <code>xcodebuild</code> to figure out what these arguments are. If you want to see an example of a tool that actually went to the trouble of doing that, check out <a href="https://github.com/rockbruno/swiftshield">swiftshield</a>. This is a tool that obfuscates Swift files, and it's completely based on SourceKit's <code>index_sources</code> request. I also think that looking at <a href="https://github.com/apple/sourcekit-lsp">sourcekit-lsp</a> is a good idea, as it contains implementations of many different SourceKit requests that you can take inspiration from.</p>
</div>
]]></description>
</item>
<item>
    <title>Creating a licensing system for paid apps in Swift</title>
    <link>https://swiftrocks.com/creating-a-license-system-for-paid-apps-in-swift</link>
    <guid>https://swiftrocks.com/creating-a-license-system-for-paid-apps-in-swift</guid>
    <pubDate>Tue, 6 Apr 2021 09:00:00 GMT-3</pubDate>
<description><![CDATA[
 
  
  <!--WRITEIT_POST_NAME=Creating a licensing system for paid apps in Swift--> 
  <!--WRITEIT_POST_HTML_NAME=creating-a-license-system-for-paid-apps-in-swift--> 
  <!--Add here the additional properties that you want each page to possess.--> 
  <!--These properties can be used to change content in the template page or in the page itself as shown here.--> 
  <!--Properties must start with 'WRITEIT_POST'.--> 
  <!--Writeit provides and injects WRITEIT_POST_NAME and WRITEIT_POST_HTML_NAME by default.--> 
  <!--WRITEIT_POST_SHORT_DESCRIPTION=The easiest way is to create a paid macOS app is to simply put a price tag in the App Store, but it's a common practice nowadays to provide a free download that can later be upgraded to a pro version. In this article, we'll use our knowledge of serial numbers and asymmetric cryptography to create license files that cannot be reverse-engineered and use them to activate an app's premium features.--> 
  <!--DateFormat example: 2020-04-12T14:00:00+02:00--> 
  <!--WRITEIT_POST_SITEMAP_DATE_LAST_MOD=2021-04-06T14:00:00+02:00--> 
  <!--WRITEIT_POST_SITEMAP_DATE=2021-04-06T14:00:00+02:00--> 
  <title>Creating a licensing system for paid apps in Swift</title>  
 

<div class="blog-post"> 
 <div class="post-title-index">  
  <h1>Creating a licensing system for paid apps in Swift</h1>
 </div> 
 <div class="post-info"> 
  <div class="category category-swift">
   Swift
  </div> 
  <div class="category category-ios">
   iOS
  </div> 
  <div class="post-info-text">
   Published on 06 Apr 2021 
  </div> 
 </div>  
 <div class="post-image"> 
  <img src="https://i.imgur.com/f2r6hL5.png" alt="License View"> 
 </div> 
 <p>The easiest way is to create a paid macOS app is to simply put a price tag in the App Store, but it's a common practice nowadays to provide a free download that can later be upgraded to a pro version. In this article, we'll use our knowledge of serial numbers and asymmetric cryptography to create license files that cannot be reverse-engineered and use them to activate an app's premium features.</p>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>The safest way to include a "pro" version in your app is to have a backend that is capable of providing content to premium users, but not every app falls into this category. If what you're developing is an offline productivity tool, then you might not have a backend at all. The easiest alternative is this case is to add an in-app purchase for the pro version, but for macOS apps, you might want to not use the App Store at all. In these cases, you'll have to ship your own licensing system that is capable of validating and upgrading an instance of the app.</p>
 <p>A simple way to achieve this is to provide serial numbers -- a system in which a user of the app can purchase one of these numbers and input it into the app to unlock its premium features. But how do you know the code is <b>legitimate</b>? Is it possible to confirm that the code was 100%, without a shadow of a doubt, provided by you, and not faked by someone who reverse-engineered the logic?</p>
 <h2>Serial numbers in the past</h2>
 <p>In the mid-2000s, serial numbers were a very common way to validate purchases, and every software/game you bought from a store would come with a serial number in the box which you had to input when installing it to prove that you were in possession of a legitimate copy of the software. However, serial numbers at the time were also very flawed. The validation logic was often some sort of hash function that was calculated on top of the serial number, and because this all happened offline, it wasn't very hard for a hacker to decompile the software and find out what this logic was. In fact, decompilers like Hopper nowadays are so good that they can even convert the decompiled assembly code into a pretty readable pseudo C code, making it pretty easy to figure out how an app works. Hackers would then use this logic to create <b>keygens</b> that could produce <i>fake</i> serial numbers that these apps would naively accept as being legitimate. If you ever pirated anything from the time, you definitely used one of these!</p>
 <p>Fortunately, with modern cryptography, the serial number system has been since replaced by a much more secure system that is practically impossible to break. Let's see how it works and how to implement one in Swift.</p>
 <h2>Creating an unbreakable(*) licensing system</h2>
 <p><i>* (Note: When I say unbreakable, I mean that it's impossible for someone to create fake licenses without modifying the app itself. If the validation process is placed in the client and a hacker decompiles your binary, they can simply disable the validation process and distribute a cracked version of your app. If you want to be truly unhackable, you should only serve content from a backend.)</i></p>
 <p>As we've seen above, the biggest flaw in serial number systems is that the validation logic could simply be reverse engineered and reproduced to generate fake keys that the apps would think are legit. This seems like a dead-end scenario because we absolutely can't prevent the app from being reverse engineered, but we actually <i>can</i> prevent the reverse-engineered logic from being reproduced.</p>
 <p>You might think this doesn't make sense, because if they know how the app validates a key, then you surely have all the tools you need to create a fake one, right? If you thought that, you're actually correct. But the thing is not that it's <b>impossible</b> for someone to reproduce it, it's that it's <b>technically unfeasible</b>.</p>
 <p>The system we'll implement in this article is called a <b>digital signature</b>, and it works around asymmetric encryption (private/public key). Digital signatures work by providing some arbitrary data (for example, the name of the person who purchased the license) and a serial number, which we'll now call a <b>signature</b>. This signature was created by encrypting that data with one of the keys, and by inputting both the data and the signature into the app, the app can validate it by decrypting the signature with the other key of the pair and checking that the resulting value is equal to the accompanying data.</p>
 <p>There's only one additional requirement we'll add to this system: Instead of encrypting the raw data, we'll instead encrypt a <i>hash</i> of it (which we'll call a <b>digest</b>). This is mainly for performance reasons since asymmetric encryption is meant to be used for small pieces of data, but also to prevent a security issue we'll see later on.</p>
 <pre>
<code>//--- How Digital Signatures Work ---</code>
<code></code>
<code>// Data: An arbitrary piece of data, like the user's name.</code>
<code></code>
<code>//--- Backend ---</code>
<code>// User purchases a license through a website</code>
<code></code>
<code>let digest = SHA512(userName)</code>
<code>let userSignature: String = encrypt(digest, withKey: privateKey)</code>
<code>return userSignature // Send the signature to the user</code>
<code></code>
<code>//--- App ---</code>
<code>// User will activate the app's premium features by validating a signature (the license)</code>
<code></code>
<code>let digest = SHA512(userName)</code>
<code>let result: String = decrypt(userSignature, withKey: publicKey)</code>
<code>if result == digest {</code>
<code>    print("Pro version unlocked!")</code>
<code>} else {</code>
<code>    print("Invalid license!")</code>
<code>}</code>
</pre>
 <p>If the validation succeeds, then the signature is absolutely legitimate. As you might know from asymmetric encryption, something encrypted by one key can <b>only</b> be decrypted by the other, so if you decrypt a value and it matches what you expected, then that value has 100% been generated by the other key of the pair.</p>
 <p>The security of digital signatures comes from the fact that you can make it impossible for a hacker to have access to both keys. The idea is that you can ship your app with one of the keys (the "public key") so you can validate signatures, but the generation of these signatures will happen privately and safely inside your backend when a user purchases a license. Because the key that generates the signatures (the "private key") is never exposed to the outside world, a hacker would never be able to intercept it, making the creation of fake licenses impossible unless they kidnap you or spend <a href="https://bitcoin.stackexchange.com/questions/2847/how-long-would-it-take-a-large-computer-to-crack-a-private-key">0.65 billion billion</a> years trying to brute-force all possible combinations.</p>
 <h2>Can we break digital signatures by reversing the process?</h2>
 <p>Let's use intuition to validate the safety of a digital signature. We know the following:</p>
 <pre>
<code>PrivateKey + Data = Signature</code>
<code>PublicKey + Signature = Data</code>
</pre>
 <p>A hacker can't intercept the private key, so they can't generate a valid signature for a certain piece of data. However, they can definitely extract the public key from your app's binary. What if they input something random as the signature and attempt to decrypt it with the key? What do you think the result will be?</p>
 <pre>
<code>PublicKey + MyRandomValue = X</code>
</pre>
 <p>The result, X, will be the arbitrary data value that would cause the private key to generate this signature!</p>
 <pre>
<code>PrivateKey + X = MyRandomValue</code>
<code>PublicKey + MyRandomValue = X</code>
</pre>
 <p>Thus, even though a hacker doesn't know what the private key is, they can still find the data that matches a given signature by reversing the process. This is precisely why we need to first hash the data with a strong algorithm like SHA-512 -- even though hackers can easily find the X that matches a particular signature, that X will simply be the digest of the original data. The app will not validate that signature unless they figure out what data generated that digest, and unless they can <a href="https://www.quora.com/How-long-would-it-take-to-crack-SHA-256">literally survive the end of the universe</a>, they probably won't.</p>
 <p>On a different note, the advancements being made to computers (especially quantum ones) are slowly making this possible, with researches suggesting that brute-forcing algorithms like SHA-256 might become feasible sometime around 2030. However, by that time, you'll have hopefully already have migrated to whatever the standards of 2030 for security would be.</p>
 <h2>Implementing digital signatures in Swift</h2>
 <p>Before implementing a validation system, let's first define what our license key/validation will look like. You can use anything as your license keys, as long as it contains the data that we'll use to create the digest and the resulting signature. In this case, let's pretend that we have a <code>myApp.license</code> file that is essentially a JSON:</p>
 <pre>
<code>{</code>
<code>    "name": "Bruno Rocha"</code>
<code>    "signature": "AUmrQ3cK+bZOjBPnrGV/3KWiTddu50zWvsas1tMlepc2zf="</code>
<code>}</code>
</pre>
 <p>In our app, we'll provide fields where the user can input this data.</p>
 <div class="post-image"> 
  <img src="https://i.imgur.com/f2r6hL5.png" alt="License View"> 
 </div>
 <h2>Generating Signatures</h2>
 <p>For this example, we'll assume that both the app and backend are written in Swift for simplicity.</p>
 <p>The first thing we need is a pair of encryption keys. It's possible to generate keys in Swift, but since the private key will be stored in the backend we'll use OpenSSL for simplicity. In this case, I want to generate a pair of 2048 bit RSA keys:</p>
 <pre>
<code>// Generate a 2048 bit RSA private key</code>
<code>openssl genrsa -out my_private_key.pem 2048</code>
<code>// Extract public key out of it</code>
<code>openssl rsa -in my_private_key.pem -outform PEM -pubout -out my_public_key.pem</code>
</pre>
 <p>If you open these files with a text editor, you'll be able to extract the base64 representation of the keys that we'll need for the rest of this tutorial.</p>
 <p>Let's now assume that we want to generate a license file for someone who just bought a pro version of our app. We'll use the name of the user to create our digest and encrypt it to create the signature. Luckily for us, the <b>Security</b> framework has tons of built-in APIs and algorithms for digital signatures.</p>
 <p>Let's start by creating an instance of our private key. <b>Remember, this is supposed to be some backend code that nobody has access to. Do not reference your private key in the actual app!</b> It's perfectly fine to ship your public key as a hardcoded string in your app, but <b>never</b> expose your private key to the outside world. If you suspect your private key has leaked, invalidate the current public key, generate a brand new pair of keys and restart the process.</p>
 <pre>
<code>import Security</code>
<code></code>
<code>func getPrivateKey(_ base64PrivateKeyString: String) throws -&gt; SecKey {</code>
<code>    let data = Data(base64Encoded: base64PrivateKeyString, options: [])!</code>
<code></code>
<code>    let options: [String: Any] = [kSecAttrKeyType as String: kSecAttrKeyTypeRSA,</code>
<code>                                  kSecAttrKeyClass as String: kSecAttrKeyClassPrivate,</code>
<code>                                  kSecAttrKeySizeInBits as String: 2048]</code>
<code></code>
<code>    var error: Unmanaged&lt;CFError&gt;?</code>
<code>    guard let privateKey = SecKeyCreateWithData(</code>
<code>        data as CFData,</code>
<code>        options as CFDictionary,</code>
<code>        &amp;error</code>
<code>    ) else {</code>
<code>        throw error!.takeRetainedValue() as Error</code>
<code>    }</code>
<code>    return privateKey</code>
<code>}</code>
</pre>
 <p>To create a signature, we can call Security's<code>SecKeyCreateSignature</code> method:</p>
 <pre>
<code>func sign(userName: String, withKey privateKey: SecKey) throws -&gt; String {</code>
<code>    let data = userName.data(using: .utf8)!</code>
<code>    var error: Unmanaged&lt;CFError&gt;?</code>
<code>    guard let signature = SecKeyCreateSignature(</code>
<code>            privateKey,</code>
<code>            .rsaSignatureMessagePKCS1v15SHA512,</code>
<code>            data as CFData,</code>
<code>            &amp;error</code>
<code>    ) as Data? else {</code>
<code>        throw error!.takeRetainedValue() as Error</code>
<code>    }</code>
<code>    return signature.base64EncodedString()</code>
<code>}</code>
</pre>
 <p>This method takes an algorithm, and you might notice that there are several options. They simply represent different encryption methods, and in this case we'll want to select <code>.rsaSignatureMessagePKCS1v15SHA512</code>. What this long name means is that we'll take a <b>message</b> (the user's name, in this case), create a digest using <b>SHA-512</b> (our hashing algorithm of choice for this article) and encrypt it with an RSA asymmetric key (the one we just created) that follows the basic definitions of the Public Key Cryptography Standards.</p>
 <p>The other algorithms are simply variations of this format. For example, if you prefer hashing the data yourself, you could use the series of enums that are named <code>SignatureDigest</code> instead of <code>SignatureMessage</code> to indicate that the data is already hashed. You can use these variations to use different hashing algorithms, and even different forms of asymmetric encryption like elliptic curve keys (ECDSA).</p>
 <p>If your backend isn't written in Swift, it's likely that your programming language of choice has its own APIs for digital signatures. In the event that it doesn't, you can reproduce this algorithm by simply hashing the data yourself and encrypting the resulting digest.</p>
 <p>Once the signature is successfully generated, we can create a license key in the format we created above and return it to the user.</p>
 <pre>
<code>func createLicense(forUser userName: String) throws -&gt; String {</code>
<code>    //// Remember: This is private backend code. Do not leak your private key!</code>
<code>    //// PS: If you generated the key with OpenSSL, you need to remove the newlines for the key creation to work.</code>
<code>    let privateKeyStringBase64 = "" // Add your key's base64 here</code>
<code>    let privateKey = try getPrivateKey(privateKeyStringBase64)</code>
<code>    ////</code>
<code></code>
<code>    let signature = try sign(userName: userName, withKey: privateKey)</code>
<code>    return """</code>
<code>    {</code>
<code>      "name": "\(userName)",</code>
<code>      "signature": "\(signature)"</code>
<code>    }</code>
<code>    """</code>
<code>}</code>
</pre>
 <p>With my private key, the result of calling <code>createLicense(forUser: "Bruno Rocha")</code> looked like this:</p>
 <pre>
<code>{</code>
<code>  "name": "Bruno Rocha",</code>
<code>  "signature": "VloolUI253gfWBBnCMXARpU/QdjOMbRaGtuNsm+60CMNVRzcvelqoN8yQ3Yy6TY1Hcrl738oJcunqUCvGyR8/3/38+zy96tUzqW7U4MDJtI+jIHD7/4IvQ5Pn9vUJ4zFXz0RiEqf4lgiuqOv8IcD7VuWpXzmMMq13HpxpHb3QoRZx9CTAUwhsVqcJV2NoYAIlHsOB89ptL1/abmH4IkSlXslLxtDeijcShxlUR08XXU3+sGjU0H796KTkSTuqotF11sz9kxWBqCoxL5dGJpxlgV8cTg8vHJl4jvGK4IzKIuWcTGBLkXZ+2NN8m/rW8Lpknxq0kiK4TXvbw/GmKeqPA=="</code>
<code>}</code>
</pre>
 <p>Now, with possession of the license file, this user can use this JSON to activate their copy of the app.</p>
 <h2>Validating a digital signature in the app</h2>
 <p>To validate the user's license in the app, we must decrypt the signature and check that the result is equal to the hash of our data of choice (the user's name). Like with the creation of the signature, <b>Security</b> provides the <code>SecKeyVerifySignature</code> API to make this easy for us!</p>
 <p>But before doing that, we need to create an instance of our <b>public</b> key. Unlike before, the logic from now on should live inside the app:</p>
 <pre>
<code>func getPublicKey(_ base64PublicKeyString: String) throws -&gt; SecKey {</code>
<code>    let data = Data(base64Encoded: base64PublicKeyString, options: [])!</code>
<code></code>
<code>    let options: [String: Any] = [kSecAttrKeyType as String: kSecAttrKeyTypeRSA,</code>
<code>                                  kSecAttrKeyClass as String: kSecAttrKeyClassPublic,</code>
<code>                                  kSecAttrKeySizeInBits as String: 2048]</code>
<code></code>
<code>    var error: Unmanaged&lt;CFError&gt;?</code>
<code>    guard let publicKey = SecKeyCreateWithData(</code>
<code>        data as CFData,</code>
<code>        options as CFDictionary,</code>
<code>        &amp;error</code>
<code>    ) else {</code>
<code>        throw error!.takeRetainedValue() as Error</code>
<code>    }</code>
<code></code>
<code>    return publicKey</code>
<code>}</code>
</pre>
 <p>With possession of the key, we can validate the signature by inputting it and the data into <code>SecKeyVerifySignature</code>. The most important thing here is the algorithm of choice: It must match the one that created the signature.</p>
 <pre>
<code>func validateLicense(userName: String, signature: String, publicKey: SecKey) -&gt; Bool {</code>
<code>    let message = userName.data(using: .utf8)!</code>
<code>    guard let signatureData = Data(base64Encoded: signature) else {</code>
<code>        print("The signature isn't a base64 string!")</code>
<code>        return false</code>
<code>    }</code>
<code></code>
<code>    var error: Unmanaged&lt;CFError&gt;?</code>
<code>    if SecKeyVerifySignature(</code>
<code>        publicKey,</code>
<code>        .rsaSignatureMessagePKCS1v15SHA512,</code>
<code>        message as CFData,</code>
<code>        signatureData as CFData,</code>
<code>        &amp;error</code>
<code>    ) {</code>
<code>        return true</code>
<code>    } else {</code>
<code>        if let error = error {</code>
<code>            print(error.takeRetainedValue())</code>
<code>        }</code>
<code>        return false</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>This function will return true if the license is valid, and print an error otherwise.</p>
 <p>Here's an example of this being used to check the previous signature. Try copying and pasting this to see the result yourself!</p>
 <pre>
<code>// It's not a problem to hardcode your public keys in your app! A hacker won't be able to do anything with them.</code>
<code>let publicKey = try! getPublicKey(</code>
<code>    "MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEArhBwaepKM5hZA4I/IZJ8oOTCbKMr+H5KZ3W4fx/ISMtZqbL6NJBNDLEqHCF/kA/Af9YbN5kFgQoysB9TzDCGnQMZ6nzMsne8muXklrPx7ApX317ckVVDph59mBNrx4IMYNM7BYCN2dv5RxraNFqHKQ9nDi510OIRHVGnKkulLa3RxGVVpTHs3GYI3rDiT/5a8Oi0Tku77lqeZDe368Kx7jsD8Pgxb+Xz7IQfh/H/xG/q9AfcDYNbmBgDbh/OH1+HF9t66/h7uXLPqEgMhkoc5jibd1h/7jFNAoMlB3o97KKGEAQjM61i5/Q1WpK5e1X4OIiFD+KpbERUwO1RvLToSwIDAQAB"</code>
<code>)</code>
<code>let isLicenseValid = validateLicense(</code>
<code>    userName: "Bruno Rocha",</code>
<code>    signature: "VloolUI253gfWBBnCMXARpU/QdjOMbRaGtuNsm+60CMNVRzcvelqoN8yQ3Yy6TY1Hcrl738oJcunqUCvGyR8/3/38+zy96tUzqW7U4MDJtI+jIHD7/4IvQ5Pn9vUJ4zFXz0RiEqf4lgiuqOv8IcD7VuWpXzmMMq13HpxpHb3QoRZx9CTAUwhsVqcJV2NoYAIlHsOB89ptL1/abmH4IkSlXslLxtDeijcShxlUR08XXU3+sGjU0H796KTkSTuqotF11sz9kxWBqCoxL5dGJpxlgV8cTg8vHJl4jvGK4IzKIuWcTGBLkXZ+2NN8m/rW8Lpknxq0kiK4TXvbw/GmKeqPA==",</code>
<code>    publicKey: publicKey</code>
<code>)</code>
<code>if isLicenseValid {</code>
<code>    print("The license is valid!")</code>
<code>    // activatePremiumFeatures()</code>
<code>} else {</code>
<code>    print("The license is not valid!")</code>
<code>}</code>
</pre>
 <p>Try changing the user name or the signature to see what happens! Because I never shared my private key with you, you will never be able to create a different license that passes the validation. I, however, can create as many of them as I wish! Here are some other ones:</p>
 <pre>
<code>{</code>
<code>  "name": "SwiftRocks",</code>
<code>  "signature": "mKb5hIV2/bWkus0VWNEWUcPEoFDcRS6Uv6wpWpbekCSCQbfusOW1mhwntQTSLhIdL+Wl6FK/upW1ztGyij5Y2EE8LjUU0a7Fa2ItdwV8QVhDb/J8ftjpc7U3H2KV8khL61R6QIVzh4aQ1hxjQ0Zs2aaN7dvjprq8gfbBe4rxnKTyllAoXsKG7aCqFgGWdMQVq3wNtiILCh1MnUjk/yRt5fa4vv3l20xHfjPindPnxhTspNCtghuGcgdon5GaHKvNtVYQcsSx7PXvvQ1wpKpDT6juohS/Q+Jz8D4tikgThuFBDoExOXIlN5ZbQJwgNugwWmS8mdnpaw+cbOI88Fm/AA=="</code>
<code>}</code>
<code></code>
<code>{</code>
<code>  "name": "Can't hack me, eh?",</code>
<code>  "signature": "Dq7EfDURo6mj/0Fk7XAnDt04WCDxXBQYJAdQMQh3fVV4K4UE4AaCGAv8XX9Mo/SKrnD54VU9oSpH3XOQKKBkLKcG59+GatKILO9Os0Ikf7/PiweaTmrtRwnY24o8PU7R3jlj+ces8A8KwZkw2up/XdIz3wS6TzPNGEq+oy38mI7sZuG7zeEKVwFsZPuSaK13zIH50jlhIndYVx/MVhSYbdHvf6mkF2n84QmwUEmQbc1ZGriUozlxNiZ+TxjeFywUvCfzidd0OR7j78kb32WgMsb7osAk1p4BSV9LTpFAOaJzmF2QiiVNr/UjgBxx5KkrXMxmznb4/wJPi902iE1IaA=="</code>
<code>}</code>
<code></code>
<code>{</code>
<code>  "name": "Unlimited power!",</code>
<code>  "signature": "rFT++9NEzcCsoxy0V8RRd7VOyO2aKfAQR0Cfwl1uLlbxp2ibRmZBRaAVWkCRw0YLOoNSb/VYkJVW++y04k+KWSq+X7QJcKpRfflZvyJCQczt8EVbYAcJrVSLyTpFVscxviwsuSFkVKsVzlJrfob/3+7YDg4hnTlBd1fvntzqUNomC0mzmyAuWcZs+EwVzHyQ7aGCnbn3tgbDq4W9TsKRjfEJBQOYrKX0WvWNpRUl5ScU5LL5wxE1Pt76CZUtBynrDlJHbRf0pNbWAdToFLUz6gJ+OqzeoUt/26ieEykfG0kwhLHKd8+N67nNWb3HuF5CiRkUoqC9nynKs4mUGmup0w=="</code>
<code>}</code>
</pre>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>We can now safely activate our app's premium features for these users.</p>
 <h2>Conclusion</h2>
 <p>As a final note, remember what was said in regards to the meaning of <i>uncrackable</i> in this context. Unless your app is serving 100% of its content from a backend, it's impossible to make it uncrackable. In this case, a hacker could simply edit the assembly of the app to invert the <code>if</code> that activates the premium features. Like a physical lock, security measures in macOS apps are simply deterrents, and you should keep that in mind when implementing features like this.</p>
</div>]]></description>
</item>
<item>
    <title>Be careful with Obj-C bridging in Swift</title>
    <link>https://swiftrocks.com/be-careful-with-objc-bridging-in-swift</link>
    <guid>https://swiftrocks.com/be-careful-with-objc-bridging-in-swift</guid>
    <pubDate>Tue, 2 Mar 2021 09:00:00 GMT-3</pubDate>
<description><![CDATA[
 
  
  <!--WRITEIT_POST_NAME=Be careful with Obj-C bridging in Swift--> 
  <!--WRITEIT_POST_HTML_NAME=be-careful-with-objc-bridging-in-swift--> 
  <!--Add here the additional properties that you want each page to possess.--> 
  <!--These properties can be used to change content in the template page or in the page itself as shown here.--> 
  <!--Properties must start with 'WRITEIT_POST'.--> 
  <!--Writeit provides and injects WRITEIT_POST_NAME and WRITEIT_POST_HTML_NAME by default.--> 
  <!--WRITEIT_POST_SHORT_DESCRIPTION=Bridging to/from Objective-C is an important part of Swift development due to the Obj-C history of Apple's platforms. Unfortunately, there are some hidden caveats that could lead to bizarre situations that would be impossible in a pure Swift environment.--> 
  <!--DateFormat example: 2020-04-12T14:00:00+02:00--> 
  <!--WRITEIT_POST_SITEMAP_DATE_LAST_MOD=2021-03-02T14:00:00+02:00--> 
  <!--WRITEIT_POST_SITEMAP_DATE=2021-03-02T14:00:00+02:00--> 
  <title>Be careful with Obj-C bridging in Swift</title>  
 

<div class="blog-post"> 
 <div class="post-title-index">  
  <h1>Be careful with Obj-C bridging in Swift</h1>
 </div> 
 <div class="post-info"> 
  <div class="category category-swift">
   Swift
  </div> 
  <div class="category category-ios">
   iOS
  </div> 
  <div class="post-info-text">
   Published on 02 Mar 2021 
  </div> 
 </div>  
 <p>Bridging to/from Objective-C is an important part of Swift development due to the Obj-C history of Apple's platforms. Unfortunately, there are some hidden caveats that could lead to bizarre situations that would be impossible in a pure Swift environment. When dealing with Objective-C types, it's useful to check if they don't have a history of being <i>too different</i> from their Swift counterparts.</p>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>The reason for the carefulness is because bridging can be completely hidden from you. As you might know, Swift developers can use the <code>as</code> upcast operator to convert a type to one of the superclasses or protocols that it inherits from:</p>
 <pre>
<code>let myViewController = MyViewController()</code>
<code>let viewController = myViewController as UIViewController</code>
</pre>
 <p>There is no change in functionality between <code>myViewController</code> and <code>viewController</code> because all the operator does is limit what you can access from that type. Deep down, they are still the same object.</p>
 <p>However, <code>as</code> is <b>also the Obj-C bridging operator:</b></p>
 <pre>
<code>let string = "MyString"</code>
<code>let nsstring = string as NSString</code>
</pre>
 <p>While visually the same, this case is completely different from the view controllers one! <code>String</code> does not inherit or uses <code>NSString</code> in any way -- they are different objects with different implementations. The way this works is that <code>as</code> in this case is a syntax sugar for the following:</p>
 <pre>
<code>let string = "MyString"</code>
<code>let nsstring: NSString = string._bridgeToObjectiveC()</code>
</pre>
 <p>This method comes from the <code>_ObjectiveCBridgeable</code> protocol, which allows objects the automatically convert a Swift type to an Objective-C equivalent when needed, as well as giving the free <code>as</code> cast behavior we've seen:</p>
 <pre>
<code>extension Int8 : _ObjectiveCBridgeable {</code>
<code>    @_semantics("convertToObjectiveC")</code>
<code>    public func _bridgeToObjectiveC() -&gt; NSNumber {</code>
<code>        return NSNumber(value: self)</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>What can go wrong with this? Unfortunately, everything. Consider the following example:</p>
 <pre>
<code>let string = "MyString"</code>
<code>let range = string.startIndex..&lt;string.endIndex</code>
<code></code>
<code>let roundTrip = (string as NSString) as String</code>
<code>roundTrip[range]</code>
</pre>
 <p>What do you think will happen in the last line?</p>
 <p>This code works fine today, but it was actually a source of crashes around Swift 4! From a Swift point of view there's nothing wrong with this code, because converting <code>String</code> to <code>NSString</code> and back to <code>String</code> again technically does nothing. But from a bridging point of view, the final <code>String</code> is a <b>different</b> object from the first one! The act of "converting" <code>String</code> to <code>NSString</code> is actually the creation of a brand new <code>NSString</code> that has its own storage, which will repeat when it gets "converted" back to String. This makes the range values incompatible with the final string, resulting in a crash.</p>
 <p>Let's take a look at a different example. Protocols can be exposed to Obj-C by using <code>@objc</code>, which from the Swift side allows metatypes to be used as Obj-C's <code>Protocol</code> pointers.</p>
 <pre>
<code>@objc(OBJCProto) protocol SwiftProto {}</code>
<code></code>
<code>let swiftProto: SwiftProto.Type = SwiftProto.self</code>
<code>let objcProto: Protocol = SwiftProto.self as Protocol</code>
<code>// or, from the Obj-C side, NSProtocolFromString("OBJCProto")</code>
</pre>
 <p>If we compare two swift metatypes, they will trivially be equal:</p>
 <pre>
<code>ObjectIdentifier(SwiftProto.self) == ObjectIdentifier(SwiftProto.self)</code>
<code>// true</code>
</pre>
 <p>Likewise, if we upcast a metatype to <code>Any.Type</code>, the condition will still be true as they are still the same object:</p>
 <pre>
<code>ObjectIdentifier(SwiftProto.self as Any.Type) == ObjectIdentifier(SwiftProto.self)</code>
<code>// true</code>
</pre>
 <p>So if, say, I upcast it to something else like <code>AnyObject</code>, this will still be true, right?</p>
 <pre>
<code>ObjectIdentifier(SwiftProto.self as AnyObject) == ObjectIdentifier(SwiftProto.self)</code>
<code>// false</code>
</pre>
 <p>No, because we're not upcasting anymore! "Casting" to <code>AnyObject</code> is also a bridge syntax sugar that converts the metatype to <code>Protocol</code>, and because they are not the same object, the condition stops being true. The same thing happens if we treat it as <code>Protocol</code> directly:</p>
 <pre>
<code>ObjectIdentifier(SwiftProto.self) == ObjectIdentifier(SwiftProto.self)</code>
<code>// true</code>
<code>ObjectIdentifier(SwiftProto.self as Protocol) == ObjectIdentifier(SwiftProto.self)</code>
<code>// false</code>
</pre>
 <p>Cases like this can be extremely confusing if your Swift method cannot predict <b>where</b> its arguments are coming from, because as we can see above, the very same object can completely change the result of an operation depending on if it was bridged or not. If it wasn't enough, things get even worse when you deal with the fact that the very same method can have different implementations across languages:</p>
 <pre>
<code>String(reflecting: Proto.self) // __C.OBJCProto</code>
<code>String(reflecting: Proto.self as Any.Type) // __C.OBJCProto</code>
<code>String(reflecting: Proto.self as AnyObject) // Protocol 0x...</code>
<code>String(reflecting: Proto.self as Protocol) // Protocol 0x...</code>
</pre>
 <p>Even though from a Swift point of view it looks like these are all the same object, the results differ when bridging kicks in because <code>Protocol</code> descriptions are implemented differently than Swift's metatypes'. If you're trying to convert types to strings, you need to make sure you're always using their bridged version:</p>
 <pre>
<code>func identifier(forProtocol proto: Any) -&gt; String {</code>
<code>    // We NEED to use this as an AnyObject to force Swift to convert metatypes</code>
<code>    // to their Objective-C counterparts. If we don't do this, they are treated as</code>
<code>    // different objects and we get different results.</code>
<code>    let object = proto as AnyObject</code>
<code>    //</code>
<code>    if let objcProtocol = object as? Protocol {</code>
<code>        return NSStringFromProtocol(objcProtocol)</code>
<code>    } else if let swiftMetatype = object as? Any.Type {</code>
<code>        return String(reflecting: swiftMetatype)</code>
<code>    } else {</code>
<code>        crash("Type identifiers must be metatypes -- got \(proto) of type \(type(of: proto))")</code>
<code>    }</code>
<code>}</code>
</pre>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>If you don't convert the type to <code>AnyObject</code>, the very same protocol may give you two different results depending on how your method was called (for example, an argument provided in Swift versus in Obj-C). This is the most common source of bridging issues, as a similar case existed with <code>NSString</code> a few versions ago where a method had different implementations when compared to <code>String</code>, which caused issues in cases where a Swift string was automatically converted to an <code>NSString</code>.</p>
 <h2>Conclusion</h2>
 <p>I personally think that using <code>as</code> as a syntax sugar for bridging was not the best idea. From the developer's point of view it's clear that <code>string._bridgeToObjectiveC()</code> may cause the object to change, while <code>as</code> indicates the opposite. <code>_ObjectiveCBridgeable</code> is a public protocol, but it's not supported for general use. In general, be aware of custom types implementing it, and pay extra attention when you're upcasting to make sure you're not bridging types when you didn't mean to.</p>
</div>]]></description>
</item>
<item>
    <title>Understanding @inlinable in Swift</title>
    <link>https://swiftrocks.com/understanding-inlinable-in-swift</link>
    <guid>https://swiftrocks.com/understanding-inlinable-in-swift</guid>
    <pubDate>Tue, 22 Dec 2020 09:00:00 GMT-3</pubDate>
<description><![CDATA[
 
  
  <!--WRITEIT_POST_NAME=Understanding @inlinable in Swift--> 
  <!--WRITEIT_POST_HTML_NAME=understanding-inlinable-in-swift--> 
  <!--Add here the additional properties that you want each page to possess.--> 
  <!--These properties can be used to change content in the template page or in the page itself as shown here.--> 
  <!--Properties must start with 'WRITEIT_POST'.--> 
  <!--Writeit provides and injects WRITEIT_POST_NAME and WRITEIT_POST_HTML_NAME by default.--> 
  <!--WRITEIT_POST_SHORT_DESCRIPTION=The @inlinable attribute is one of Swift's lesser-known attributes. Like others of its kind, its purpose is to enable a specific set of micro-optimizations that you can use to increase the performance of your application.--> 
  <!--DateFormat example: 2020-04-12T14:00:00+02:00--> 
  <!--WRITEIT_POST_SITEMAP_DATE_LAST_MOD=2020-12-22T14:00:00+02:00--> 
  <!--WRITEIT_POST_SITEMAP_DATE=2020-12-22T14:00:00+02:00--> 
  <title>Understanding @inlinable in Swift</title>  
 

<div class="blog-post"> 
 <div class="post-title-index">  
  <h1>Understanding <code>@inlinable</code> in Swift</h1>
 </div> 
 <div class="post-info"> 
  <div class="category category-compiler">
   Compiler
  </div> 
  <div class="category category-swift">
   Swift
  </div> 
  <div class="post-info-text">
   Published on 22 Dec 2020 
  </div> 
 </div>  
 <p>The <code>@inlinable</code> attribute is one of Swift's lesser-known attributes. Like others of its kind, its purpose is to enable a specific set of micro-optimizations that you can use to increase the performance of your application. Let's take a look at how this one works.</p>
 <h2>Inline expansion in Swift with <code>@inline</code></h2>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>Perhaps the most important thing to note is that although <code>@inlinable</code> is related to code inlining, it's <b>not</b> the same as the <code>@inline</code> attribute <a href="https://swiftrocks.com/the-forbidden-inline-attribute-in-swift">we already covered here at SwiftRocks.</a> But to avoid you from having to read two articles, we'll go through the concepts again before introducing <code>@inlinable</code>.</p>
 <p>In programming, <b>inline expansion</b>, also called inlining, is a compiler optimization technique that replaces a method call with the body of the said method.</p>
 <p>The action of calling a method is hardly free. As we covered back in SwiftRocks's article about memory allocation, a lot of orchestration is done to transmit, store and mutate the state of your application when it desires to push a new stack trace to a thread. While for one side having a stack trace makes your debugging life easier, you might wonder if it's necessary to do this every time. If a method is too simple, the overhead of calling it might be seen as something not only unnecessary but also harmful for the overall performance of the app:</p>
 <pre>
<code>func printPlusOne(_ num: Int) {</code>
<code>    print("My number: \(num + 1)")</code>
<code>}</code>
<code></code>
<code>print("I'm going to print some numbers!")</code>
<code>printPlusOne(5)</code>
<code>printPlusOne(6)</code>
<code>printPlusOne(7)</code>
<code>print("Done!")</code>
</pre>
 <p>A method like <code>printPlusOne</code> is too simple to justify a complete definition in the application's binary. We define it in code for clarity reasons, but when pushing this app for release it would arguably be better to get rid of it and replace everyone that is calling it with the full implementation, like this:</p>
 <pre>
<code>print("I'm going to print some number!")</code>
<code>print("My number: \(5 + 1)")</code>
<code>print("My number: \(6 + 1)")</code>
<code>print("My number: \(7 + 1)")</code>
<code>print("Done!")</code>
</pre>
 <p>This removed method-calling overhead may increase the performance of the app with the trade-off of slightly increasing the overall binary size, depending on how large the inlined methods are. This process is done automatically by the Swift compiler, with variable degrees of aggressiveness depending on which optimization level you are building for. As we covered in <a href="https://swiftrocks.com/the-forbidden-inline-attribute-in-swift">The Forbidden @inline Attribute in Swift</a>, the <code>@inline</code> attribute can be used to ignore the optimization level and force the compiler to follow a particular direction, and that the act of inlining can also be useful for obfuscation purposes.</p>
 <h2>What is the purpose of <code>@inlinable</code>?</h2>
 <p>One important aspect of most optimizations like inlining is that they are mostly done internally. While you can be confident that a module you're developing will be properly optimized, things are a lot more complicated when we're dealing with calls made from <b>other</b> modules.</p>
 <p>Compiler optimizations happen because the compiler has the full picture of what's being compiled, but when you're building a framework the compiler cannot possibly know <i>how</i> the importers are going to it. As a result, while the internal code of the framework will be optimized, the public interface will most likely end up intact.</p>
 <p>A first thought may be "well, we could tell the compiler what sources composed that framework so that it could regain the full picture and apply more optimizations to the call sites", but this gets complicated when you realize that the importer of the said framework is linking something that is <b>already</b> compiled. All this information on source files is gone, and you may not even have them in the first place if this is a third-party framework!</p>
 <p>However, this is not an impossible problem. In fact, while compilers have different solutions for this problem, they mostly follow this same idea of <i>supercharging</i> a module's public interface to contain additional information that the compiler can use at link time to further optimize the pieces of code in where a framework is being used, which includes, but is not exclusive to, inlining.</p>
 <p>In practice though, you may notice that this could seriously get out of hand. If we start adding information from every single method to the public interface, not only the framework would massively jump in size but most of that would probably go to waste! As we don't know how the framework is going to be used, doing so in a discriminatory manner would be a terrible mistake.</p>
 <p>Instead of gambling, Swift instead lets you make this decision for yourself. Introduced in Swift 4.2, the <code>@inlinable</code> attribute allows you to enable cross-module inlining for a particular method. When this is done, the implementation of the method will be exposed as part of the module's public interface, allowing the compiler to further optimize calls made from different modules.</p>
 <pre>
<code>@inlinable func printPlusOne(_ num: Int) {</code>
<code>    print("My number: \(num + 1)")</code>
<code>}</code>
</pre>
 <p>If the inlinable method happens to be calling other methods internally, the compiler will ask you to <b>also</b> expose these methods. This can be done either by also making them <code>@inlinable</code> or by marking them with <code>@usableFromInline</code>, which indicates that although the method is being used <i>from</i> an inlined method, it <i>itself</i> is not really supposed to be inlined.</p>
 <pre>
<code>@inlinable func myMethod() {</code>
<code>    myMethodHelper()</code>
<code>}</code>
<code></code>
<code>// Used within an inlinable method, but not inlinable itself</code>
<code>@usableFromInline internal func myMethodHelper() {</code>
<code>    // ...</code>
<code>}</code>
</pre>
 <p>The largest benefit of <code>@inlinable</code> lies in how much overhead certain methods might have. Even though the overhead of most methods can be negligible, some methods can be quite expensive, specifically if they contain generics and closures:</p>
 <pre>
<code>@inlinable public func allEqual&lt;T&gt;(_ seq: T) -&gt; Bool where T : Sequence, T.Element : Equatable {</code>
<code> // ...</code>
<code>}</code>
</pre>
 <p>The compiler already applies multiple optimizations to prevent generics from being a problem in general, but as we mentioned, these don't apply when the code is being called from a separate module. For cases like that, using <code>@inlinable</code> can give you interesting performance boosts at the cost of an increased framework binary size.</p>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>On the other hand, <code>@inlinable</code> can be a massive problem depending on what you're building. If the implementation of an <code>@inlinable</code> method changes, the modules that import it will not be able to make use of the modifications unless they are recompiled. Normally you would be able to update a framework by simply replacing the binary, but because the implementation of some methods got inlined, the app will keep running the old behavior even if you're linking to the new version. Because of this, apps with the <b>library evolution</b> setting enabled may find themselves unable to play around with <code>@inlinable</code> as this can break the ABI stability of your framework.</p>
 <h2>Should I use <code>@inlinable</code>, or even <code>@inline</code>?</h2>
 <p>Unless you're building a framework with ABI/API stability, these attributes should be perfectly safe to use. Still, I would strongly suggest for you to <b>not</b> use them unless you know what you're doing. They are built to be used in very special cases that most applications will never experience, so unless you really have to, it may be better for you to see these as nothing more than a piece of cool Swift trivia you read at SwiftRocks.</p>
 <h2>References and Good Reads</h2>
 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0193-cross-module-inlining-and-specialization.md">SE-0193: Cross-module inlining and specialization</a>
 <br>
</div>]]></description>
</item>
<item>
    <title>DispatchSource: Detecting changes in files and folders in Swift</title>
    <link>https://swiftrocks.com/dispatchsource-detecting-changes-in-files-and-folders-in-swift</link>
    <guid>https://swiftrocks.com/dispatchsource-detecting-changes-in-files-and-folders-in-swift</guid>
    <pubDate>Tue, 24 Nov 2020 09:00:00 GMT-3</pubDate>
<description><![CDATA[
 
  
  <!--WRITEIT_POST_NAME=DispatchSource: Detecting changes in files and folders in Swift--> 
  <!--WRITEIT_POST_HTML_NAME=dispatchsource-detecting-changes-in-files-and-folders-in-swift--> 
  <!--Add here the additional properties that you want each page to possess.--> 
  <!--These properties can be used to change content in the template page or in the page itself as shown here.--> 
  <!--Properties must start with 'WRITEIT_POST'.--> 
  <!--Writeit provides and injects WRITEIT_POST_NAME and WRITEIT_POST_HTML_NAME by default.--> 
  <!--WRITEIT_POST_SHORT_DESCRIPTION=The DispatchSource family of types from GCD contains a series of objects that are capable of monitoring OS-related events. In this article, we'll see how to use DispatchSource to monitor a log file and create a debug-only view that shows the app's latest logs.--> 
  <!--WRITEIT_POST_SITEMAP_DATE_LAST_MOD=2020-11-24T14:00:00+02:00--> 
  <!--WRITEIT_POST_SITEMAP_DATE=2020-11-24T14:00:00+02:00--> 
  <title>DispatchSource: Detecting changes in files and folders in Swift</title>  
 

<div class="blog-post"> 
 <div class="post-title-index">  
  <h1>DispatchSource: Detecting changes in files and folders in Swift</h1>
 </div> 
 <div class="post-info"> 
  <div class="category category-ios">
   iOS
  </div> 
  <div class="post-info-text">
   Published on 24 Nov 2020 
  </div> 
 </div>  
 <div class="post-image"> 
  <img src="https://i.imgur.com/OsWGXW5.png" alt="Debug Log View" style="height: 500px"> 
 </div> 
 <p>The <code>DispatchSource</code> family of types from GCD contains a series of objects that are capable of monitoring OS-related events. In this article, we'll see how to use <code>DispatchSource</code> to monitor a log file and create a debug-only view that shows the app's latest logs.</p>
 <h2>Context: File logging in Swift</h2>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>While every app will print debug logs to the developer console, it's good practice to save these logs somewhere. While <code>OSLog</code> automatically saves your logs to the system, I find that maintaining your own log file (like <code>MyApp-2020-11-24T14:23:42.log</code>) is an additional good practice. If your app receives a bug report from an external beta tester, you may find retrieving and inspecting your own log file easier than teaching that user how to extract and send their <code>OSLogs</code>. For example, if you have your own log files, you can add a debug gesture that automatically dumps these logs somewhere.</p>
 <p>Regardless of how you generate these logs, you can save them in two main ways. The most common way to write a file is to write all of the contents at once using <code>String.write(to:)</code>:</p>
 <pre>
<code>var logs = ["Logged in!", "Logged out!"]</code>
<code>logs.joined(separator: "\n").write(to: logsPath, atomically: false, encoding: .utf8)</code>
</pre>
 <p>This is fine if you're writing all your logs at once when your app is going to close, but if you plan to continuously add content to a file, you should use <code>FileHandler</code>:</p>
 <pre>
<code>let fileHandler = try FileHandle(forWritingTo: logsPath)</code>
<code></code>
<code>func addToFile(log: String) throws {</code>
<code>    fileHandler.seekToEndOfFile() // Move the cursor to the end of the file</code>
<code>    fileHandler.write(log.data(using: .utf8)!)</code>
<code>}</code>
</pre>
 <p>In the end, the difference between these two methods is that the first one is overwriting the file, while the second one is more similar to a text editor in terms that you're <i>modifying</i> an existing file.</p>
 <h2>Monitoring file changes</h2>
 <p>Monitoring changes in the file system is done by attaching a <code>DispatchSource</code> object to the file/folder in question and registering which events we'd like to be notified of. Note though that a <code>DispatchSource</code> is not necessarily restricted to file system events -- they are capable of monitoring many types of OS-related events, which include timers, processes, UNIX signals and more things that are meant to be used in macOS instead of iOS itself.</p>
 <p>In this article, however, we're only going to monitor file events. To show how the process works, we are going to detect changes in a log file and display these changes in the app's UI.</p>
 <div class="post-image"> 
  <img src="https://i.imgur.com/OsWGXW5.png" alt="Debug Log View" style="height: 500px"> 
 </div>
 <p>If you have something akin to an internal employee beta of your app, a feature like this can be very useful. If someone finds a bug, they can open this feature and potentially determine the cause of the issue on the fly without needing a developer to boot Xcode and run an actual debug build.</p>
 <p>The first step to monitor file changes is to abstract all of it. Let's start with a new <code>FileMonitor</code> class:</p>
 <pre>
<code>final class FileMonitor {</code>
<code></code>
<code>    let url: URL</code>
<code>    let fileHandle: FileHandle</code>
<code>    let source: DispatchSourceFileSystemObject</code>
<code></code>
<code>    init(url: URL) throws {</code>
<code>        self.url = url</code>
<code>        ...</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>To create a <code>DispatchSource</code> that monitors the file system, we'll call the <code>makeFileSystemObjectSource</code> factory to get a new <code>DispatchSourceFileSystemObject</code>:</p>
 <pre>
<code>source = DispatchSource.makeFileSystemObjectSource(</code>
<code>    fileDescriptor: ...,</code>
<code>    eventMask: ...,</code>
<code>    queue: ...</code>
<code>)</code>
</pre>
 <p>To fill these arguments, let's describe what each of them represents.</p>
 <p><code>fileDescriptor</code> is an <code>Int32</code> that represents a file descriptor pointing to the file/folder we want to monitor. Sounds crazy right? Don't worry! The same <code>FileHandle</code> type used to write the logs can provide this information.</p>
 <p>For <code>eventMask</code>, we should pass the event types that we want to be notified of. The enum of possibilities includes many cases like <code>.rename</code>, <code>.delete</code>, <code>.write</code> and <code>.extend</code>, and for monitoring <b>changes</b> in files, the correct one to use depends on how you're writing to that file. If you're <i>overwriting</i> the file by calling <code>String.write(to:)</code>, you should use <code>.write</code>, but if you're <i>modifying</i> the file with <code>FileHandle</code>, you should use <code>.extend</code> instead. For this tutorial, we'll use the latter.</p>
 <p>Finally, the <code>queue</code> argument is the dispatch queue in which the events should be dispatched. For simplicity, we'll use the main queue.</p>
 <pre>
<code>self.fileHandle = try FileHandle(forReadingFrom: url)</code>
<code></code>
<code>source = DispatchSource.makeFileSystemObjectSource(</code>
<code>    fileDescriptor: fileHandle.fileDescriptor,</code>
<code>    eventMask: .extend,</code>
<code>    queue: DispatchQueue.main</code>
<code>)</code>
</pre>
 <p>In order to receive event notifications, we must pass an <code>eventHandler</code> to the dispatch source. This might seem weird since you'd normally use a delegate object for this, but the reason it works like this is probably that this is a very old Objective-C API.</p>
 <pre>
<code>source.setEventHandler {</code>
<code>    let event = self.source.data</code>
<code>    self.process(event: event)</code>
<code>}</code>
</pre>
 <p>When the event handler is triggered, the <code>data</code> property of the dispatch source will contain the set of events that were dispatched.</p>
 <p>Additionally, we must provide a way to safely shutdown the dispatch source. We do this by assigning a <code>cancelHandler</code> that closes the <code>FileHandle</code> whenever the source is canceled, and by adding a <code>deinit</code> call to our class that cancels it.</p>
 <pre>
<code>    //init()...</code>
<code>    source.setCancelHandler {</code>
<code>        try? self.fileHandle.close()</code>
<code>    }</code>
<code>}</code>

<code>deinit {</code>
<code>    source.cancel()</code>
<code>}</code>
</pre>
 <p>To process the events, we'll use the following method:</p>
 <pre>
<code>func process(event: DispatchSource.FileSystemEvent) {</code>
<code>    guard event.contains(.extend) else {</code>
<code>        return</code>
<code>    }</code>
<code>    let newData = self.fileHandle.readDataToEndOfFile()</code>
<code>    let string = String(data: newData, encoding: .utf8)!</code>
<code>    print("Detected: \(string)")</code>
<code>}</code>
</pre>
 <p>When <code>readDataToEndOfFile()</code> is called, the file handle will return everything between the column it's currently pointing at and the end of the file. This also makes it point to the end of the file, making it a great way of fetching the changes in the file. When another event is received, the file handle will already be positioned to read the newest changes.</p>
 <p>If the concept of pointers here makes you confused, think of <code>FileHandle</code> like a cursor in a text editor. When we call <code>readDataToEndOfFile()</code>, we're copying everything that was added and moving the cursor to the end of it.</p>
 <p>While the <code>guard</code> is going to be useless for this example, it's important to notice that <code>FileSystemEvent</code> is an <code>OptionSet</code>. As you can monitor and receive multiple event types to/from your dispatch source, the idea is that you should always check which events were received so you can call the correct logic for it.</p>
 <p>To test all of this, we need to set up two final things. First, as we're not interested in reading what's <i>already</i> logged, we should move the file handler's pointer to the end of the file as soon as we create it. Finally, to wrap it up, we can start the dispatch source by calling <code>source.resume()</code>.</p>
 <pre>
<code>fileHandle.seekToEndOfFile()</code>
<code>source.resume()</code>
</pre>
 <p>Here's a simple <code>ViewController</code> that you can use to test this:</p>
 <pre>
<code>class ViewController: UIViewController {</code>
<code></code>
<code>    // Make sure to edit this path to your real Desktop.</code>
<code>    static let logPath = URL(fileURLWithPath: "/Users/swiftrocks/Desktop/logTester.log")</code>
<code></code>
<code>    override func viewDidLoad() {</code>
<code>        // Create the file</code>
<code>        try! "".write(to: Self.logPath, atomically: true, encoding: .utf8)</code>
<code></code>
<code>        // Monitor the file</code>
<code>        let monitor = try! FileMonitor(url: ViewController.logPath)</code>
<code></code>
<code>        // Write something to the file</code>
<code>        let fileHandle = try! FileHandle(forWritingTo: Self.logPath)</code>
<code>        fileHandle.seekToEndOfFile() // Make sure we're writing at the end of the file!</code>
<code>        fileHandle.write("Woo! SwiftRocks.".data(using: .utf8)!)</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>After running this app, you should see <code>"Detected: Woo! SwiftRocks."</code> in the console, plus anything else you add to that file later on!</p>
 <h2>Why doesn't it work when I edit the file in an editor?</h2>
 <p>If you try to test this by opening a text editor, adding some text and saving the file, you'll see that it may not work. The reason is that editors like Xcode don't actually modify the file -- instead, they act on copies of it. When you save it, they <i>delete</i> the original file and replace it with the copy they were maintaining. You can confirm that this is the case by registering events like <code>.delete</code> and <code>.link</code> to your dispatch source and see how they get triggered when you save the file. If you're doing this for a macOS app, one way to support text editors would be to register these cases and cancel/reboot the dispatch source when a new file is linked.</p>
 <h2>Wrapping up: Getting it ready for our debug feature</h2>
 <p>Because making our monitor print what was just logged to a file makes no sense, we can modify our <code>FileMonitor</code> to work with a delegate. Here's the full <code>FileMonitor</code>:</p>
 <pre>
<code>protocol FileMonitorDelegate: AnyObject {</code>
<code>    func didReceive(changes: String)</code>
<code>}</code>
<code></code>
<code>final class FileMonitor {</code>
<code></code>
<code>    let url: URL</code>
<code></code>
<code>    let fileHandle: FileHandle</code>
<code>    let source: DispatchSourceFileSystemObject</code>
<code></code>
<code>    weak var delegate: FileMonitorDelegate?</code>
<code></code>
<code>    init(url: URL) throws {</code>
<code>        self.url = url</code>
<code>        self.fileHandle = try FileHandle(forReadingFrom: url)</code>
<code></code>
<code>        source = DispatchSource.makeFileSystemObjectSource(</code>
<code>            fileDescriptor: fileHandle.fileDescriptor,</code>
<code>            eventMask: .extend,</code>
<code>            queue: DispatchQueue.main</code>
<code>        )</code>
<code></code>
<code>        source.setEventHandler {</code>
<code>            let event = self.source.data</code>
<code>            self.process(event: event)</code>
<code>        }</code>
<code></code>
<code>        source.setCancelHandler {</code>
<code>            try? self.fileHandle.close()</code>
<code>        }</code>
<code></code>
<code>        fileHandle.seekToEndOfFile()</code>
<code>        source.resume()</code>
<code>    }</code>
<code></code>
<code>    deinit {</code>
<code>        source.cancel()</code>
<code>    }</code>
<code></code>
<code>    func process(event: DispatchSource.FileSystemEvent) {</code>
<code>        guard event.contains(.extend) else {</code>
<code>            return</code>
<code>        }</code>
<code>        let newData = self.fileHandle.readDataToEndOfFile()</code>
<code>        let string = String(data: newData, encoding: .utf8)!</code>
<code>        self.delegate?.didReceive(changes: string)</code>
<code>    }</code>
<code>}</code>
</pre>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>From here, creating a view that displays the latest logs like in the example picture is just a matter of creating a new <code>FileMonitor</code> and setting the feature as the delegate.</p>
 <p>You can make a feature like this without file logging/monitoring, but adding it to the mix would allow you to isolate the feature's logic from the actual logging mechanics. For something that's meant to be only used when debugging, that can be very nice in terms of architecture.</p>
</div>]]></description>
</item>
<item>
    <title>How Swift API Availability Works Internally</title>
    <link>https://swiftrocks.com/how-availability-works-internally-in-swift</link>
    <guid>https://swiftrocks.com/how-availability-works-internally-in-swift</guid>
    <pubDate>Tue, 29 Sep 2020 09:00:00 GMT-3</pubDate>
<description><![CDATA[
 
  
  <!--WRITEIT_POST_NAME=How Swift API Availability Works Internally--> 
  <!--WRITEIT_POST_HTML_NAME=how-availability-works-internally-in-swift--> 
  <!--Add here the additional properties that you want each page to possess.--> 
  <!--These properties can be used to change content in the template page or in the page itself as shown here.--> 
  <!--Properties must start with 'WRITEIT_POST'.--> 
  <!--Writeit provides and injects WRITEIT_POST_NAME and WRITEIT_POST_HTML_NAME by default.--> 
  <!--WRITEIT_POST_SHORT_DESCRIPTION=We use API availability checks all the time, but have you wondered how the Swift compiler handles this? In this article, we'll take a deep dive on how the #availability condition works, how the Swift compiler is able to know if a specific symbol is available for usage and what the code you wrote looks like after being optimized.--> 
  <!--WRITEIT_POST_SITEMAP_DATE_LAST_MOD=2020-09-29T14:00:00+02:00--> 
  <!--WRITEIT_POST_SITEMAP_DATE=2020-09-29T14:00:00+02:00--> 
  <title>How Swift API Availability Works Internally</title>  
 

<div class="blog-post"> 
 <div class="post-title-index">  
  <h1>How Swift API Availability Works Internally</h1>
 </div> 
 <div class="post-info"> 
  <div class="category category-compiler">
   Compiler
  </div> 
  <div class="category category-swift">
   Swift
  </div> 
  <div class="post-info-text">
   Published on 29 Sep 2020 
  </div> 
 </div>  
 <p>We use API availability checks all the time to provide fallbacks for users running older iOS versions, but have you wondered <b>how the Swift compiler handles this?</b> In this article, we'll take a deep dive on how the <code>#availability</code> condition works, how the Swift compiler is able to know if a specific symbol is available for usage and what the code you wrote looks like after being optimized.</p>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>I have recently authored an <a href="https://github.com/apple/swift-evolution/pull/1184">evolution proposal</a> to add a new <code>#unavailable</code> attribute to Swift, and while I haven't needed to do any meaningful work on Swift's availability system to implement it, this gave me the opportunity to learn a little more about things work deep down. Here's a deep dive on Swift's availability system!</p>
 <h2>Why are <code>#available</code> checks necessary?</h2>
 <p>While the reason <i>why</i> API availability checks are needed might be obvious, let's take a practical look at it for educational purposes before seeing how it works deep down.</p>
 <p>Every <code>UIKit</code> or <code>Foundation</code> code you use comes from the iOS SDKs in your machine. While users of new iOS versions can still use your app normally if you don't update your app to support the new version, you'll only be able to use the version's new features if you submit a version that links with the relevant SDK. Currently these SDKs are shipped within Xcode, so you can always expect newer iOS versions to accompany a new Xcode version as well. You can always find an Xcode's provided SDKs in the description of the version.</p>
 <p><code>Xcode 12 includes Swift 5.3 and SDKs for iOS 14, iPadOS 14, tvOS 14, watchOS 7 and maccOS Catalina.</code></p>
 <p>However, even though your app now links to the correct SDK and uses its features, you don't know if the users of your app have the latest iOS version installed! If you were allowed to ship your app without compatibility checks, an app using newer iOS features would crash when used in old versions because the SDK in that user's device will not have those symbols. Thus, unless you explicitly set your app's minimum deployment target to be the latest available iOS version, you must use Swift's <code>#available</code> condition to provide a suitable fallback for older versions.</p>
 <pre>
<code>if #available(iOS 14.0, *) {</code>
<code>    SomeiOS14NewType()</code>
<code>} else {</code>
<code>    SomeOlderType()</code>
<code>}</code>
</pre>
 <p>Here, <code>(iOS 14.0, *)</code> means "If this is an iOS device, return <code>true</code> only if it contains the iOS 14 SDK. Always return <code>true</code> if this is a different platform (*)."</p>
 <p>You can only use platforms that are hardcoded into Swift (iOS, OSX, tvOS and watchOS), but you can use any version you wish. The Swift compiler funnily uses absurd version numbers to prevent things from running:</p>
 <pre>
<code>if #available(macOS 9999, iOS 9999, watchOS 9999, tvOS 9999, *) {</code>
<code>  expectTrue(isP(CFBitVector.makeImmutable(from: [10, 20])))</code>
<code>  expectTrue(isP(CFMutableBitVector.makeMutable(from: [10, 20])))</code>
<code>}</code>
</pre>
 <p>You can also lock types to work only when used in a very distant future, although that might not be really useful unless you're trying to predict future features, I guess.</p>
 <pre>
<code>@available(iOS, introduced: 999)</code>
<code>final class HologramCreator {}</code>
<code></code>
<code>HologramCreator()</code>
<code>// 'HologramCreator' is only available in iOS 999 or newer</code>
</pre>
 <h2>How Availability works in the Swift Compiler</h2>
 <p>In the compiler, the availability of symbols is treated during the type-checking phase.</p>
 <div class="post-image margin-top-40 margin-bottom-40"> 
  <img src="https://i.imgur.com/xbVOfbq.png" alt="" style="background-color: #fff;"> 
 </div>
 <p>If you haven't read my previous articles or need a refresher, the type-checking phase is when the compiler wants to determine if what you coded semantically correct. At this stage, the compiler has a basic <b>Abstract Syntax Tree</b> of your code that it knows to be correct in terms of structure, but it needs to know if what you're doing is actually possible. For example, does the type you're referencing actually contains the method you're calling? Are the return types correct?</p>
 <h3>Type Refinement Contexts for AST nodes</h3>
 <p>Naturally, checking if a symbol you're calling is available for usage falls into that phase. The compiler does it by building <b>Type Refinement Contexts</b>, which is a special structure that can hold any relevant additional information that a scope should have. Currently, this is only used for the very symbol availability we're interested in.</p>
 <p>The process starts when the compiler wants to type-check a statement that contains an availability check. Let's take this one as an example:</p>
 <pre>
<code>if #available(iOS 14.0, *) {</code>
<code></code>
<code>} else {</code>
<code></code>
<code>}</code>
</pre>
 <p>At this phase, the purpose of the compiler is to search for any availability conditions and build a proper refinement context if needed. For every condition, the compiler will extract the currently-being-built platform from the condition and attempt to build a <i>range</i> of available version numbers. In this case, the range will simply be <code>minimumTarget...iOS 14</code>, while the else branch will keep whatever its parent refinement context was unless your condition is checking for some <i>lower</i> than the current context (which would reduce it instead). The main refinement context allows you to freely use anything up to your app's minimum deployment target, which is why you don't need to bother with these checks when you have a sufficiently high deployment target.</p>
 <pre>
<code>if #available(iOS 14.0, *) {</code>
<code> // Symbol Availability: minimumTarget...iOS 14</code>
<code>} else {</code>
<code> // Symbol Availability: 0...minimumTarget (The default)</code>
<code>}</code>
</pre>
 <p>The fact that it works with ranges makes it possible for it to locate potentially useless checks. If a condition's range is completely contained by the current context, the compiler will ignore it and display a warning.</p>
 <pre>
<code>if #available(iOS 14.0, *), #available(iOS 13.0, *) {</code>
<code> // (iOS 13.0) Unnecessary check for 'iOS'; enclosing scope ensures guard will always be true</code>
<code> // Symbol Availability: minimumTarget...iOS 14</code>
<code>} else {</code>
<code> // Symbol Availability: 0...minimumTarget (The default)</code>
<code>}</code>
</pre>
 <p>When the refinement contexts for each scope are determined, the compiler will associate it with the current statement's AST node and use it for any future availability checks. The refinement contexts are built like trees (where a context has a pointer to its parent), but they are used as a stack. As the compiler traverses your code, these refinement contexts will get pushed and popped as needed.</p>
 <pre>
<code>if #available(iOS 9.0, *) {</code>
<code>  // Symbol Availability: minimumTarget...iOS 9</code>
<code>  if #available(iOS 13.0, *) {</code>
<code>    // Symbol Availability: minimumTarget...iOS 13</code>
<code>  } else {</code>
<code>    // Symbol Availability: minimumTarget...iOS 9</code>
<code>  }</code>
<code>} else {</code>
<code>  // Symbol Availability: 0...minimumTarget (The default)</code>
<code>}</code>
</pre>
 <p>While the outer else scope will make no changes to availability, the inner else scope will keep the increased iOS 9 availability as that was the current refinement context at the time. Here's a visual example of how this works in practice:</p>
 <pre>
<code>// Refinement Context Stack: [MinimumTarget]</code>
<code>if #available(iOS 9.0, *) {</code>
<code>  // Push: iOS 9 ([MinimumTarget, iOS 9])</code>
<code>  if #available(iOS 13.0, *) {</code>
<code>    // Push: iOS 13 ([MinimumTarget, iOS 9, iOS 13])</code>
<code>  } else {</code>
<code>    // Pop: iOS 13 ([MinimumTarget, iOS 9])</code>
<code>  }</code>
<code>} else {</code>
<code>  // Pop: iOS 9 ([MinimumTarget])</code>
<code>}</code>
</pre>
 <p>Everything shown here also applies for <code>guard</code> statements, except in that case the positive availability changes are applied in what's left of the current scope.</p>
 <pre>
<code>guard #available(iOS 14, *) else {</code>
<code>    // Symbol Availability: 0...minimumTarget (The default)</code>
<code>    return</code>
<code>}</code>
<code>// Symbol Availability: minimumTarget...iOS 14</code>
</pre>
 <p>This process involving refinement contexts is precisely why you can't use availability conditions outside of statements like this:</p>
 <pre>
<code>let isAvailable: Bool = #available(iOS 13.0, *)</code>
<code>if isAvailable {</code>
<code>  // ?????</code>
<code>}</code>
<code>// error: #available may only be used as condition of an 'if', 'guard' or 'while' statement</code>
</pre>
 <p>Even though doing something like this might make sense at first glace, what should be the symbol availability of that <code>if</code> statement? Something like this would be incredibly hard to process as now every boolean you create must also have its own refinement context, and would lead to many situations where the compiler wouldn't be able to process something that a human being can visualize as being possible.</p>
 <h2>Determining if a symbol is available</h2>
 <p>With the type refinement contexts created, the compiler can check if something is available by matching its current availability status with the top context in the refinement stack. The availability of the declaration in question is determined by the presence of the <code>@availability</code> attribute in its type. If there's none, the type will always be available.</p>
 <pre>
<code>Optional&lt;AvailabilityContext&gt; AnnotatedRange = annotatedAvailableRange(D, Ctx);</code>
<code>if (AnnotatedRange.hasValue()) {</code>
<code>  return AnnotatedRange.getValue();</code>
<code>}</code>
<code></code>
<code>// Treat unannotated declarations as always available.</code>
<code>return AvailabilityContext::alwaysAvailable();</code>
</pre>
 <p>To check whether or not this specific declaration is available, the compiler retrieves the current refinement context of the declaration and checks if it's contained by the declaration's own availability range. This is where an app's minimum deployment target comes into play: If there's no refinement context (because no availability conditions have been seen yet), the compiler will build one that has it as the maximum available version. Finally, if this availability check returns false, the compiler will emit an error and suggest a fix-it that includes adding an availability condition.</p>
 <pre>
<code>// Code sligthly changed for readability purposes</code>
<code>bool TypeChecker::isDeclAvailable(const Decl *D,</code>
<code>                                  const DeclContext *referenceDC) {</code>
<code></code>
<code>  ASTContext &amp;Context = referenceDC-&gt;getASTContext();</code>
<code></code>
<code>  AvailabilityContext declAvailability{</code>
<code>      AvailabilityInference::availableRange(D, Context)};</code>
<code>  AvailabilityContext currentAvailability =</code>
<code>      overApproximateAvailabilityAtLocation(referenceDC);</code>
<code></code>
<code>  return currentAvailability.isContainedIn(declAvailability);</code>
<code>}</code>
</pre>
 <p>Additionally, if you're building something outside of Xcode, the minimum deployment target will be the current version of whatever it is that you're doing. For example, when running <code>.swift</code> scripts, the "minimum deployment target" will be your macOS's version.</p>
 <pre>
<code>/// Returns the minimum platform version to which code will be deployed.</code>
<code>///</code>
<code>/// This is only implemented on certain OSs. If no target has been</code>
<code>/// configured, returns v0.0.0.</code>
<code>llvm::VersionTuple getMinPlatformVersion() const {</code>
<code>  unsigned major = 0, minor = 0, revision = 0;</code>
<code>  if (Target.isMacOSX()) {</code>
<code>    Target.getMacOSXVersion(major, minor, revision);</code>
<code>  } else if (Target.isiOS()) {</code>
<code>    Target.getiOSVersion(major, minor, revision);</code>
<code>  } else if (Target.isWatchOS()) {</code>
<code>    Target.getOSVersion(major, minor, revision);</code>
<code>  }</code>
<code>  return llvm::VersionTuple(major, minor, revision);</code>
<code>}</code>
</pre>
 <h2>Translating <code>#available</code> to a boolean</h2>
 <p>Finally, after determining that our code is structurally and semantically correct, the compiler can wrap up by swapping the availability conditions with actual booleans. Currently, this works by replacing your statement with a call to <code>_stdlib_isOSVersionAtLeast</code> that receives the version range calculated and stored in each refinement context and returns a boolean if the current device is running the desired version.</p>
 <pre>
<code>// Before</code>
<code>if #available(iOS 14.0, *) {</code>
<code></code>
<code>}</code>
<code></code>
<code>// After</code>
<code>if _stdlib_isOSVersionAtLeast(14, 0, 0)</code>
<code></code>
<code>}</code>
</pre>
 <p>As you would expect, <code>_stdlib_isOSVersionAtLeast</code> works by determining the current OS version and checking if it matches the provided value. Here's how the compiler tries to determine the current iOS version:</p>
 <pre>
<code>static os_system_version_s getOSVersion() {</code>
<code>  auto lookup =</code>
<code>    (int(*)(struct os_system_version_s * _Nonnull))</code>
<code>    dlsym(RTLD_DEFAULT, "os_system_version_get_current_version");</code>
<code></code>
<code>  struct os_system_version_s vers = { 0, 0, 0 };</code>
<code>  lookup(&amp;vers);</code>
<code>  return vers;</code>
<code>}</code>
</pre>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>If you'd like to see this happening in practice, you can ask the compiler to emit the Swift Intermediate Language for a certain code like this:</p>
 <pre class="command-line language-bash" data-host="SwiftRocks">
<code>swiftc -emit-sil myFile.swift</code>
</pre>
 <p>After running it, you can see all availability conditions being replaced by the lower-level OS version check.</p>
 <pre>
<code>// function_ref _stdlib_isOSVersionAtLeast(_:_:_:)</code>
<code>%5 = function_ref @$ss26_stdlib_isOSVersionAtLeastyBi1_Bw_BwBwtF</code>
</pre>
 <h2>References and Good reads</h2>
 <a href="https://github.com/apple/swift">The Swift Source Code</a>
 <br>
 <a href="https://github.com/apple/swift/blob/9af806e8fd93df3499b1811deae7729176879cb0/lib/Sema/TypeCheckAvailability.cpp#L400">TypeCheckAvailability.cpp</a>
 <br>
 <a href="https://github.com/apple/swift-evolution/pull/1184">SE-NNNN: Unavailability Condition</a>
 <br>
</div>]]></description>
</item>
<item>
    <title>UI Testing Deeplinks and Universal Links in iOS</title>
    <link>https://swiftrocks.com/ui-testing-deeplinks-and-universal-links-in-ios</link>
    <guid>https://swiftrocks.com/ui-testing-deeplinks-and-universal-links-in-ios</guid>
    <pubDate>Tue, 15 Sep 2020 09:00:00 GMT-3</pubDate>
<description><![CDATA[
 
  
  <!--WRITEIT_POST_NAME=UI Testing Deeplinks and Universal Links in iOS--> 
  <!--WRITEIT_POST_HTML_NAME=ui-testing-deeplinks-and-universal-links-in-ios--> 
  <!--Add here the additional properties that you want each page to possess.--> 
  <!--These properties can be used to change content in the template page or in the page itself as shown here.--> 
  <!--Properties must start with 'WRITEIT_POST'.--> 
  <!--Writeit provides and injects WRITEIT_POST_NAME and WRITEIT_POST_HTML_NAME by default.--> 
  <!--WRITEIT_POST_SHORT_DESCRIPTION=Did you know it's possible to terminate your app in the middle of an XCUITest and launch it again from somewhere else? Let's see how to use this trick to test that deeplinks and universal links are properly launching our app when executed from Safari or iMessage.--> 
  <!--WRITEIT_POST_SITEMAP_DATE_LAST_MOD=2020-09-15T14:00:00+02:00--> 
  <!--WRITEIT_POST_SITEMAP_DATE=2020-09-15T14:00:00+02:00--> 
  <title>UI Testing Deeplinks and Universal Links in iOS</title>  
 

<div class="blog-post"> 
 <div class="post-title-index">  
  <h1>UI Testing Deeplinks and Universal Links in iOS</h1>
 </div> 
 <div class="post-info"> 
  <div class="category category-ios">
   iOS
  </div> 
  <div class="post-info-text">
   Published on 15 Sep 2020 
  </div> 
 </div>  
 <p>Did you know it's possible to terminate your app in the <i>middle</i> of an XCUITest and launch it again from somewhere else? Let's see how to use this trick to test that deeplinks and universal links are properly launching our app when executed from Safari or iMessage.</p>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>It's tricky to test iOS features because while you can write unit tests to guarantee that your abstraction of it works, you can't really unit test that iOS will correctly call what you think will be called. In the case of deeplinks, what iOS does differs depending on what's the current state of your app (closed or in background) and which delegates you support (AppDelegate versus SceneDelegates), which commonly leads to very confusing bug reports in the point of view of the developer who isn't aware of this fact.</p>
 <p>But unless you're for some reason not supporting iOS 11 in 2020, you can perfectly test "app launch" related features and any other AppDelegate/SceneDelegate related feature through UI Tests. This is because it was in iOS 11 where XCUI started supporting the ability to <b>launch and control system apps</b>. Today, we can make a test that boots Safari, types an URL and deeplinks back to our app. We can even terminate our app (which doesn't stop the test!) to check that our app behaves correctly if it's <i>launched</i> from said deeplink!</p>
 <h2>UI Testing Deeplinks (from a backgrounded app)</h2>
 <p>To begin, let's UI test a Safari deeplink when our app is already running in the background.</p>
 <p>Launching other apps in the middle of a UI test is similar to launching our own, with the simple difference that you pass a different bundle identifier instead. In the case of Safari, the bundle identifier is <code>"com.apple.mobilesafari"</code>:</p>
 <pre>
<code>func testDeeplinkFromSafari() {</code>
<code>    let app = XCUIApplication()</code>
<code>    app.launch()</code>
<code>    let safari = XCUIApplication(bundleIdentifier: "com.apple.mobilesafari")</code>
<code>    safari.launch()</code>
<code>}</code>
</pre>
 <p>If you run this, you'll get a simple test that launches your app and switches to Safari right after.</p>
 <p>Now, to deeplink back to our app, we can control Safari just like we would in a regular UI test. In this case, we can grab a hold of the address bar, type our link and press the "go" button. If everything works correctly Safari will deeplink back to our app, allowing us to assert that the deeplink logic in our app is working as expected.</p>
 <pre>
<code>func testDeeplinkFromSafari() {</code>
<code>    // Launch our app</code>
<code>    let app = XCUIApplication()</code>
<code>    app.launch()</code>
<code>    // Launch Safari and deeplink back to our app</code>
<code>    openFromSafari("swiftrocks://profile")</code>
<code>    // Make sure Safari properly switched back to our app before asserting</code>
<code>    XCTAssert(app.wait(for: .runningForeground, timeout: 5))</code>
<code>    // Assert that the deeplink worked by checking if we're in the "Profile" screen</code>
<code>    XCTAssertTrue(app.navigationBars["Profile"].exists)</code>
<code>}</code>
<code></code>
<code>private func openFromSafari(_ urlString: String) {</code>
<code>    let safari = XCUIApplication(bundleIdentifier: "com.apple.mobilesafari")</code>
<code>    safari.launch()</code>
<code>    // Make sure Safari is really running before asserting</code>
<code>    XCTAssert(safari.wait(for: .runningForeground, timeout: 5))</code>
<code>    // Type the deeplink and execute it</code>
<code>    let firstLaunchContinueButton = safari.buttons["Continue"]</code>
<code>    if firstLaunchContinueButton.exists {</code>
<code>        firstLaunchContinueButton.tap()</code>
<code>    }</code>
<code>    safari.buttons["URL"].tap()</code>
<code>    let keyboardTutorialButton = safari.buttons["Continue"]</code>
<code>    if keyboardTutorialButton.exists {</code>
<code>        keyboardTutorialButton.tap()</code>
<code>    }</code>
<code>    safari.typeText(urlString)</code>
<code>    safari.buttons["Go"].tap()</code>
<code>    _ = confirmationButton.waitForExistence(timeout: 2)</code>
<code>    if confirmationButton.exists {</code>
<code>        confirmationButton.tap()</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>It's good to add the additional <code>wait(for: .runningForeground)</code> assertion for safety as that makes the test check that the app switching actually worked before attempting to assert anything else. If it fails for some reason, you'll know it was because the app failed to switch instead of something not being present in the UI of your app.</p>
 <p>You may also notice that there's some additional logic in our Safari handling; Safari sometimes shows a "What's new" screen, which we treat by first finding and tapping the <code>"Continue"</code> button, if it exists, which can also happen when opening the keyboard for the same time. Additionally, when executing deeplinks you might sometimes get a "Open in X?" confirmation, which is treated by finding and tapping the <code>"Open"</code> button.</p>
 <h2>UI Testing Deeplinks (that launches the app / from a killed app)</h2>
 <p>The issue I faced that prompted me to write this article is that iOS processes deeplinks differently according to the current state of the app. For example, in SceneDelegates, deeplinks will trigger your <code>scene(_:openURLContexts:)</code> method, but if the app is <b>launched</b> as a result of the deeplink, no method is called. Instead, you need to access it from the <code>urlContexts</code> property of your scene. Thus, when UI testing, you also need to have a test that operates on an app that is <b>not</b> running.</p>
 <p>One may think that a UI test would fail if your app terminates, but that's actually not the case! You can make a test that terminates and reboots an app as much as you like by using these special methods from <code>XCUIApplication</code>:</p>
 <pre>
<code>app.launch() // Launches the app (or reboots it/launches it again)</code>
<code>app.terminate() // Terminates the app (which does not stops the test!)</code>
<code>app.activate() // Puts the app in the foreground, if it was backgrounded</code>
</pre>
 <p>As mentioned, if you terminate the app, you're free to launch it again in the same test. It's not necessary to reassign your <code>XCUIApplication</code> instance -- all assertions will work normally as if the app was never terminated in the first place.</p>
 <p>Thus, to test that our deeplinks work correctly when the app <b>isn't</b> launched, we can simply close the app before opening Safari. It's not necessary to launch it again, as that will happen naturally as iOS attempts to open our deeplink.</p>
 <pre>
<code>func testDeeplinkFromSafari_fromBackgroundedApp() {</code>
<code>    openSafariDeeplink(terminateFirst: false)</code>
<code>}</code>
<code></code>
<code>func testDeeplinkFromSafari_thatLaunchesTheApp() {</code>
<code>    openSafariDeeplink(terminateFirst: true)</code>
<code>}</code>
<code></code>
<code>func openSafariDeeplink(terminateFirst: Bool) {</code>
<code>    let app = XCUIApplication()</code>
<code>    app.launch()</code>
<code></code>
<code>    if terminateFirst {</code>
<code>        app.terminate()</code>
<code>    }</code>
<code></code>
<code>    // Launch Safari and deeplink back to our app</code>
<code>    openFromSafari("swiftrocks://profile")</code>
<code>    // Make sure Safari properly switched back to our app before asserting</code>
<code>    XCTAssert(app.wait(for: .runningForeground, timeout: 5))</code>
<code>    // Assert that the deeplink worked by checking if we're in the "Profile" screen</code>
<code>    XCTAssertTrue(app.navigationBars["Profile"].exists)</code>
<code>}</code>
</pre>
 <p>An alternative for this is to simply never call <code>app.launch()</code>, but personally I had mixed results with it. Launching the app also installs it, so never launching it resulted in flaky tests. Launching and terminating it however works 100% of the time.</p>
 <h2>UI Testing Universal Links (from a backgrounded app)</h2>
 <p>The testing process of universal links is very similar to the deeplinks' one, with an important difference: for some <i>god knows why</i> reason, universal links don't work in the simulator's Safari. It's unclear if that's on purpose or if it's really a bug, but while universal links work fine on your device's Safari, they will not work on the simulator's one.</p>
 <p>This means we unfortunately can't use our Safari wrapper for them, but luckily you can still test universal links by using the <b>Messages</b> app. We can then test our universal links by opening the Messages app, clicking on a contact, sending them a universal link and tapping the newly sent message's link bubble to trigger it.</p>
 <p>To launch Messages, we use the bundle identifier <code>"com.apple.MobileSMS"</code>.</p>
 <pre>
<code>private func openFromMessages(_ urlString: String) {</code>
<code>    let messages = XCUIApplication(bundleIdentifier: "com.apple.MobileSMS")</code>
<code>    messages.launch()</code>
<code>    XCTAssert(messages.wait(for: .runningForeground, timeout: 5))</code>
<code></code>
<code>    // Dismiss "What's New" if needed</code>
<code>    let continueButton = messages.buttons["Continue"]</code>
<code>    if continueButton.exists {</code>
<code>        continueButton.tap()</code>
<code>    }</code>
<code>    // Dismiss iOS 13's "New Messages" if needed</code>
<code>    let cancelButton = messages.navigationBars.buttons["Cancel"]</code>
<code>    if cancelButton.exists {</code>
<code>        cancelButton.tap()</code>
<code>    }</code>
<code></code>
<code>    // Open the first available chat</code>
<code>    let chat = messages.cells.firstMatch</code>
<code>    XCTAssertTrue(chat.waitForExistence(timeout: 5))</code>
<code>    chat.tap()</code>
<code>    // Tap the text field</code>
<code>    messages.textFields["iMessage"].tap()</code>
<code></code>
<code>    // Dismiss Keyboard tutorial if needed</code>
<code>    let keyboardTutorialButton = messages.buttons["Continue"]</code>
<code>    if keyboardTutorialButton.exists {</code>
<code>        keyboardTutorialButton.tap()</code>
<code>    }</code>
<code></code>
<code>    messages.typeText("Link: \(urlString)")</code>
<code>    messages.buttons["sendButton"].tap()</code>
<code></code>
<code>    let bubble = messages.links.firstMatch</code>
<code>    XCTAssertTrue(bubble.waitForExistence(timeout: 5))</code>
<code>    sleep(3)</code>
<code>    bubble.tap()</code>
<code>}</code>
</pre>
 <p>The logic to open a link from Messages is a little longer because it sometimes takes a couple more taps before being able to click our link. In this case, we may need to dismiss up to three 3 onboarding screens before being able to send a message. Additionally, before tapping the link, we <code>sleep(3)</code> to give iOS enough time to load our app's metadata. If you don't wait, sometimes iOS will fail to properly open your app.</p>
 <p>The result, however, is the same from when we tested deeplinks in Safari. When you call this method, iOS will switch to Messages and attempt to switch back to your app via your universal link.</p>
 <pre>
<code>func testUniversalLinkFromMessages() {</code>
<code>    // Launch our app</code>
<code>    let app = XCUIApplication()</code>
<code>    app.launch()</code>
<code>    // Launch Messages and univesal link back to our app</code>
<code>    openFromMessages("https://swiftrocks.com/profile")</code>
<code>    // Make sure Messages properly switched back to our app before asserting</code>
<code>    XCTAssert(app.wait(for: .runningForeground, timeout: 5))</code>
<code>    // Assert that the universal link worked by checking if we're in the "Profile" screen</code>
<code>    XCTAssertTrue(app.navigationBars["Profile"].exists)</code>
<code>}</code>
</pre>
 <h2>UI Testing Universal Links (that launches the app / from a killed app)</h2>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>Like with deeplinks, iOS's behavior differs slightly when launching your app as a result of tapping a universal link. When using SceneDelegates for example, you need to instead fetch them from a scene's <code>userActivities</code> property.</p>
 <p>To confirm that our app can properly handle this, we can use the same trick we used for the deeplinks and terminate our app before executing the test.</p>
 <pre>
<code>func testUniversalLinkFromMessages_fromBackgroundedApp() {</code>
<code>    openMessagesUniversalLink(terminateFirst: false)</code>
<code>}</code>
<code></code>
<code>func testUniversalLinkFromMessages_thatLaunchesTheApp() {</code>
<code>    openMessagesUniversalLink(terminateFirst: true)</code>
<code>}</code>
<code></code>
<code>func openMessagesUniversalLink(terminateFirst: Bool) {</code>
<code>    let app = XCUIApplication()</code>
<code>    app.launch()</code>
<code></code>
<code>    if terminateFirst {</code>
<code>        app.terminate()</code>
<code>    }</code>
<code></code>
<code>    // Launch Messages and univesal link back to our app</code>
<code>    openFromMessages("https://swiftrocks.com/profile")</code>
<code>    // Make sure Messages properly switched back to our app before asserting</code>
<code>    XCTAssert(app.wait(for: .runningForeground, timeout: 5))</code>
<code>    // Assert that the universal link worked by checking if we're in the "Profile" screen</code>
<code>    XCTAssertTrue(app.navigationBars["Profile"].exists)</code>
<code>}</code>
</pre>
</div>]]></description>
</item>
<item>
    <title>Improving Observer Pattern APIs in Swift With Weak Collections</title>
    <link>https://swiftrocks.com/improving-observer-pattern-apis-in-swift-with-weak-collections</link>
    <guid>https://swiftrocks.com/improving-observer-pattern-apis-in-swift-with-weak-collections</guid>
    <pubDate>Tue, 25 Aug 2020 09:00:00 GMT-3</pubDate>
<description><![CDATA[
 
  
  <!--WRITEIT_POST_NAME=Improving Observer Pattern APIs in Swift With Weak Collections--> 
  <!--WRITEIT_POST_HTML_NAME=improving-observer-pattern-apis-in-swift-with-weak-collections--> 
  <!--Add here the additional properties that you want each page to possess.--> 
  <!--These properties can be used to change content in the template page or in the page itself as shown here.--> 
  <!--Properties must start with 'WRITEIT_POST'.--> 
  <!--Writeit provides and injects WRITEIT_POST_NAME and WRITEIT_POST_HTML_NAME by default.--> 
  <!--WRITEIT_POST_SHORT_DESCRIPTION=In this article, I'll show you a memory management trick with some old-school Foundation types that can be used in any object that applies the Observer pattern to create better and safer APIs.--> 
  <!--WRITEIT_POST_SITEMAP_DATE_LAST_MOD=2020-08-25T14:00:00+02:00--> 
  <!--WRITEIT_POST_SITEMAP_DATE=2020-08-25T14:00:00+02:00--> 
  <title>Improving Observer Pattern APIs in Swift With Weak Collections</title>  
 

<div class="blog-post"> 
 <div class="post-title-index">  
  <h1>Improving Observer Pattern APIs in Swift With Weak Collections</h1>
 </div> 
 <div class="post-info"> 
  <div class="category category-swift">
   Swift
  </div> 
  <div class="post-info-text">
   Published on 25 Aug 2020 
  </div> 
 </div>   
 <p>Even if you don't know what the <b>Observer</b> pattern is, there's a good chance that you applied it somewhere in the past. This design pattern is used to create APIs that notify one or more subjects about changes in a certain object, with the <code>NotificationCenter</code> being the most popular use of this pattern in iOS.</p>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>One simple way to reproduce what the <code>NotificationCenter</code> does is to create a dictionary that maps a string (a notification) to an array of closures. Whenever that notification is "posted", all of the closures are executed.</p>
 <pre>
<code>final class NotificationCenter {</code>
<code></code>
<code>    var notifications = [String: [() -&gt; Void]]()</code>
<code></code>
<code>    func register(_ closure: @escaping () -&gt; Void, forNotification string: String) {</code>
<code>        notifications[string, default: []].append(closure)</code>
<code>    }</code>
<code></code>
<code>    func post(notification: String) {</code>
<code>        notifications[notification]?.forEach { $0() }</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>However, the point of this article is not to attempt to reproduce the <code>NotificationCenter</code>, but to show you <b>what</b> this implementation implies. You must be aware that whenever you're using the basic Swift dictionaries, arrays or sets, <b>all keys and values are retained!</b> Additionally, you need to be aware that <b>closures are reference types</b>, so they are retained as well and can outlive their owners.</p>
 <p>What this means is that you'll see that while this implementation works, it's going to be a huge memory issue. Because it's retaining the closures, they will never be unregistered. The notifications will attempt to execute them even if the object that registered it is <b>long gone</b>.</p>
 <p>If you're been working with iOS for a long time, you might remember that iOS's own <code>NotificationCenter</code> had this issue! Prior to iOS 9, every observer had to be unregistered when being deallocated, because if you didn't, it would attempt to execute it when it shouldn't and crash your app.</p>
 <pre>
<code>deinit {</code>
<code>    NotificationCenter.default.removeObserver(self, ...)</code>
<code>}</code>
</pre>
 <p>In the case of our implementation, we could replicate this by adding the concept of "owners" to our closures, so that we are able to remove them if someone wishes to be unregistered. Fortunately, not only we don't need to go this far, but it's good if we don't. If you're developing an API, its usability should be one of your main priorities. In this case, let's take a look at how we can create an observer API that <b>is</b> memory safe while also <b>not having</b> to manually unregister the observers. The problem shown above that <code>NotificationCenter</code> had was fixed in iOS 9 (removing observers became an automatic process) when Apple started applying the same concept.</p>
 <h2>Weak Collections</h2>
 <p>Let's pretend we have a deeplink-based navigation system where "feature providers" can provide a feature (represented as an <code>UIViewController</code>) if they recognize the deeplink that the app wants to present:</p>
 <pre>
<code>final class FeaturePusher {</code>
<code></code>
<code>    typealias FeatureProvider = (URL) -&gt; UIViewController?</code>
<code></code>
<code>    lazy var providers = [FeatureProvider]()</code>
<code></code>
<code>    func register(featureProvider: @escaping FeatureProvider) {</code>
<code>        providers.append(featureProvider)</code>
<code>    }</code>
<code></code>
<code>    func feature(forUrl url: URL) -&gt; UIViewController? {</code>
<code>        return providers.lazy.compactMap { $0(url) }.first</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>Like in the notification center example, this suffers from a memory issue. If whoever provided those closures ceases to exist, the <code>FeaturePusher</code> class will still be able to execute the closure and potentially crash the app. Fortunately, there are a few useful types in <code>Foundation</code> that can assist us in improving that.</p>
 <p>As I've shown before in my <a href="https://swiftrocks.com/weak-dictionary-values-in-swift">Weak Dictionary Values</a> article, <code>Foundation</code> offers a series of lower-level Obj-C collection types that are more powerful than the basic Swift ones. Two of them specifically are <code>NSMapTable</code> and <code>NSHashTable</code>, which are Obj-C versions of <code>Dictionary</code> and <code>Set</code>, respectively. Both of them allow a higher range of memory management options, which include weak references for both values and keys. If instead of using a base Swift array we used a <code>NSMapTable</code> that has our closures as values and <b>weak</b> references to whoever provided that block as a key, our navigation system would automatically evict and deallocate the closures whenever the related providers are deallocated. That's because in weak collections if the weak component is deallocated, the entire entry will be evicted from the collection.</p>
 <p>Creating Weak Collections is just a matter of using the correct initializer. A dictionary with weak keys can be initialized with <code>NSMapTable.weakToStrongObjects()</code>, while one with weak values can be initialized with <code>NSMapTable.strongToWeakObjects()</code>. If we want our navigation system's closures to be automatically unregistered if the object that registered them was deallocated, we can create a weak-keyed dictionary that maps an object to an array of closures:</p>
 <pre>
<code>lazy var providers = NSMapTable&lt;AnyObject, NSHashTable&lt;FeatureProviderBox&gt;&gt;.weakToStrongObjects()</code>
</pre>
 <p>Because the keys are weak, the closures will automatically be evicted from the dictionary if the key ceases to exist.</p>
 <p>Note that <code>NSMapTable</code> is an Obj-C API, so all keys and values must be class objects. That's why we have to use a <code>NSHashTable</code> as a value instead of a regular <code>Set</code> or <code>Array</code>.</p>
 <p>You can make Obj-C types like <code>NSMapTable</code> able to hold Swift structs by creating a generic <code>Box</code> class wrapper type. Here, we create one to be able to represent our feature closure as a class object (<code>FeatureProviderBox</code>) in order to be able to store it inside the <code>NSHashTable</code>.</p>
 <pre>
<code>final class Box&lt;T&gt; {</code>
<code>    let obj: T</code>
<code>    init(obj: T) {</code>
<code>        self.obj = obj</code>
<code>    }</code>
<code>}</code>
<code></code>
<code>final class FeaturePusher {</code>
<code></code>
<code>    typealias FeatureProvider = (URL) -&gt; UIViewController?</code>
<code>    typealias FeatureProviderBox = Box&lt;FeatureProvider&gt;</code>
<code></code>
<code>    lazy var providers = NSMapTable&lt;AnyObject, NSHashTable&lt;FeatureProviderBox&gt;&gt;.weakToStrongObjects()</code>
<code></code>
<code>    func register(featureProvider: @escaping FeatureProvider, forObject object: AnyObject) {</code>
<code>        if providers.object(forKey: object) == nil {</code>
<code>            providers.setObject(NSHashTable(), forKey: object)</code>
<code>        }</code>
<code>        let box = FeatureProviderBox(obj: featureProvider)</code>
<code>        providers.object(forKey: object)?.add(box)</code>
<code>    }</code>
<code></code>
<code>    func feature(forUrl url: URL) -&gt; UIViewController? {</code>
<code>        let allValues = providers.objectEnumerator()</code>
<code>        while let table = allValues?.nextObject() as? NSHashTable&lt;FeatureProviderBox&gt; {</code>
<code>            if let feature = table.allObjects.lazy.compactMap { $0.obj(url) }.first {</code>
<code>                return feature</code>
<code>            }</code>
<code>        }</code>
<code>        return nil</code>
<code>    }</code>
<code>}</code>
</pre>
 <h2>Unit Testing Weak Collections (and Reference Cycles)</h2>
 <p>To check if our improvement worked, we can create a unit test that checks if the correct view controllers are returned:</p>
 <pre>
<code>func test_observerReturnsTheCorrectFeature() {</code>
<code></code>
<code>    let pusher = FeaturePusher()</code>
<code>    let swiftRocksUrl = URL(string: "myApp://swiftRocks")!</code>
<code>    let swiftRocksVC = SwiftRocksViewController()</code>
<code></code>
<code>    let observerObject: UIView = UIView()</code>
<code></code>
<code>    pusher.register(featureProvider: { url in</code>
<code>        return url == swiftRocksUrl ? swiftRocksVC : nil</code>
<code>    }, forObject: observerObject)</code>
<code></code>
<code>    XCTAssertTrue(pusher.feature(forUrl: swiftRocksUrl) === swiftRocksVC)</code>
<code></code>
<code>    let someOtherURL = URL(string: "myApp://notSwiftRocks")!</code>
<code>    XCTAssertNil(pusher.feature(forUrl: someOtherURL))</code>
<code>}</code>
</pre>
 <p>However, we are mostly interested in seeing if the automatic eviction is working. To test that the observers are being deallocated and the closures are being evicted, we can use an <code>autoreleasepool</code>. As described in my <a href="https://swiftrocks.com/autoreleasepool-in-2019-swift">autoreleasepool article</a>, you can use a pool whenever you want something to be deallocated as soon as possible:</p>
 <pre>
<code>func test_observerIsDeallocated() {</code>
<code></code>
<code>    let pusher = FeaturePusher()</code>
<code>    let swiftRocksUrl = URL(string: "myApp://swiftRocks")!</code>
<code>    let swiftRocksVC = SwiftRocksViewController()</code>
<code></code>
<code>    autoreleasepool {</code>
<code>        let observerObject: UIView = UIView()</code>
<code></code>
<code>        pusher.register(featureProvider: { url in</code>
<code>            return url == swiftRocksUrl ? swiftRocksVC : nil</code>
<code>        }, forObject: observerObject)</code>
<code></code>
<code>        XCTAssertTrue(pusher.feature(forUrl: swiftRocksUrl) === swiftRocksVC)</code>
<code></code>
<code>        let someOtherURL = URL(string: "myApp://notSwiftRocks")!</code>
<code>        XCTAssertNil(pusher.feature(forUrl: someOtherURL))</code>
<code>    }</code>
<code></code>
<code>    XCTAssertNil(pusher.feature(forUrl: swiftRocksUrl))</code>
<code>}</code>
</pre>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>You'll see that this test will pass, but if you're not sure why, try removing the pool to see what happens. The test will fail, and the reason is that objects aren't deallocated as soon as they go out of scope in iOS (that will usually happen at the end of a <code>RunLoop</code>). In this case, the pool is simply a way to force it to deallocate immediately for unit testing purposes. This same trick can be applied to unit test any type of reference cycle situation :)</p>
 <h2>Conclusion: Final considerations for Weak Collections</h2>
 <p>Weak Collections are a great way to build better APIs, but you must be aware of their possible limitations. While types like <code>NSHashTable</code> and <code>NSPointerArray</code> are all-around great tools, you may see that <code>NSMapTable</code>'s documentation tells you to be careful with <code>weakToStrongObjects()</code>. In that configuration, although the values are ejected from the table as expected, they still may be held in memory for a larger period of time. That's why this article didn't attempt to fully reproduce the NotificationCenter, as <a href="https://forums.swift.org/t/why-is-this-unreferenced-object-refusing-to-deallocate/39604?u=rockbruno">it took me a while to realize that doing so would require a pretty ugly workaround.</a> However, you'll find that <code>NSHashTable</code> is good to go under any configuration.</p>
 <h2>References and Good Reads</h2>
 <a href="https://swiftrocks.com/weak-dictionary-values-in-swift">Weak Dictionary Values (SwiftRocks)</a>
 <br>
 <a href="https://swiftrocks.com/autoreleasepool-in-2019-swift">@autoreleasepool uses in 2019 Swift (SwiftRocks)</a>
 <br>
</div>]]></description>
</item>
<item>
    <title>App Attest: How to prevent an iOS app's APIs from being abused</title>
    <link>https://swiftrocks.com/app-attest-apple-protect-ios-jailbreak</link>
    <guid>https://swiftrocks.com/app-attest-apple-protect-ios-jailbreak</guid>
    <pubDate>Tue, 11 Aug 2020 09:00:00 GMT-3</pubDate>
<description><![CDATA[
 
  
  <!--WRITEIT_POST_NAME=App Attest: How to prevent an iOS app's APIs from being abused--> 
  <!--WRITEIT_POST_HTML_NAME=app-attest-apple-protect-ios-jailbreak--> 
  <!--Add here the additional properties that you want each page to possess.--> 
  <!--These properties can be used to change content in the template page or in the page itself as shown here.--> 
  <!--Properties must start with 'WRITEIT_POST'.--> 
  <!--Writeit provides and injects WRITEIT_POST_NAME and WRITEIT_POST_HTML_NAME by default.--> 
  <!--WRITEIT_POST_SHORT_DESCRIPTION=As (possibly) a response to jailbreaking become popular again in recent times, Apple has released their own solution to hackers creating compromised versions of your app.--> 
  <!--WRITEIT_POST_SITEMAP_DATE_LAST_MOD=2020-08-11T14:00:00+02:00--> 
  <!--WRITEIT_POST_SITEMAP_DATE=2020-08-11T14:00:00+02:00--> 
  <title>App Attest: How to prevent an iOS app's APIs from being abused</title>  
 

<div class="blog-post"> 
 <div class="post-title-index">  
  <h1>App Attest: How to prevent an iOS app's APIs from being abused</h1>
 </div> 
 <div class="post-info"> 
  <div class="category category-ios">
   iOS
  </div> 
  <div class="post-info-text">
   Published on 11 Aug 2020 
  </div> 
 </div>   
 <p>When jailbreaking of iOS devices first became popular, it was very common for iOS developers to try to defend their apps from users that altered their devices to enable piracy. There were many ways of doing that, which included checking for the existence of <b>Cydia</b>, checking if the app could read files outside its sandbox, crashing the app if it detects a debugger and more.</p>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>As time has shown, these "defensive" measures were and still are a really <b>bad</b> idea. If an attacker has physical access to the device, there's <b>no way</b> you can trust your app's logic. It was and still is trivial for hackers to "pretend" their devices were not jailbroken and effectively bypass these measures, and besides, having a jailbroken device doesn't mean the user wants to pirate content -- some people just want to have cooler looking home screens.</p>
 <p>As (possibly) a response to jailbreaking become popular again in recent times, Apple has released their own measure to this problem. In iOS 14, the new <b>App Attest</b> APIs provide you a way to sign server requests as an attempt to prove to your server that they came from an <b>unmodified</b> version of your app.</p>
 <p>It's important to know that <b>App Attest is not a "is this device jailbroken?" check</b>, as that has been proven over and over to be impossible to pinpoint. Instead, it aims to <b>protect server requests</b> in order to make it harder for hackers to create compromised versions of your app that unlock premium features or inserts features like cheats, while also adding a layer of protection against <b>replay attacks</b> against your server's APIs. Note the word <b>harder</b>: as jailbreakers have physical access to their devices, nothing will <b>completely</b> safe-guard you from fraud in this case.</p>
 <p>As you can't trust your app to protect itself, App Attest requires work on your backend to be fully implemented. I won't go through the backend part of it as this is a Swift blog, but will at least mention how it works to show how it wrap things together.</p>
 <h2>Generating a pair of keys to sign requests</h2>
 <p>App Attest works through the use of an asymmetric public/secret pair of encryption keys. The intention, in the end, is for your app to sign server requests with the secret key, send the data to the backend and have it confirm it to be true with the public one. If a hacker intercepts the request, it will not be able to alter its contents without making the backend's subsequent validation fail.</p>
 <p>To generate the keys, import the <code>DeviceCheck</code> framework and call the <code>generateKey</code> method from the <code>DCAppAttestService</code> singleton:</p>
 <pre>
<code>import DeviceCheck</code>
<code></code>
<code>let service = DCAppAttestService.shared</code>
<code>service.generateKey { (keyIdentifier, error) in</code>
<code>    guard error == nil else {</code>
<code>        return</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>The keys generated by App Attest are safely stored in your device's Security Enclave. As you can't directly access it, the result of this method will be a <code>keyIdentifier</code> property that allows iOS to find the keys when needed. You need to store it so you can later validate your app's requests.</p>
 <p>It's important to mention that App Attest is not supported by <b>all</b> types of devices, and if you look at Apple's own documentation, they will ask you to first check if it's supported and have your server support a fallback in case it's not:</p>
 <pre>
<code>if service.isSupported { ... }</code>
</pre>
 <p><b>Do not do this!</b> As said before, it's trivial for a jailbreak user to "pretend" their device doesn't support it. Apple doesn't expand on this topic, but the reasons for this check to exist appears to be that there are some Macbooks that don't have the necessary chip to support it. However, <a href="https://twitter.com/_inside/status/1291810797782544386">as investigated by Guilherme Rambo, it appears that every single iOS device supports it.</a> For an iOS app, you do not need to do a compatibility check.</p>
 <h2>Attesting: Sending the public key to the backend</h2>
 <p>In order to sign server requests, you need to provide your backend with a way to <b>confirm</b> that signature. This is done by giving the backend access to the public key we previously generated, but we can't simply create a request and add it as a parameter because it would be pretty easy for a hacker to intercept it and send their <b>own</b> public key instead, giving them full control of what your app sends to the backend.</p>
 <p>The solution to this problem is to ask Apple to <b>attest</b> that what the key we're sending originated from a uncompromised version of your app. This is done by calling the <code>attestKey</code> method, which receives the key's identifier as a parameter:</p>
 <pre>
<code>service.attestKey(keyIdentifier, clientDataHash: hash) { attestation, error in</code>
<code>    guard error == nil else { return }</code>
<code>    let attestationString = attestation?.base64EncodedString()</code>
<code>    // Send the attestation to the server. It now has access to the public key!</code>
<code>    // If it fails, throw the identifier away and start over.</code>
<code>}</code>
</pre>
 <p>This method accesses a remote Apple server, and the result is an "attestation" object that contains not only your public key, but a ton of information about your app that serves as a statement from Apple that the previously generated keys are not fake. When you receive this object, you must send it to your backend and have it perform several validations on it that allows it to confirm that it was unaltered. If the attestation object was successfully validated, the backend will be able to safely extract the app's public key from it.</p>
 <p>It's unclear if Apple attempts or not to check if the user's device if jailbroken during this process. It's never mentioned that this is the case, but they do say "App Attest can‚Äôt <b>definitively</b> pinpoint a device with a compromised operating system." which could imply that they at least <b>try</b> something. It's probably safe to assume that this is not the case, and the word attest here simply means that your request (probably) wasn't intercepted and modified.</p>
 <p>The additional <code>clientDataHash</code> parameter of the attestation request is not related to the attestation process itself, but extremely important for it to make it safe. As it is, this request is susceptible to a <b>replay attack</b> where a hacker could intercept the validation request and steal the attestation object sent from Apple so that later they can "replay" the same validation request at a fake version of your app to make the server believe it came from the real one.</p>
 <p>A solution to this problem is to simply not allow the validation request to be executed freely. Instead, the client can provide a one-time use token (or session ID) that the server will expect to accompany the request to ensure its validity. If the same token is used twice, the request will fail. That's what <code>clientDataHash</code> is for: By providing a hashed version of that expected token to the attestation request, Apple will embed it into the final object and provide your server a way to extract it. With this, it's pretty hard for a hacker to create a compromised version of your app by simply intercepting requests.</p>
 <pre>
<code>let challenge = getSessionId().data(using: .utf8)!</code>
<code>let hash = Data(SHA256.hash(data: challenge))</code>
<code>service.attestKey(keyIdentifier, clientDataHash: hash) { ... }</code>
</pre>
 <p>As mentioned earlier, Apple suggests you to not reuse keys. You should do this entire process for each user account in a device.</p>
 <p>Because this request relies on a remote Apple server, it's possible for it to fail. If the error is that the server was unavailable, Apple says that you can simply try again, but if it's anything else, you should <b>discard</b> the key identifier and start over. This can happen for example when a user reinstalls your app -- The keys that you generate remain valid through regular app updates, but don‚Äôt survive app reinstallation, device migration, or restoration of a device from a backup. For these cases, your app needs to be able to restart the key generation process.</p>
 <p>From the server side of things, it's also interesting to mention that the statement object also contains a receipt that your server can use to request fraud assessment metrics from Apple. This allows you to check the number of generated keys and the devices that they have been associated to detect possible cases of fraud. Apple specifically mentions the possibility of an attack where a user could use one device to provide valid assertions to compromised devices, which can be detected by this fraud assessment by locating users with unusually high amounts of assertion requests.</p>
 <h2>Wrapping it up: Encrypting Server Requests</h2>
 <p>After attesting the validity of the key, your backend will have access to the public key. From now on, every time you're dealing with sensitive content, you have the ability to safely sign that request. The <code>generateAssertion</code> method used for this works very similarly to the attestation of the keys, except this time you're attesting the request itself:</p>
 <pre>
<code>let challenge = getSessionId().data(using: .utf8)!</code>
<code>let requestJSON = "{ 'requestedPremiumLevel': 300, 'sessionId': '\(challenge)' }".data(using: .utf8)!</code>
<code>let hash = Data(SHA256.hash(data: requestJSON))</code>
<code>service.generateAssertion(keyIdentifier, clientDataHash: hash) { assertion, error in</code>
<code>    guard error == nil else { return }</code>
<code>    let assertionString = assertion?.base64EncodedString()</code>
<code>    // Send the signed assertion to your server.</code>
<code>    // The server will validate it, grab your request and process it.</code>
<code>}</code>
</pre>
 <p>Just like before, your backend must support the usage of a one-time token to prevent replay attacks. This time, since the request itself is our <code>clientDataHash</code>, we're adding the token inside the JSON. There's no restriction on the number of assertions that you can make with a given key, but still, you typically should reserve that for requests made at sensitive moments of your app such as the download of premium content.</p>
 <p>In this case, your additional protection comes from the fact that the request is hashed and usable only once. Because the entire request is signed by your private key, a hacker can't simply intercept your requests and use them to craft their own. They must figure out where the parameters of your request are coming from and manually attempt to sign it, something that will take slightly more skill than simply attaching a proxy. As mentioned in the beginning, it's not impossible to break this protection, just harder.</p>
 <h2>Testing and rolling out your implementation</h2>
 <p>The App Attest service records metrics that you can't reset. To prevent that, apps not in a production environment will use a sandboxed version of it. If you instead want to test in the production environment, you should add the <b>com.apple.developer.devicecheck.appattest-environment</b> entitlement to your app and set its value to <b>production</b>.</p>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>If you have a large user base, Apple recommends you to gradually roll this feature as requests to <code>attestKey</code> are rate limited. After carefully rolling it out for existing users, you can guarantee that it will only be called for new users.</p>
 <h2>Conclusion</h2>
 <p>By implementing this in your client and in your backend, it should become harder for hackers to abuse your server's APIs. However, be aware of the word <b>harder</b> -- it doesn't mean impossible! As mentioned before, there's no sure way for you to detect if a user has a jailbroken device, and even fewer ways to prevent them from attacking your app. As with most security measures, the intention of App Attest is instead to make this process <b>difficult enough</b> so that only a very skilled and dedicated hacker would be able to find a way to break into your app -- someone much harder to come by.</p>
 <h2>References and Good Reads</h2>
 <a href="https://developer.apple.com/documentation/devicecheck">Official App Attest Docs covering the Backend implementation</a>
 <br>
</div>]]></description>
</item>
<item>
    <title>Entry Points in Swift: How @main and @UIApplicationMain work internally</title>
    <link>https://swiftrocks.com/entry-points-swift-uiapplicationmain-main</link>
    <guid>https://swiftrocks.com/entry-points-swift-uiapplicationmain-main</guid>
    <pubDate>Tue, 21 Jul 2020 09:00:00 GMT-3</pubDate>
<description><![CDATA[
 
  
  <!--WRITEIT_POST_NAME=Entry Points in Swift: How @main and @UIApplicationMain work internally--> 
  <!--WRITEIT_POST_HTML_NAME=entry-points-swift-uiapplicationmain-main--> 
  <!--Add here the additional properties that you want each page to possess.--> 
  <!--These properties can be used to change content in the template page or in the page itself as shown here.--> 
  <!--Properties must start with 'WRITEIT_POST'.--> 
  <!--Writeit provides and injects WRITEIT_POST_NAME and WRITEIT_POST_HTML_NAME by default.--> 
  <!--WRITEIT_POST_SHORT_DESCRIPTION=In this article, we'll see how Swift determines the entry point of an app, the different attributes used to alter this behavior in iOS, how they work internally, and what Swift 5.3's new @main attribute brings to the table.--> 
  <!--WRITEIT_POST_SITEMAP_DATE_LAST_MOD=2020-07-21T14:00:00+02:00--> 
  <!--WRITEIT_POST_SITEMAP_DATE=2020-07-21T14:00:00+02:00--> 
  <title>Entry Points in Swift: How @main and @UIApplicationMain work internally</title>  
 

<div class="blog-post"> 
 <div class="post-title-index">  
  <h1>Entry Points in Swift: How <code>@main</code> and <code>@UIApplicationMain</code> work internally</h1>
 </div> 
 <div class="post-info"> 
  <div class="category category-compiler">
   Compiler
  </div> 
  <div class="category category-swift">
   Swift
  </div> 
  <div class="post-info-text">
   Published on 21 Jul 2020 
  </div> 
 </div>  
 <p>In this article, we'll see how Swift determines the entry point of an app, the different attributes used to alter this behavior in iOS, how they work internally, and what Swift 5.3's new <code>@main</code> attribute brings to the table.</p>
 <h2>How Swift Scripts Work</h2>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>When executing Swift code from the command line, by default, the code will be read from top to bottom just like any other scripting language. While Swift scripts support everything you'd have in any other context, they have the additional advantage of being able to write expressions in a <b>global scope</b>:</p>
 <pre>
<code>print("Hello")</code>
<code></code>
<code>struct MyStruct {</code>
<code>    func foo() {}</code>
<code>}</code>
<code></code>
<code>MyStruct().foo()</code>
</pre>
 <p>In an iOS app, by default, doing so would result in the <code>Expressions are not allowed at the top level</code> error, but in a scripted world where you want to execute something as possible, there's no point in preventing this behavior.</p>
 <p>Deep down, the ability to call code globally is just a cool syntax sugar. What is really happening is that Swift is abstracting your global code inside a fake <code>main</code> C function:</p>
 <pre>
<code>func main(argc: Int32, argv: UnsafeMutablePointer&lt;UnsafeMutablePointer&lt;Int8&gt;?&gt;) -&gt; Int32 {</code>
<code>    print("Hello")</code>
<code></code>
<code>    struct MyStruct {</code>
<code>        func foo() {}</code>
<code>    }</code>
<code></code>
<code>    MyStruct().foo()</code>
<code>}</code>
</pre>
 <p>Swift uses clang internally to compile and provide interoperability with C/C++/Objective-C, so it's natural that the starting point of a script/app mimicks it as well. You can check this with <code>swiftc (file) -emit-sil</code>, which will print Swift's Intermediate Language representation of your code after optimizing and generating any additional code it needs. In this case, we'll see a definition for a <code>main</code> function and our script's contents inside of it.</p>
 <pre>
<code>sil @main</code>
<code>// a bunch of stuff that defines your top-level code!</code>
</pre>
 <p>Interestingly enough, it's not possible for you to "steal" and define your own main function in that context. The generated main function is literally symbolized as <code>main</code>, while anything you define will internally have its symbol <b>mangled</b> (an unique identifier for your function or class, based on the context where it was defined), like <code>s4MyApp4mainCACycfc</code>.</p>
 <p>This is what happens when your Swift script/binary only contains one file, but what if it contains <b>multiple</b> files?</p>
 <p>In this case, as we can't have multiple starting points, we must designate one of them as the <b>main</b> one. Like before, the main file will be the entry point of the app and gain access to global expressions, but now, as expected, any additional file will have to follow your usual Swift rules. In Swift, designating the main file is just a matter of naming it <code>main.swift</code>.</p>
 <pre>
<code>swiftc main.swift anotherFile.swift</code>
</pre>
 <h2><code>@UIApplicationMain</code> -- When the entry point needs to be controlled</h2>
 <p>But not all kinds of programs fit into this top-bottom code execution format -- for example, in iOS, the execution of the app relies on running and maintaining an <code>UIApplication</code> instance, a process that is the same for every single iOS app. This initial process of booting an <code>UIApplication</code> is abstracted by UIKit, and there's no reason for you as an user to have to worry about it, specially considering that this is the very first thing your app should do. For this reason, you could argue that handling this responsability to the user could even have <b>negative</b> consequences. Imagine accidentally shipping a version where your app doesn't boot at all!</p>
 <p>To prevent this issue from happening, Apple thought that if UIKit is responsible for providing the code necessary to boot an iOS app, then it should probably <b>get its hands dirty and do it itself</b>. The Swift compiler then started supporting two new special attributes: <code>@UIApplicationMain</code> and <code>@NSApplicationMain</code> (for macOS).</p>
 <p>These attributes are magical, but they don't deviate from what we already know. Their purpose is to <b>automatically generate an entry point</b>, and internally, what happens is that the presence of these attributes will result in a fake <code>main</code> function being added to your binary:</p>
 <pre>
<code>func main(argc: Int32, argv: UnsafeMutablePointer&lt;UnsafeMutablePointer&lt;Int8&gt;?&gt;) -&gt; Int32 {</code>
<code>    return UIApplicationMain(argc, argv, nil, ClassName)</code>
<code>}</code>
</pre>
 <p>The content of the function depends on the attribute you used, but as you can expect, it simply initializes your iOS app.</p>
 <p>You might know <code>UIApplicationMain()</code> if you ever needed to use a subclass of an <code>UIApplication</code> in your app -- this is the function that bootstraps an iOS app, and you can use the third and fourth arguments to change the classes you want to use as your <code>UIApplication</code> and <code>UIApplicationDelegate</code>. This means that there's nothing special about the <code>@UIApplicationMain</code> attribute, and you can reproduce what the compiler is doing by removing it and creating your own <code>main.swift</code> file. This is a legit technique to fine-tune the initialization of your app, which you can use to run code before your app launches (literally).</p>
 <pre>
<code>UIHooks.swizzleEverything()</code>
<code>UIApplicationMain(CommandLine.argc, CommandLine.unsafeArgv, nil, "AppDelegate")</code>
</pre>
 <p>As a fake <code>main</code> function is emitted as a result of using the <code>@UIApplicationMain</code> attribute, you can't have <b>both</b> the attribute and a <code>main.swift</code> file. Trying to use both will result in a duplicated symbol error, and in some situations the compiler will even give you a specific <code>attribute cannot be used in a module that contains top-level code</code> error.</p>
 <h2>Swift 5.3 and <code>@main</code></h2>
 <p>Many years later, it was realized that UIKit was not the only framework that benefitted from controlling the entry point. Many frameworks for Swift CLI tools involve some sort of initial setup, and so it would be great if the language provided a standard way to replicating what was currently hardcoded as <code>@UIApplicationMain</code>. Finally, in Swift 5.3, the <code>@main</code> attribute was added to allow developers to control this behavior.</p>
 <pre>
<code>@main struct MyScript {</code>
<code>    static func main() throws {</code>
<code>    	print("SwiftRocks!")</code>
<code>    }</code>
<code>}</code>
</pre>
 <p><code>@main</code> works similarly to a protocol -- when added, you must define a <code>main()</code> method that will serve as the entry point for your Swift code. Apart from that, <code>@main</code> works precisely like <code>@UIApplicationMain</code>. The fake <code>main</code> function is still emitted, but instead of returning the hardcoded UIKit behavior, it executes the function that you defined as a result of adding the attribute to a type. As seen in WWDC 2020, the new <code>@main</code> attribute is used by SwiftUI and the new Widgets extension to abstract the definition of their entry points.</p>
 <p>One particularly interesting use of it is in Apple's <b>swift-argument-parser</b> library, which is a tool for creating commands and arguments for CLI tools. Before Swift 5.3, you had to manually initialize your tool by calling its main command's <code>main()</code> method from the library, but now, you can simply attach the new attribute to mark it as the starting point.</p>
 <p>Before:</p>
 <pre>
<code>struct Repeat: ParsableCommand {</code>
<code>    @Argument(help: "The phrase to repeat.")</code>
<code>    var phrase: String</code>
<code></code>
<code>    mutating func run() throws {</code>
<code>        for _ in 1...5 {</code>
<code>            print(phrase)</code>
<code>        }</code>
<code>    }</code>
<code>}</code>
<code></code>
<code>Repeat.main()</code>
</pre>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>Post Swift 5.3:</p>
 <pre>
<code>@main struct Repeat: ParsableCommand {</code>
<code>    @Argument(help: "The phrase to repeat.")</code>
<code>    var phrase: String</code>
<code></code>
<code>    mutating func run() throws {</code>
<code>        for _ in 1...5 {</code>
<code>            print(phrase)</code>
<code>        }</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>Because of this addition, using <code>@UIApplicationMain</code> is now officially deprecated as Apple allows you to use the new <code>@main</code> attribute in your AppDelegates (except in the second Xcode 12 beta, where the feature was temporarily disabled).</p>
</div>]]></description>
</item>
<item>
    <title>Adapting Objective-C APIs to Swift with NS_REFINED_FOR_SWIFT</title>
    <link>https://swiftrocks.com/adapting-objectivec-apis-for-swift-using-nsrefinedforswift</link>
    <guid>https://swiftrocks.com/adapting-objectivec-apis-for-swift-using-nsrefinedforswift</guid>
    <pubDate>Tue, 14 Jul 2020 09:00:00 GMT-3</pubDate>
<description><![CDATA[
 
  
  <!--WRITEIT_POST_NAME=Adapting Objective-C APIs to Swift with NS_REFINED_FOR_SWIFT--> 
  <!--WRITEIT_POST_HTML_NAME=adapting-objectivec-apis-for-swift-using-nsrefinedforswift--> 
  <!--Add here the additional properties that you want each page to possess.--> 
  <!--These properties can be used to change content in the template page or in the page itself as shown here.--> 
  <!--Properties must start with 'WRITEIT_POST'.--> 
  <!--Writeit provides and injects WRITEIT_POST_NAME and WRITEIT_POST_HTML_NAME by default.--> 
  <!--WRITEIT_POST_SHORT_DESCRIPTION=The compiler already does a good job translating Objective-C APIs to Swift's standards, but what if you want them to be translated to something completely different?--> 
  <!--WRITEIT_POST_SITEMAP_DATE_LAST_MOD=2020-07-14T14:00:00+02:00--> 
  <!--WRITEIT_POST_SITEMAP_DATE=2020-07-14T14:00:00+02:00--> 
  <title>Adapting Objective-C APIs to Swift with NS_REFINED_FOR_SWIFT</title>  
 

<div class="blog-post"> 
 <div class="post-title-index">  
  <h1>Adapting Objective-C APIs to Swift with <code>NS_REFINED_FOR_SWIFT</code></h1>
 </div> 
 <div class="post-info"> 
  <div class="category category-ios">
   iOS
  </div> 
  <div class="category category-swift">
   Swift
  </div> 
  <div class="post-info-text">
   Published on 14 Jul 2020 
  </div> 
 </div>  
 <p>If your iOS project uses Objective-C SDKs, you'll find that the compiler does a good job translating those APIs to Swift. Whenever you try to use one of them in Swift, you'll be greeted with a <i>swiftified</i> version of it that has common Objective-C standards translated to Swift. <code>Foundation</code> types like <code>NSData</code> and <code>NSString</code> will be translated to their Swift variants (<code>Data</code>, <code>String</code>), <code>nullables</code> will become optionals, and the name of the method will change to follow Swift's naming conventions. If the method can fail (by having an error pointer), it will even become a throwing function:</p>
 <pre>
<code>- (NSData *)dataForRow:(NSInteger)row error:(NSError **)error;</code>
<code>// becomes:</code>
<code>let data: Data = try data(for: row)</code>
</pre>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>For most cases, this does the trick. While I'm not a fan of how the naming can end up sometimes, there are attributes that you can use to finetune the final result, like <code>NS_SWIFT_NAME(customName)</code> to use a customized name or <code>NS_SWIFT_NOTHROW</code> to disable the <b>error pointer -&gt; throws</b> conversion.</p>
 <p>However, what if you want that Objective-C API to become something <b>completely</b> different? One example of a common architectural difference between the languages is the usage of methods versus properties -- most things in Objective-C are methods, while Swift will advise you to use <b>computed properties</b> for things that are computed but yet don't involve actually processing data. The compiler isn't <b>that</b> smart, so by default you'll end up with methods even if they are better defined as something else in Swift:</p>
 <pre>
<code>MyClass.sharedInstance() // would work better in Swift as `MyClass.shared`!</code>
</pre>
 <p>Additionally, the automatic API translation doesn't consider Swift-only features like default arguments and generics in methods, which are really good tools for developing APIs in Swift. Fortunately, the compiler provides you a way to completely customize how Objective-C APIs end up in Swift.</p>
 <h2>NS_REFINED_FOR_SWIFT</h2>
 <p>The <code>NS_REFINED_FOR_SWIFT</code> attribute can be added to Objective-C methods to indicate that you want to have full control on how this API is translated to Swift. When added to an Objective-C API, the compiler will still port it, but it will do so in the shape of a <b>special hidden method</b> that you can use to redefine it as something else. Here's an example of a singleton in Objective-C:</p>
 <pre>
<code>@interface SRMyClass : NSObject</code>
<code>+ (instancetype)sharedInstance;</code>
<code>@end</code>
</pre>
 <p>By default this will be converted to a <code>sharedInstance()</code> method in Swift, but in Swift standards, this would look better as a computed property instead.</p>
 <p>To customize how it'll be translated, let's add the attribute to the Objective-C definition:</p>
 <pre>
<code>@interface SRMyClass : NSObject</code>
<code>+ (instancetype)sharedInstance NS_REFINED_FOR_SWIFT;</code>
<code>@end</code>
</pre>
 <p>As mentioned, using this attribute won't stop the method from being migrated to Swift -- but it'll be done in a special way. In the case of methods, this special way will be that the method's name will be prefixed by two underscores (<code>__</code>):</p>
 <pre>
<code>let instance = SRMyClass.__sharedInstance()</code>
</pre>
 <p>The reason for this is precisely to indicate that this method shouldn't be used as-is. In fact, if you try to implement this example you'll notice that while you <b>can</b> use it, it will <b>not</b> show in code completion at all. The intention, instead, is for you to <b>abstract</b> this special method into what you actually want this to look like in Swift. In the case of our singleton example, if we want it to become a computed property, we should define that property in our Swift code and implement it by calling the exposed unrefined method:</p>
 <pre>
<code>extension SRMyClass {</code>
<code>    var shared: SRMySingleton {</code>
<code>        return __sharedInstance()</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>Because the original unrefined method doesn't even show up in code completion, you can be sure that the developers will always use the correct <i>swiftified</i> version of it.</p>
 <p>My personal favorite use of this attribute is to add default parameters to methods, which is something normally ignored in Objective-C for not being easy to implement, but extremely simple and useful in Swift. To do, we just need to create a version of the method that contains default parameters and internally call the original unrefined one:</p>
 <pre>
<code>public extension SRKeychain {</code>
<code>    func data(</code>
<code>        forDomain domain: String,</code>
<code>        andKey key: String,</code>
<code>        accessGroup: String? = nil,</code>
<code>        accessAttr: String? = nil,</code>
<code>        synchronizable: Bool = false</code>
<code>    ) -&gt; Data? {</code>
<code>        return __data(</code>
<code>            forDomain: domain,</code>
<code>            andKey: key,</code>
<code>            accessGroup: accessGroup,</code>
<code>            accessAttr: accessAttr,</code>
<code>            synchronizable: synchronizable</code>
<code>        )</code>
<code>    }</code>
<code>}</code>
</pre>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p><code>NS_REFINED_FOR_SWIFT</code> is also a great way to enforce type-safety in places where it wouldn't be applicable in Objective-C. In Swift, you can easily abstract unsafe <code>id</code> (<code>Any</code> / <code>AnyObject</code>) Objective-C methods, for example, under generics.</p>
 <pre>
<code>public extension SRPersistance {</code>
<code>    func object&lt;T&gt;(forKey key: String) -&gt; T? {</code>
<code>        return __object(forKey: key) as? T</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>Unfortunately you can't redefine <b>entire</b> types with <code>NS_REFINED_FOR_SWIFT</code> as only methods, properties and initializers are supported, but in my experience, that's enough to give legacy code a good Swift experience.</p>
</div>]]></description>
</item>
<item>
    <title>Creating Debug Menus in Swift with UIContextMenuInteraction</title>
    <link>https://swiftrocks.com/creating-debug-menus-in-swift-with-uicontextmenuinteraction</link>
    <guid>https://swiftrocks.com/creating-debug-menus-in-swift-with-uicontextmenuinteraction</guid>
    <pubDate>Tue, 30 Jun 2020 09:00:00 GMT-3</pubDate>
<description><![CDATA[
 
  
  <!--WRITEIT_POST_NAME=Creating Debug Menus in Swift with UIContextMenuInteraction--> 
  <!--WRITEIT_POST_HTML_NAME=creating-debug-menus-in-swift-with-uicontextmenuinteraction--> 
  <!--Add here the additional properties that you want each page to possess.--> 
  <!--These properties can be used to change content in the template page or in the page itself as shown here.--> 
  <!--Properties must start with 'WRITEIT_POST'.--> 
  <!--Writeit provides and injects WRITEIT_POST_NAME and WRITEIT_POST_HTML_NAME by default.--> 
  <!--WRITEIT_POST_SHORT_DESCRIPTION=Debug menus in iOS are an effective way to make your debugging day more productive. Let's see how we can use UIContextMenuInteraction to create debug-only menus.--> 
  <!--WRITEIT_POST_SITEMAP_DATE_LAST_MOD=2020-06-30T14:00:00+02:00--> 
  <!--WRITEIT_POST_SITEMAP_DATE=2020-06-30T14:00:00+02:00--> 
  <title>Creating Debug Menus in Swift with UIContextMenuInteraction</title>  
 

<div class="blog-post"> 
 <div class="post-title-index">  
  <h1>Creating Debug Menus in Swift with <code>UIContextMenuInteraction</code></h1>
 </div> 
 <div class="post-info"> 
  <div class="category category-ios">
   iOS
  </div> 
  <div class="post-info-text">
   Published on 30 Jun 2020 
  </div> 
 </div>  
 <div class="post-image margin-top-40 margin-bottom-40"> 
  <img src="https://i.imgur.com/akiIA1Z.png" alt="Context Menu 2"> 
 </div> 
 <p>Debug menus in iOS are a very effective way to make your day more productive as a developer. If you find yourself doing the same debugging tasks over and over, such as printing backend responses, skipping to specific view controllers or copying user identifiers, it's nice to have special developer menus in your app that automatically handles these tasks for you.</p>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>iOS 13 introduced <code>UIContextMenuInteraction</code> -- a new context menu API that replaces the older (and much harder to use) peek-and-pop menus. When a <code>UIView</code> with a registered interaction is pressed, a menu containing actions and an optional preview will show up. It works similarly to an <code>UIAlertController</code>, but nicer to look at and much easier to implement! New in iOS 14, we can even add asynchronously resolved actions to it.</p>
 <div class="post-image margin-top-40 margin-bottom-40"> 
  <img src="https://i.imgur.com/iJ9FXS6.png" alt="Context Menu"> 
 </div>
 <p>Because these context menus are implemented directly into the view (as opposed to something like an alert, which is an independent view controller), we can create an abstraction that implements debug menus to specific views if we're running a developer build.</p>
 <h2>Example: Copy a logged user's data to the pasteboard</h2>
 <p>In this example, let's pretend that we have an app where we often have to retrieve the logged account's user identifier -- in past projects, I had to do this a lot for debugging and bug reporting purposes, either to let the backend know which user I am having a problem with or to be able to manually send backend requests in a service like <b>Postman</b>.</p>
 <p>I normally did that by setting a breakpoint and printing the user's model fields, which was a very slow and annoying process. Let's add a special debug menu that does this for us.</p>
 <p><code>UIContextMenuInteraction</code> works through a delegate -- to have a debug menu show up for a view, you must inherit the delegate, define a list of <code>UIActions</code> that should show up and insert the interaction in the view. In this case, we'll add the interaction directly in the initializer.</p>
 <p>Here's how our "debuggable user view" looks like:</p>
 <pre>
<code>struct User {</code>
<code>    let identifier: String</code>
<code>    let name: String</code>
<code>}</code>
<code></code>
<code>final class UserTextField: UITextField {</code>
<code></code>
<code>    private(set) var user: User?</code>
<code></code>
<code>    override init(frame: CGRect) {</code>
<code>        super.init(frame: frame)</code>
<code>        let interaction = UIContextMenuInteraction(delegate: self)</code>
<code>        addInteraction(interaction)</code>
<code>    }</code>
<code></code>
<code>    required init?(coder: NSCoder) {</code>
<code>        fatalError()</code>
<code>    }</code>
<code></code>
<code>    func render(user: User) {</code>
<code>        self.user = user</code>
<code>        text = "Logged as \(user.name)"</code>
<code>    }</code>
<code>}</code>
<code></code>
<code>extension UserTextField: UIContextMenuInteractionDelegate {</code>
<code>    func contextMenuInteraction(</code>
<code>        _ interaction: UIContextMenuInteraction,</code>
<code>        configurationForMenuAtLocation location: CGPoint</code>
<code>    ) -&gt; UIContextMenuConfiguration? {</code>
<code>        return UIContextMenuConfiguration(</code>
<code>            identifier: nil,</code>
<code>            previewProvider: nil</code>
<code>        ) { _ in</code>
<code>            return UIMenu(title: "Debug Menu", children: [self.copyIdentifierAction()])</code>
<code>        }</code>
<code>    }</code>
<code></code>
<code>    func copyIdentifierAction() -&gt; UIAction {</code>
<code>        return UIAction(title: "Copy Identifier") { _ in</code>
<code>            UIPasteboard.general.string = self.user?.identifier ?? ""</code>
<code>        }</code>
<code>    }</code>
<code>}</code>
</pre>
 <div class="post-image margin-top-40 margin-bottom-40"> 
  <img src="https://i.imgur.com/akiIA1Z.png" alt="Context Menu 2"> 
 </div>
 <p>There are a few ways to remove this code from release builds, and my recommended way is to use preprocessor macros to completely eliminate the "debug code", as other approaches will still allow your code to be reverse-engineered by hackers.</p>
 <pre>
<code>#if DEBUG</code>
<code>extension UserTextField: UIContextMenuInteractionDelegate {</code>
<code>...</code>
<code>#endif</code>
</pre>
 <h2>Expanding it for every UIView in the app</h2>
 <p>We have created a debug menu for a single view, but what about the others? As you can see, this code doesn't look very nice and will get difficult to maintain pretty quickly. To remedy this, we can subclass <code>UIContextMenuInteraction</code> into a cleaner abstraction that only requires the list of actions to display -- no configurations, previews or other annoying things.</p>
 <p>I chose to create <code>DebugMenuInteraction</code> -- a special <code>UIContextMenuInteraction</code> that handles its own delegate, exposing a <code>DebugMenuInteractionDelegate</code> instead to retrieve the list of debugging actions.</p>
 <pre>
<code>public protocol DebugMenuInteractionDelegate: AnyObject {</code>
<code>    func debugActions() -&gt; [UIMenuElement]</code>
<code>}</code>
<code></code>
<code>public final class DebugMenuInteraction: UIContextMenuInteraction {</code>
<code></code>
<code>    class DelegateProxy: NSObject, UIContextMenuInteractionDelegate {</code>
<code>        weak var delegate: DebugMenuInteractionDelegate?</code>
<code></code>
<code>        public func contextMenuInteraction(</code>
<code>            _ interaction: UIContextMenuInteraction,</code>
<code>            configurationForMenuAtLocation location: CGPoint</code>
<code>        ) -&gt; UIContextMenuConfiguration? {</code>
<code>            return UIContextMenuConfiguration(</code>
<code>                identifier: nil,</code>
<code>                previewProvider: nil</code>
<code>            ) { [weak self] _ in</code>
<code>                let actions = self?.delegate?.debugActions() ?? []</code>
<code>                return UIMenu(title: "Debug Actions", children: actions)</code>
<code>            }</code>
<code>        }</code>
<code>    }</code>
<code></code>
<code>    private let contextMenuDelegateProxy: DelegateProxy</code>
<code></code>
<code>    public init(delegate: DebugMenuInteractionDelegate) {</code>
<code>        let contextMenuDelegateProxy = DelegateProxy()</code>
<code>        contextMenuDelegateProxy.delegate = delegate</code>
<code>        self.contextMenuDelegateProxy = contextMenuDelegateProxy</code>
<code>        super.init(delegate: contextMenuDelegateProxy)</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>This allows us to refactor <code>UserTextField</code> into a much cleaner structure:</p>
 <pre>
<code>final class UserTextField: UITextField {</code>
<code></code>
<code>    private(set) var user: User?</code>
<code></code>
<code>    func render(user: User) {</code>
<code>        self.user = user</code>
<code>        text = "Logged as \(user.name)"</code>
<code>    }</code>
<code>}</code>
<code></code>
<code>#if DEBUG</code>
<code>extension UserTextField: DebugMenuInteractionDelegate {</code>
<code>    func debugActions() -&gt; [UIAction] {</code>
<code>        let copyId = UIAction(title: "Copy Identifier") { _ in</code>
<code>            UIPasteboard.general.string = self.user?.identifier ?? ""</code>
<code>        }</code>
<code>        return [copyId]</code>
<code>    }</code>
<code>}</code>
<code>#endif</code>
</pre>
 <p>Previously, the interaction was being added directly in the class's initializer. This can still be done, but to allow us to better separate the "debug code" from the production code, we can create a global extension instead:</p>
 <pre>
<code>extension UIView {</code>
<code>    public func addDebugMenuInteraction() {</code>
<code>        #if DEBUG</code>
<code>        guard let delegate = self as? DebugMenuInteractionDelegate else {</code>
<code>            return</code>
<code>        }</code>
<code>        let debugInteraction = DebugMenuInteraction(delegate: delegate)</code>
<code>        addInteraction(debugInteraction)</code>
<code>        #endif</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>Since the extension itself is able to determine if we're running a debug build, calls to <code>addDebugMenuInteraction()</code> can be kept in production code as the compiler will automatically optimize it out of the build.</p>
 <p>With these abstractions, the final result is the same, but the code is now easier to maintain and evolve as supporting different views is just a matter of extending them to conform to the new delegate.</p>
 <h2>iOS 14 - Asynchronous actions with <code>UIDeferredMenuElement</code></h2>
 <p>The arrival of iOS 14 introduced the possibility of creating menu elements that are resolved asynchronously. If your debug actions involves some data that requires an API call, you can use the new APIs to create async actions that are automatically displayed in the <code>UIContextMenuInteraction</code> with a special loading UI:</p>
 <pre>
<code>func serverInformation() -&gt; UIMenuElement {</code>
<code>    return UIDeferredMenuElement { completion in</code>
<code>        // an Async task that fetches some information about a server:</code>
<code>        completion([printServerInformationAction(serverInfo)])</code>
<code>    }</code>
<code>}</code>
</pre>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>The completion type of the deferred action is an array of <code>UIMenuElements</code>, meaning that you can a single action can be resolved to multiple entries in the debug menu. When displayed, you'll get a nice loading screen that is replaced with the real actions once the completion handler is called.</p>
 <div class="post-image margin-top-40 margin-bottom-40"> 
  <img src="https://i.imgur.com/05piylJ.png" alt="Context Menu Async"> 
 </div>
 <p>If you're interested in creating debug menus, the code we created here <a href="https://github.com/rockbruno/DebugActions">is available in SPM and CocoaPods as the DebugActions library.</a></p>
</div>]]></description>
</item>
<item>
    <title>How to create Widgets in iOS 14 in Swift</title>
    <link>https://swiftrocks.com/ios-14-widget-tutorial-mini-apps</link>
    <guid>https://swiftrocks.com/ios-14-widget-tutorial-mini-apps</guid>
    <pubDate>Tue, 23 Jun 2020 13:10:00 GMT-3</pubDate>
<description><![CDATA[
 
  
  <!--WRITEIT_POST_NAME=How to create Widgets in iOS 14 in Swift--> 
  <!--WRITEIT_POST_HTML_NAME=ios-14-widget-tutorial-mini-apps--> 
  <!--Add here the additional properties that you want each page to possess.--> 
  <!--These properties can be used to change content in the template page or in the page itself as shown here.--> 
  <!--Properties must start with 'WRITEIT_POST'.--> 
  <!--Writeit provides and injects WRITEIT_POST_NAME and WRITEIT_POST_HTML_NAME by default.--> 
  <!--WRITEIT_POST_SHORT_DESCRIPTION=Widgets existed in iOS for a long time, but iOS 14 completely revamped them. With the new Widget APIs, not you're able to add widgets directly to your home screen, but they are also completely written in SwiftUI.--> 
  <!--WRITEIT_POST_SITEMAP_DATE_LAST_MOD=2020-06-25T13:50:00+02:00--> 
  <!--WRITEIT_POST_SITEMAP_DATE=2020-06-23T18:10:00+02:00--> 
  <title>How to create Widgets in iOS 14 in Swift</title>  
 

<div class="blog-post"> 
 <div class="post-title-index">  
  <h1>How to create Widgets in iOS 14 in Swift</h1>
 </div> 
 <div class="post-info"> 
  <div class="category category-ios">
   iOS
  </div> 
  <div class="post-info-text">
   Published on 23 June 2020 
  </div> 
 </div>   
 <p>Widgets existed in iOS for a long time, but iOS 14 completely revamped them. With the new Widget APIs, not you're able to add widgets directly to your home screen, but they are also completely written in SwiftUI. iOS 14's Widgets come in a variety of shapes (literally), ranging from simple information squares to widgets that can retrieve and display information from its parent app's <b>Siri Intents</b>.</p>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>One trick that has drawn my attention the most however is that having widgets directly in your home means that technically you're now able to make visual "mini apps". If you find yourself doing the same tasks over and over in your job such as checking the number of crashes in a release or the latest release supported by one of your apps, you can create a Widget in iOS 14 that essentially behaves like a super-charged, UI-enabled <b>Siri Shortcut</b>.</p>
 <p>Although you can't interact with a Widget besides touching it (which triggers a deep link to your app), there aren't many limitations in what you can display in them, so you can use them to develop read-only visual apps. In this article, we'll develop a Widget that shows us <b>the latest commit in the Swift repository.</b></p>
 <h2>Developing a "Swift commit tracker" Widget</h2>
 <p>I find myself going to the Swift repo once in a while to see what the community is up to. To make my life easier, how about displaying this information directly on my home screen?</p>
 <div class="post-image margin-top-40 margin-bottom-40"> 
  <img src="https://i.imgur.com/7iNmotK.jpg" alt=""> 
 </div>
 <p>To do something like this, we can make a request to GitHub's public APIs, parse the information and render it to our widget.</p>
 <p>We can start by creating a new iOS project -- the details of the project don't matter as in this tutorial all the code will be inside the Widget's module.</p>
 <p>With your project created, add a Widget module by going to <b>File -&gt; New -&gt; Target</b> and selecting the <b>Widget Extension</b> target:</p>
 <div class="post-image margin-top-40 margin-bottom-40"> 
  <img src="https://i.imgur.com/xDsjmiD.png" alt=""> 
 </div>
 <p>Make sure to uncheck the <b>Include Configuration Intent</b> checkbox, as this involves a feature that will be presented only later in this article! After generating the target, make sure to erase the example code so we can inspect it step by step.</p>
 <p>To define a Widget, all you have to do is create a struct that inherits from <b>Widget</b> and configures its capabilities:</p>
 <pre>
<code>@main</code>
<code>struct CommitCheckerWidget: Widget {</code>
<code>    private let kind: String = "CommitCheckerWidget"</code>
<code></code>
<code>    public var body: some WidgetConfiguration {</code>
<code>        StaticConfiguration(kind: kind, provider: CommitTimeline(), placeholder: PlaceholderView()) { entry in</code>
<code>            CommitCheckerWidgetView(entry: entry)</code>
<code>        }</code>
<code>        .configurationDisplayName("Swift's Latest Commit")</code>
<code>        .description("Shows the last commit at the Swift repo.")</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>This code will not compile before we define such capabilities, but this is important as a first step because this is the Widget itself. The <code>WidgetConfiguration</code> return value describes what this widget is and how it's built, but most importantly, how it fetches its content.</p>
 <h2>Types of Widgets</h2>
 <p>The <code>StaticConfiguration</code> <code>WidgetConfiguration</code> defines a Widget that can resolve itself without any input from the user. You could fetch any relevant data in the Widget's parent app and send the result to the Widget module as an "user input", but as you are allowed to make API calls when configuring your Widget, there's no need to do so if there's no contextual information involved in the request.</p>
 <p>On the other hand, you can use the <code>IntentConfiguration</code> <code>WidgetConfiguration</code> to define a Widget that depends on a Siri Intent from the parent app, which allows you to build configurable dynamic widgets. For example, when using intents, a food delivery app can create a widget that displays the delivery status for the user's latest order. This is done by having the app dispatch a Siri Intent (just like when developing Siri Shortcuts), which are automatically picked up by <code>IntentConfiguration</code> and used to update a Widget. You can create a base <code>IntentConfiguration</code> Widget by checking the intents box when creating the Widget Extension, but since all we need to do is parse GitHub's public API, we can use a <code>StaticConfiguration</code> Widget and avoid interacting with the app itself.</p>
 <h2>TimelineProvider</h2>
 <p>The content displayed by iOS 14's Widgets works similarly to watchOS's complications in the sense that instead of having an extension that is running all the time, you provide, at once, a "timeline" of events that the OS should display throughout the hours, days or even weeks. This is useful for apps like <b>Weather</b> and <b>Calendar</b> where you can "predict" what is going to be displayed in the future as you already have that information.</p>
 <p>In our case, since we are unable to predict Swift's commits, we'll provide a timeline that contains only a single event -- making iOS refresh our Widget in a more regular basis.</p>
 <p>To create a <code>Timeline</code>, we first need to define a <code>TimelineEntry</code>. A <code>TimelineEntry</code> only requires the <code>Date</code> when this entry is expected to be rendered in the Widget, but it can also contain any additional information that you require. In our case, our entries will contain the <code>Commit</code> that we want to display in the Widget.</p>
 <pre>
<code>struct Commit {</code>
<code>    let message: String</code>
<code>    let author: String</code>
<code>    let date: String</code>
<code>}</code>
<code></code>
<code>struct LastCommitEntry: TimelineEntry {</code>
<code>    public let date: Date</code>
<code>    public let commit: Commit</code>
<code>}</code>
</pre>
 <p>But before creating the timeline, we need to be able to fetch such commits. Let's create a <code>CommitLoader</code> class that fetches and parses Swift's latest commit:</p>
 <pre>
<code>struct Commit {</code>
<code>    let message: String</code>
<code>    let author: String</code>
<code>    let date: String</code>
<code>}</code>
<code></code>
<code>struct CommitLoader {</code>
<code>    static func fetch(completion: @escaping (Result&lt;Commit, Error&gt;) -&gt; Void) {</code>
<code>        let branchContentsURL = URL(string: "https://api.github.com/repos/apple/swift/branches/main")!</code>
<code>        let task = URLSession.shared.dataTask(with: branchContentsURL) { (data, response, error) in</code>
<code>            guard error == nil else {</code>
<code>                completion(.failure(error!))</code>
<code>                return</code>
<code>            }</code>
<code>            let commit = getCommitInfo(fromData: data!)</code>
<code>            completion(.success(commit))</code>
<code>        }</code>
<code>        task.resume()</code>
<code>    }</code>
<code></code>
<code>    static func getCommitInfo(fromData data: Foundation.Data) -&gt; Commit {</code>
<code>        let json = try! JSONSerialization.jsonObject(with: data, options: []) as! [String: Any]</code>
<code>        let commitParentJson = json["commit"] as! [String: Any]</code>
<code>        let commitJson = commitParentJson["commit"] as! [String: Any]</code>
<code>        let authorJson = commitJson["author"] as! [String: Any]</code>
<code>        let message = commitJson["message"] as! String</code>
<code>        let author = authorJson["name"] as! String</code>
<code>        let date = authorJson["date"] as! String</code>
<code>        return Commit(message: message, author: author, date: date)</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>When <code>fetch</code> is called, this loader type sends a request to GitHub's public API and parses the latest commit -- giving us the message, author and its timestamp. We can now create a <code>Timeline</code> that fetches the latest commit, adds it as an entry and schedules itself to be updated after a while.</p>
 <pre>
<code>struct CommitTimeline: TimelineProvider {</code>
<code>    typealias Entry = LastCommitEntry</code>
<code>    /* protocol methods implemented below! */</code>
<code>}</code>
</pre>
 <p>The <code>TimelineProvider</code> protocol has two methods that we need to implement:</p>
 <h3><code>snapshot()</code> - The fake information of the Widget</h3>
 <p>The <code>snapshot()</code> required method of the <code>TimelineProvider</code> protocol defines how your Widget should be configured when your Widget appears in transient situations, such as the Widget selection screen. This configuration will be used when showing correct information doesn't matter:</p>
 <div class="post-image margin-top-40 margin-bottom-40"> 
  <img src="https://i.imgur.com/CpKrwmv.jpg" alt=""> 
 </div>
 <p>To create a snapshot configuration, all you have to do is create and return a fake entry of your <code>TimelineEntry</code> object.</p>
 <pre>
<code></code>
<code>public func snapshot(with context: Context, completion: @escaping (LastCommitEntry) -&gt; ()) {</code>
<code>    let fakeCommit = Commit(message: "Fixed stuff", author: "John Appleseed", date: "2020-06-23")</code>
<code>    let entry = LastCommitEntry(date: Date(), commit: fakeCommit)</code>
<code>    completion(entry)</code>
<code>}</code>
<code></code>
</pre>
 <h3><code>timeline()</code> - The true information of the Widget</h3>
 <p>The <code>timeline()</code> method, however, defines the real information that should be used by your widget. The objective is for you to return a <code>Timeline</code> instance that contains all the entries you want to display, <b>when</b> they are expected to be displayed (the <code>date</code> of the entry) and when the timeline "expires".</p>
 <p>Because our app can't "predict" its future state like a Weather app, it suffices for us to create a timeline with a single entry that should be displayed immediately, which can be done by setting the entry's <code>date</code> to the current <code>Date()</code>:</p>
 <pre>
<code>public func timeline(with context: Context, completion: @escaping (Timeline&lt;LastCommitEntry&gt;) -&gt; ()) {</code>
<code>    let currentDate = Date()</code>
<code>    let refreshDate = Calendar.current.date(byAdding: .minute, value: 5, to: currentDate)!</code>
<code></code>
<code>    CommitLoader.fetch { result in</code>
<code>        let commit: Commit</code>
<code>        if case .success(let fetchedCommit) = result {</code>
<code>            commit = fetchedCommit</code>
<code>        } else {</code>
<code>            commit = Commit(message: "Failed to load commits", author: "", date: "")</code>
<code>        }</code>
<code>        let entry = LastCommitEntry(date: currentDate, commit: commit)</code>
<code>        let timeline = Timeline(entries: [entry], policy: .after(refreshDate))</code>
<code>        completion(timeline)</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>The <code>policy</code> property of the timeline is what defines <b>when</b> should iOS attempt to discard this timeline and fetch a new one. Currently, they can be <code>.never</code> (Widgets displaying a static content that never changes), <code>.atEnd</code> (when the last entry in the timeline is displayed), or <code>.after(Date)</code>, which is after a specific amount of time after displaying the timeline for the first time. Since our timeline only has one entry, I decided to use <code>.after</code> to tell iOS that this widget should be reloaded every 5 minutes.</p>
 <p>Note, however, that the Widget API's documentation states that you <b>can't predict when the Widget will be updated.</b> Even though the timeline itself will be indeed fetched again after 5 minutes, there's no guarantee that the iOS will update the view at the same time. From my personal experience when writing this, the view actually took around <b>~20 minutes</b> to update by itself. The update time is based on a few factors, which includes how often the Widget is seen by the user. If you need to <b>force</b> a Widget to update, you can use the <code>WidgetCenter</code> APIs from your main app to reload all timelines (or a specific one):</p>
 <pre>
<code>WidgetCenter.shared.reloadAllTimelines()</code>
</pre>
 <p>While not necessary by our Widget, it's important to mention that timelines and entries have other interesting capabilities. For example, it's possible to set a <b>relevance</b> value to an entry, which will allow iOS to determine how important your Widget is. This is used, for example, to determine the order of Widgets inside a stack:</p>
 <pre>
<code>struct LastCommit: TimelineEntry {</code>
<code>    public let date: Date</code>
<code>    public let commit: Commit</code>
<code></code>
<code>    var relevance: TimelineEntryRelevance? {</code>
<code>        return TimelineEntryRelevance(score: 10) // 0 - not important | 100 - very important</code>
<code>    }</code>
<code>}</code>
</pre>
 <h2>Creating a Widget View</h2>
 <p>Now that our timeline is configured, we can create the Widget's visual components. We need to create <b>two</b> views: A <b>placeholder</b> that is displayed while the timeline is loading, and the actual Widget view that is capable of rendering our timeline entry.</p>
 <pre>
<code>struct PlaceholderView : View {</code>
<code>    var body: some View {</code>
<code>        Text("Loading...")</code>
<code>    }</code>
<code>}</code>
<code></code>
<code>struct CommitCheckerWidgetView : View {</code>
<code>    let entry: LastCommitEntry</code>
<code></code>
<code>    var body: some View {</code>
<code>        VStack(alignment: .leading, spacing: 4) {</code>
<code>            Text("apple/swift's Latest Commit")</code>
<code>                .font(.system(.title3))</code>
<code>                .foregroundColor(.black)</code>
<code>            Text(entry.commit.message)</code>
<code>                .font(.system(.callout))</code>
<code>                .foregroundColor(.black)</code>
<code>                .bold()</code>
<code>            Text("by \(entry.commit.author) at \(entry.commit.date)")</code>
<code>                .font(.system(.caption))</code>
<code>                .foregroundColor(.black)</code>
<code>            Text("Updated at \(Self.format(date:entry.date))")</code>
<code>                .font(.system(.caption2))</code>
<code>                .foregroundColor(.black)</code>
<code>        }.frame(minWidth: 0, maxWidth: .infinity, minHeight: 0, maxHeight: .infinity, alignment: .leading)</code>
<code>            .padding()</code>
<code>            .background(LinearGradient(gradient: Gradient(colors: [.orange, .yellow]), startPoint: .top, endPoint: .bottom))</code>
<code>    }</code>
<code></code>
<code>    static func format(date: Date) -&gt; String {</code>
<code>        let formatter = DateFormatter()</code>
<code>        formatter.dateFormat = "MM-dd-yyyy HH:mm"</code>
<code>        return formatter.string(from: date)</code>
<code>    }</code>
<code>}</code>
</pre>
 <h3>Interacting with a Widget View</h3>
 <p>Optionally, you can detect taps in your Widget and redirect them to a deeplink. This is unfortunately the only interaction you're allowed to have in your widget, so no scrolling or other forms of interaction are possible.</p>
 <p>You can configure which deeplink is triggered when your Widget is tapped through the <code>.widgetURL(myDeeplink)</code> method, but you can also make different parts of the widget trigger different deeplinks by using a <code>Link</code>. Note that since widgets are small, you shouldn't pack a ton of actions into a single Widget.</p>
 <p>Here's an example of a Widget View that redirects to the app's home screen when tapped, but also contains two labels that redirect to different parts of the app when tapped.</p>
 <pre>
<code>var body: some View {</code>
<code>    VStack {</code>
<code>        Link(destination: homeDeepLink) {</code>
<code>            Text("Home")</code>
<code>        }</code>
<code>        Link(destination: settingsDeepLink) {</code>
<code>            Text("Settings")</code>
<code>        }</code>
<code>    }.widgetURL(homeDeeplink)</code>
<code>}</code>
</pre>
 <p>If you don't provide a <code>widgetURL</code>, your app will simply open when tapped.</p>
 <h2>Seeing the Widget in action</h2>
 <p>You should be able to compile your code, and now that all components were provided, we can take a second look at our configuration method to see how this is all wrapped together:</p>
 <pre>
<code>@main</code>
<code>struct CommitCheckerWidget: Widget {</code>
<code>    private let kind: String = "CommitCheckerWidget"</code>
<code></code>
<code>    public var body: some WidgetConfiguration {</code>
<code>        StaticConfiguration(kind: kind, provider: CommitTimeline(), placeholder: PlaceholderView()) { entry in</code>
<code>            CommitCheckerWidgetView(entry: entry)</code>
<code>        }</code>
<code>        .configurationDisplayName("Swift's Latest Commit")</code>
<code>        .description("Shows the last commit at the Swift repo.")</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>We've created a static widget that fetches its content from our <code>CommitTimeline</code>, has a <code>PlaceholderView</code> as a placeholder and generates a <code>CommitCheckerWidgetView</code> when an entry is ready to be displayed.</p>
 <p>After running our app and adding the Widget to our home, we're now able to see an auto-updating Swift commit displayer!</p>
 <div class="post-image margin-top-40 margin-bottom-40"> 
  <img src="https://i.imgur.com/h8bBgyJ.jpg" alt=""> 
 </div>
 <h2>Allowing the user to configure which repo / branch to visualize</h2>
 <p>As mentioned before, iOS 14's new APIs also support Widgets that are tied to <b>Siri Intents</b>, allowing you to create dynamic Widgets that are configurable by your users. We can have an intent-based Widget that allows the user to configure which repo to watch, directly from the Widget itself.</p>
 <p>To create an intent-based Widget, we first need a Siri intent. Inside your Widget Extensions, add a <b>SiriKit Intent Definition File</b>.</p>
 <p>To allow the user to see the commits of any repo or branch, let's create a <code>LastCommitIntent</code> that supports the <b>account</b>, <b>repo</b> and <b>branch</b> properties. Make sure to also tick the <b>Intent is eliglible for Widgets</b> box.</p>
 <div class="post-image margin-top-40 margin-bottom-40"> 
  <img src="https://i.imgur.com/3HuvF8V.png" alt=""> 
 </div>
 <p>It's possible to use Widgets with the data of any donated Siri Intent, but the magic lies in not needing to. If the intent has widget capabilities, like the one we created, you're able to set the parameters <b>directly at the Widget</b> as we'll see later on.</p>
 <p>Before upgrading our Widget, let's make sure our code supports fetching commits from other repos. Let's upgrade our timeline entry to support a repo configuration:</p>
 <pre>
<code>struct RepoBranch {</code>
<code>    let account: String</code>
<code>    let repo: String</code>
<code>    let branch: String</code>
<code>}</code>
<code></code>
<code>struct LastCommit: TimelineEntry {</code>
<code>    public let date: Date</code>
<code>    public let commit: Commit</code>
<code>    public let branch: RepoBranch</code>
<code>}</code>
</pre>
 <p>From here, we can upgrade our fetcher's <code>fetch()</code> method to download any branch from any repo:</p>
 <pre>
<code>static func fetch(account: String, repo: String, branch: String, completion: @escaping (Result
   <commit, error>
    ) -&gt; Void) {
   </commit,></code>
<code>    let branchContentsURL = URL(string: "https://api.github.com/repos/\(account)/\(repo)/branches/\(branch)")!</code>
<code>    // ...</code>
<code>}</code>
</pre>
 <p>As mentioned before, intents-based Widgets require the usage of <code>IntentConfiguration</code>, whose's only major difference from our previous static approach is that we have to provide the intent which this widget is linked to. Let's update our Widget to use <code>IntentConfiguration</code> and <code>LastCommitIntent</code>:</p>
 <pre>
<code>@main</code>
<code>struct CommitCheckerWidget: Widget {</code>
<code>    private let kind: String = "CommitCheckerWidget"</code>
<code></code>
<code>    public var body: some WidgetConfiguration {</code>
<code>        IntentConfiguration(kind: kind, intent: LastCommitIntent.self, provider: CommitTimeline(), placeholder: PlaceholderView()) { entry in</code>
<code>            CommitCheckerWidgetView(entry: entry)</code>
<code>        }</code>
<code>        .configurationDisplayName("A Repo's Latest Commit")</code>
<code>        .description("Shows the last commit at the a repo/branch combination.")</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>One additional modification we have to make is updating our timeline to inherit from <code>IntentTimelineProvider</code> instead of <code>TimelineProvider</code>. They work mostly the same way, with the difference being that the intents variant provides access to an instance of our intent, allowing us to grab a hold of any customizations made by our users. In this case, we'll update <code>snapshot()</code> to additionally return a fake repo and our timeline method to fetch the user's repo configuration and fetch the commit using those parameters.</p>
 <pre>
<code>struct CommitTimeline: IntentTimelineProvider {</code>
<code>    typealias Entry = LastCommit</code>
<code>    typealias Intent = LastCommitIntent</code>
<code></code>
<code>    public func snapshot(for configuration: LastCommitIntent, with context: Context, completion: @escaping (LastCommit) -&gt; ()) {</code>
<code>        let fakeCommit = Commit(message: "Fixed stuff", author: "John Appleseed", date: "2020-06-23")</code>
<code>        let entry = LastCommit(</code>
<code>            date: Date(),</code>
<code>            commit: fakeCommit,</code>
<code>            branch: RepoBranch(</code>
<code>                account: "apple",</code>
<code>                repo: "swift",</code>
<code>                branch: "main"</code>
<code>            )</code>
<code>        )</code>
<code>        completion(entry)</code>
<code>    }</code>
<code></code>
<code>    public func timeline(for configuration: LastCommitIntent, with context: Context, completion: @escaping (Timeline&lt;Entry&gt;) -&gt; ()) {</code>
<code>        let currentDate = Date()</code>
<code>        let refreshDate = Calendar.current.date(byAdding: .minute, value: 5, to: currentDate)!</code>
<code></code>
<code>        guard let account = configuration.account,</code>
<code>              let repo = configuration.repo,</code>
<code>              let branch = configuration.branch</code>
<code>        else {</code>
<code>            let commit = Commit(message: "Failed to load commits", author: "", date: "")</code>
<code>            let entry = LastCommit(date: currentDate, commit: commit, branch: RepoBranch(</code>
<code>                account: "???",</code>
<code>                repo: "???",</code>
<code>                branch: "???"</code>
<code>            ))</code>
<code>            let timeline = Timeline(entries: [entry], policy: .after(refreshDate))</code>
<code>            completion(timeline)</code>
<code>            return</code>
<code>        }</code>
<code></code>
<code>        CommitLoader.fetch(account: account, repo: repo, branch: branch) { result in</code>
<code>            let commit: Commit</code>
<code>            if case .success(let fetchedCommit) = result {</code>
<code>                commit = fetchedCommit</code>
<code>            } else {</code>
<code>                commit = Commit(message: "Failed to load commits", author: "", date: "")</code>
<code>            }</code>
<code>            let entry = LastCommit(date: currentDate, commit: commit, branch: RepoBranch(</code>
<code>                account: account,</code>
<code>                repo: repo,</code>
<code>                branch: branch</code>
<code>            ))</code>
<code>            let timeline = Timeline(entries: [entry], policy: .after(refreshDate))</code>
<code>            completion(timeline)</code>
<code>        }</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>While this code works, our view still has "apple/swift" hardcoded into it. Let's update it to use the new parameters the entry now possesses:</p>
 <pre>
<code>struct RepoBranchCheckerEntryView : View {</code>
<code>    var entry: Provider.Entry</code>
<code></code>
<code>    var body: some View {</code>
<code>        VStack(alignment: .leading, spacing: 4) {</code>
<code>            Text("\(entry.branch.account)/\(entry.branch.repo)'s \(entry.branch.branch) Latest Commit")</code>
<code>                .font(.system(.title3))</code>
<code>                .foregroundColor(.black)</code>
<code>            Text("\(entry.commit.message)")</code>
<code>                .font(.system(.callout))</code>
<code>                .foregroundColor(.black)</code>
<code>                .bold()</code>
<code>            Text("by \(entry.commit.author) at \(entry.commit.date)")</code>
<code>                .font(.system(.caption))</code>
<code>                .foregroundColor(.black)</code>
<code>            Text("Updated at \(Self.format(date:entry.date))")</code>
<code>                .font(.system(.caption2))</code>
<code>                .foregroundColor(.black)</code>
<code>        }.frame(minWidth: 0, maxWidth: .infinity, minHeight: 0, maxHeight: .infinity, alignment: .leading)</code>
<code>            .padding()</code>
<code>            .background(LinearGradient(gradient: Gradient(colors: [.orange, .yellow]), startPoint: .top, endPoint: .bottom))</code>
<code>    }</code>
<code></code>
<code>    static func format(date: Date) -&gt; String {</code>
<code>        let formatter = DateFormatter()</code>
<code>        formatter.dateFormat = "MM-dd-yyyy HH:mm"</code>
<code>        return formatter.string(from: date)</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>Now, run your app and check the Widget. The repo configuration you see will be determined by the default value you added in the intents file, but if you long press your Widget and click the <b>Edit</b> button, you will now be able to customize the intent's parameters and change the repo that is fetched!</p>
 <div class="post-image margin-top-40 margin-bottom-40"> 
  <img src="https://i.imgur.com/NvMfu2e.jpg" alt=""> 
 </div>
 <div class="post-image margin-top-40 margin-bottom-40"> 
  <img src="https://i.imgur.com/mu8tBgl.jpg" alt=""> 
 </div>
 <h2>Supporting Multiple Widgets</h2>
 <p>It's possible to make your app provide <b>multiple</b> choices of Widgets by creating a <code>WidgetBundle</code> that returns the <code>WidgetConfiguration</code> of one or more Widgets. To do so, you need to remove the <code>@main</code> declaration of your main Widget's configuration and instead add it to a new bundle struct:</p>
 <pre>
<code>@main</code>
<code>struct SwiftWidgetsBundle: WidgetBundle {</code>
<code>    @WidgetBundleBuilder</code>
<code>    var body: some Widget {</code>
<code>        RepoBranchChecker()</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>You can then support multiple Widgets by simply adding more configurations to this bundle:</p>
 <pre>
<code>@main</code>
<code>struct SwiftWidgetsBundle: WidgetBundle {</code>
<code>    @WidgetBundleBuilder</code>
<code>    var body: some Widget {</code>
<code>        RepoBranchChecker()</code>
<code>        CommitNumberChecker()</code>
<code>        AppleOpenSourceProjectsChecker()</code>
<code>    }</code>
<code>}</code>
</pre>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>With this in place, when trying to add a Widget from your app, you'll be able to see the additional Widget options by swiping.</p>
 <h2>Where to go from here?</h2>
 <p>There are further customizations you can do Widgets, including rendering different info depending on the container size of the Widget, locking the possible Widget sizes and more. Check WWDC 2020's sessions for more information on Widgets.</p>
</div>]]></description>
</item>
<item>
    <title>Benefits of using throwing functions (try) - Swift's most underrated feature?</title>
    <link>https://swiftrocks.com/benefits-of-throwing-functions-try-swift-underrated-feature</link>
    <guid>https://swiftrocks.com/benefits-of-throwing-functions-try-swift-underrated-feature</guid>
    <pubDate>Tue, 16 Jun 2020 09:00:00 GMT-3</pubDate>
<description><![CDATA[
 
  
  <!--WRITEIT_POST_NAME=Benefits of using throwing functions (try) - Swift's most underrated feature?--> 
  <!--WRITEIT_POST_HTML_NAME=benefits-of-throwing-functions-try-swift-underrated-feature--> 
  <!--Add here the additional properties that you want each page to possess.--> 
  <!--These properties can be used to change content in the template page or in the page itself as shown here.--> 
  <!--Properties must start with 'WRITEIT_POST'.--> 
  <!--Writeit provides and injects WRITEIT_POST_NAME and WRITEIT_POST_HTML_NAME by default.--> 
  <!--WRITEIT_POST_SHORT_DESCRIPTION=I've always found throwing functions to be a very underrated feature in the Swift community. In this article, I've separated some of the benefits of this feature that have drawn my attention the most and shared some of my thoughts on why you should give it a second chance.--> 
  <!--WRITEIT_POST_SITEMAP_DATE_LAST_MOD=2020-06-16T14:00:00+02:00--> 
  <!--WRITEIT_POST_SITEMAP_DATE=2020-06-16T14:00:00+02:00--> 
  <title>Benefits of using throwing functions (try) - Swift's most underrated feature?</title>  
 

<div class="blog-post"> 
 <div class="post-title-index">  
  <h1>Benefits of using throwing functions (try) - Swift's most underrated feature?</h1>
 </div> 
 <div class="post-info"> 
  <div class="category category-swift">
   Swift
  </div> 
  <div class="post-info-text">
   Published on 16 June 2020 
  </div> 
 </div>  
 <p>I've always found throwing functions (<code>try/catch</code>, or <code>do/catch</code>) to be a very underrated feature in the Swift community. While many native APIs from iOS rely on it, very few people seem to actually use them in their daily projects. Most people seem to either optionally unwrap them (<code>try?</code>) or use other features like the <code>Result</code> type, and in my opinion, this stems from the fact that unless your entire project is built around throwing, the parts that do use it are somewhat annoying to deal with, and don't look very nice code-wise:</p>
 <pre>
<code>func getAValue() -&gt; Int? {</code>
<code>    do {</code>
<code>        let content = try getAnInteger()</code>
<code>    } catch {</code>
<code>        return nil</code>
<code>    }</code>
<code>}</code>
</pre>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>I've personally avoided this feature a lot for these reasons in favor of things like <b>Promises</b> or the new <code>Result&lt;&gt;</code> type, but even then, I still felt that my way of handling errors wasn't good. In fact, I was often falling into the same pitfalls, just in different ways. When I recently refactored one of my open-source CLI tools, I noticed that parts of it would not only look better if they used throwing functions instead, but they also would be considerably easier to unit test. I decided to try it out by refactoring that tool to use this feature, but to avoid falling into that same pit, I made the <b>entire</b> tool rely on it.</p>
 <p>The results exceeded all of my expectations. With about ~80% of code coverage, the tool is now very easy to maintain and evolve thanks to the benefits of throwing functions. In this article, I've separated some of the benefits of this feature that have drawn my attention the most and shared some of my thoughts on why you should give it a second chance.</p>
 <h2>Throwing functions clean your code by allowing you to focus on what matters</h2>
 <p>When you need the value of something wrapped in the <code>Result</code> type, you must switch its result immediately. This will make your method responsible for handling any errors associated with that result:</p>
 <pre>
<code>func getUserProfile() -&gt; Result&lt;Profile, Error&gt; {</code>
<code>    let result = database.profileSchema</code>
<code>    switch result {</code>
<code>    case .success(let profileSchema)</code>
<code>        let profile = Profile(profileSchema)</code>
<code>        return .success(profile)</code>
<code>    case .error(let error)</code>
<code>        return .error(error)</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>This method now has <b>two responsibilities</b> which must ideally be covered by unit tests, which might not be your intention.</p>
 <p>When you use <code>try</code> in a method that is itself <code>throws</code>, you can <b>delegate the treatment of errors to the code that is actually interested in it.</b> This allows you to develop methods that only handle their success cases:</p>
 <pre>
<code>func getUserProfile() throws {</code>
<code>    let profileSchema = try database.profileSchema</code>
<code>    return Profile(profileSchema)</code>
<code>}</code>
</pre>
 <p>As you can see, I don't need to worry about the database failing to fetch the user's profile schema in this specific method because that's not the point of it -- someone else will handle it if it happens. With these changes, this method is now so short that it possibly doesn't even need to exist anymore -- it could be refactored to a simple `try Profile(database: database)` call (initializers can also be <code>throws</code>!). This benefit is especially visible when your access depends on multiple things that can fail:</p>
 <pre>
<code>func migrateDefaultsToDatabase() throws {</code>
<code>    let oldUserProfile = try defaultsWrapper.profileJSON</code>
<code>    let converted = try databaseConverter.convertToDatabaseFormat(oldUserProfile)</code>
<code>    try database.set(converted, to: .profile)</code>
<code>}</code>
</pre>
 <p>Without throwing functions, you would probably have to divide this operation into multiple methods.</p>
 <h2>Throwing functions allows you to better design / unit test fatal problems</h2>
 <p>In CLI tools, it's common to halt everything or cause a crash when something goes wrong, like failing to open a file:</p>
 <pre>
<code>func obfuscate(file: File) {</code>
<code>    guard let contents = open(file) else {</code>
<code>        preconditionFailure()</code>
<code>    }</code>
<code>    let obfuscatedVersion = obfuscate(string: contents) // can also crash internally!</code>
<code>    guard success = save(contents, toFile: file) else {</code>
<code>        preconditionFailure()</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>Not only this method is impossible to unit test by itself, but other unit tests might also trip these failure conditions and crash your test bundle entirely. While your iOS app probably doesn't crash in these conditions, I have seen my share of similar conditions: using an optional <code>try?</code>, returning things like <code>nil</code> or an empty string, logging the occurrence and having the methods who rely on this information be able to treat these special cases. This can be made better by using <code>Result</code>, but that can make you fall back to the previous issue: your methods now do more than they have to.</p>
 <p>Similar to the previous benefit, you can use <code>throws</code> here and defer the actual crash / failure to someone who is actually interested in it. In the case of my CLI tool, all fatal conditions will throw a special <code>FatalError</code>, which only results in a crash if handled by <code>main.swift</code>. In fact, <code>main.swift</code> is the only part of the code that even attempts to handle errors. Everything in the tool is delegate to it, which made the tool's code considerably cleaner.</p>
 <pre>
<code>func obfuscate(file: File) throws {</code>
<code>    let contents = try open(file)</code>
<code>    let obfuscatedVersion = try obfuscate(string: contents)</code>
<code>    try save(contents, toFile: file)</code>
<code>}</code>
</pre>
 <p>You can now unit test that this method succeeds if everything is fine and proceed with your life. It's not necessary to unit test this method's specific failure conditions because the errors are not only <b>not</b> coming from it, it also doesn't handle them -- it just sends them downstream.</p>
 <p>For reference, here's an example of a method in my CLI tool that generates a failure condition:</p>
 <pre>
<code>public func deobfuscate(crashFilePath: String, mapPath: String) throws {</code>
<code>    let crashFile = File(path: crashFilePath)</code>
<code>    let crash = try crashFile.read()</code>
<code>    let mapString = try File(path: mapPath).read()</code>
<code>    guard let map = ConversionMap(mapString: mapString) else {</code>
<code>        throw logger.fatalError(forMessage: "Failed to parse conversion map. Have you passed the correct file?")</code>
<code>    }</code>
<code>    let result = replace(crashLog: crash, withContentsOfMap: map)</code>
<code>    try crashFile.write(contents: result)</code>
<code>}</code>
</pre>
 <p>Custom errors can be made by creating enums that conform to <code>Error</code>. Personally, I like making my custom error inherit from <code>LocalizedError</code> to make <code>error.localizedDescription</code> return a custom description. This can be done by implementing its <code>errorDescription</code> property. (implementing <code>localizedDescription</code> directly doesn't work)</p>
 <pre>
<code>public enum SwiftShieldError: Error, LocalizedError {</code>
<code>    case fatal(String)</code>
<code></code>
<code>    public var errorDescription: String? {</code>
<code>        switch self {</code>
<code>        case .fatal(let message):</code>
<code>            return message</code>
<code>        }</code>
<code>    }</code>
<code>}</code>
<code></code>
<code>public func fatalError(forMessage message: String) -&gt; Error {</code>
<code>    SwiftShieldError.fatal(message)</code>
<code>}</code>
</pre>
 <h2>XCTestCase has special support for throwing methods</h2>
 <p>Perhaps my favorite benefit is that <b>XCTestCase can automatically handle failures in throwing functions.</b> Here's a classic example on how would I unit test something that used <code>Result</code>:</p>
 <pre>
<code>func testSomethingUsingResult() {</code>
<code>    let result: Result&lt;String, Error&gt; = getAResult()</code>
<code>    guard let string = result.get() else {</code>
<code>        XCTFail()</code>
<code>    } // You could also use the new XCTUnwrap here.</code>
<code>    XCTAssertEqual(string, "aString")</code>
<code>}</code>
</pre>
 <p>Having to bypass error conditions tests is very annoying. Fortunately, XCTestCase allows you to mark any test method as <code>throws</code>, making it automatically fail the test if it throws. By making the example's <code>getAResult()</code> become a throwing <code>getAString()</code> instead, you can refactor this test to a single line and completely ignore the failure conditions.</p>
 <pre>
<code>func testSomethingUsingTryCatch() throws {</code>
<code>    XCTAssertEqual(try getAString(), "aString")</code>
<code>}</code>
</pre>
 <p>If you would like to do the reverse, which is testing if something fails, there's no need to switch the result -- you can use the special <code>XCTAssertThrowsError</code> method. You can also use <code>XCTAssertNoThrow</code> to test that something succeeds when the result itself isn't what is being tested.</p>
 <p>In general, what I like about this is that I don't need to consider failure cases when the test subject itself isn't the one throwing the errors. If I want to test that this method is working, all I have to do is test its success cases. If anything fails upstream, the test will throw an error and fail. This makes unit testing considerably easier and faster, while still being very durable (if not <b>more</b> durable, in my opinion).</p>
 <h2><code>Result</code> can be translated from/to throwing functions</h2>
 <p>Although <code>Result</code> is sometimes seen as the opposite to throwing functions, they are actually somewhat interchangeable. It's possible to build <code>Result</code> types from throwing operations and get throwing operations from existing <code>Result</code> instances, which might be helpful if you'd like to play with throwing functions in a project without fully commiting to it.</p>
 <pre>
<code>let result: Result&lt;String, Error&gt; = Result(catching: { try file.read() })</code>
<code>let contents = try result.get()</code>
</pre>
 <h2>Conclusion</h2>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>Using throwing functions has been extremely beneficial in my new project, but as I said in the beginning, you might find that most of these benefits only apply if your project is <b>completely</b> using them to handle errors. Still, even if you don't have a full project, you can use <code>Result</code>'s special initializers to treat the gaps and benefit from cleaner methods and more durable unit tests.</p>
 <p>The project in question is <a href="https://github.com/rockbruno/swiftshield">SwiftShield</a>. Make sure to check it out (especially the test cases!) to see how these benefits are translated to code.</p>
</div>]]></description>
</item>
<item>
    <title>How Random Numbers Work In Swift</title>
    <link>https://swiftrocks.com/how-random-numbers-work-in-swift</link>
    <guid>https://swiftrocks.com/how-random-numbers-work-in-swift</guid>
    <pubDate>Tue, 12 May 2020 09:00:00 GMT-3</pubDate>
<description><![CDATA[
 
  
  <!--WRITEIT_POST_NAME=How Random Numbers Work In Swift--> 
  <!--WRITEIT_POST_HTML_NAME=how-random-numbers-work-in-swift--> 
  <!--Add here the additional properties that you want each page to possess.--> 
  <!--These properties can be used to change content in the template page or in the page itself as shown here.--> 
  <!--Properties must start with 'WRITEIT_POST'.--> 
  <!--Writeit provides and injects WRITEIT_POST_NAME and WRITEIT_POST_HTML_NAME by default.--> 
  <!--WRITEIT_POST_SHORT_DESCRIPTION=Let's see how to use the new APIs, but most importantly, how they are implemented inside the Swift compiler.--> 
  <!--WRITEIT_POST_SITEMAP_DATE_LAST_MOD=2020-05-12T14:00:00+02:00--> 
  <!--WRITEIT_POST_SITEMAP_DATE=2020-05-12T14:00:00+02:00--> 
  <title>How Random Numbers Work In Swift</title>  
 

<div class="blog-post"> 
 <div class="post-title-index">  
  <h1>How Random Numbers Work In Swift</h1>
 </div> 
 <div class="post-info"> 
  <div class="category category-compiler">
   Compiler
  </div> 
  <div class="category category-swift">
   Swift
  </div> 
  <div class="post-info-text">
   Published on 12 May 2020 
  </div> 
 </div>  
 <p>Before Swift 4.2, generating random numbers involved using raw C APIs. With the addition of the <b>RandomNumberGenerator</b> protocol in Swift 4.2, developers were graced with an easy way to generate random numbers. Let's see how to use the new APIs, but most importantly, <b>how they are implemented inside the Swift compiler</b>.</p>
 <h2>RandomNumberGenerator</h2>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>Deep down, the generation of random numbers in Swift still works exactly like before. The difference is that Swift 4.2 introduced some nice abstractions on top of it in the form of protocols -- allowing you to create your own randomization algorithms if you need to.</p>
 <p>The generation of random numbers in Swift begins with <b>RandomNumberGenerator</b> -- a protocol that does nothing but generate random <b>UInt64</b> values:</p>
 <pre>
<code>public protocol RandomNumberGenerator {</code>
<code>    mutating func next() -&gt; UInt64</code>
<code>}</code>
</pre>
 <p>Types that can access/generate random values are meant to receive an implementation of this protocol, generate a (possibly very big) random number and use it to determine which value to return (for example, by calculating <b>randomNumber % range.upperBound</b>).</p>
 <p>The Swift Standard Library provides an all-purpose implementation of <b>RandomNumberGenerator</b> called <b>SystemRandomNumberGenerator</b>, which pulls a random number from the innards of the compiler.</p>
 <pre>
<code>public struct SystemRandomNumberGenerator: RandomNumberGenerator {</code>
<code>  public mutating func next() -&gt; UInt64 {</code>
<code>      var random: UInt64 = 0</code>
<code>      swift_stdlib_random(&amp;random, MemoryLayout&lt;UInt64&gt;.size)</code>
<code>      return random</code>
<code>  }</code>
<code>}</code>
</pre>
 <p>The actual random mechanism used differs by platform, but is guaranteed to be type-safe in all of them. For Apple platforms, the compiler uses <b>arc4random_buf</b> (whose functionality requires a separate article):</p>
 <pre>
<code>#if defined(__APPLE__)</code>
<code></code>
<code>SWIFT_RUNTIME_STDLIB_API</code>
<code>void swift::swift_stdlib_random(void *buf, __swift_size_t nbytes) {</code>
<code>  arc4random_buf(buf, nbytes);</code>
<code>}</code>
</pre>
 <h2>Swift Random APIs</h2>
 <p>From Swift 4.2, numeric types like <b>Int</b>, <b>Float</b> and <b>Bool</b> can generate random numbers through the new <b>.random(in:)</b> APIs:</p>
 <pre>
<code>let randomInt = Int.random(in: 1..&lt;5)</code>
<code>let randomFloat = Float.random(in: 1..&lt;10)</code>
<code>let randomBool = Bool.random()</code>
</pre>
 <p>All of these APIs support taking a <b>RandomNumberGenerator</b> argument, but you're allowed to not provide one, as the compiler is rigged to use <b>SystemRandomNumberGenerator</b> by default. For example, here's how the default API for <b>Bool</b> is defined:</p>
 <pre>
<code>public static func random() -&gt; Bool {</code>
<code>    var g = SystemRandomNumberGenerator()</code>
<code>    return Bool.random(using: &amp;g)</code>
<code>}</code>
</pre>
 <h3>Bool.random()</h3>
 <p>In the case of <b>Bool</b>, the full implementation of the API will get the raw <b>UInt64</b> value from the generator, bit shift it to the right 17 times, and return true if the first bit of the resulting value is <b>0</b>.</p>
 <pre>
<code>public static func random&lt;T: RandomNumberGenerator&gt;(</code>
<code>    using generator: inout T</code>
<code>) -&gt; Bool {</code>
<code>    return (generator.next() &gt;&gt; 17) &amp; 1 == 0</code>
<code>}</code>
</pre>
 <p>The reason the value is shifted exactly <b>17</b> times is that (some) weak RNGs have better randomness properties in the middle bits over the low/high bits, and the Swift team felt like protecting us from APIs that decided to use these RNGs instead of the default <b>SystemRandomNumberGenerator</b>. Before the PR that implemented this improvement, <b>Bool.random()</b> used to simply return <b>generator.next() % 2 == 0</b>.</p>
 <h3>Int.random() and others</h3>
 <p>The implementation of the random API for other numeric types is similar to <b>Bool</b>, with the difference being how the value is pre/post-processed. For example, for <b>..&lt;</b> <b>Int</b> ranges, Swift calculates the distances between the bounds, generates a value, makes sure it's less than <b>upperBound</b> and adds <b>lowerBound</b> to it, resulting in a random value inside the requested range.</p>
 <pre>
<code>// Note: The actual implementation is slightly different than this</code>
<code>// because it treats compiler edge cases and uses some different types.</code>
<code>let delta = range.upperBound &amp;- range.lowerBound</code>
<code>return range.lowerBound + generator.next(upperBound: delta)</code>
</pre>
 <p>An interesting note is that <b>generator.next(upperBound: delta)</b> isn't simply a <b>value % delta</b> calculation -- it uses <b>Daniel Lemire‚Äôs ‚ÄúFast Random Integer Generation in Interval‚Äù algorithm</b>, which produces a higher quality result (for example, it avoids module bias).</p>
 <pre>
<code>public mutating func next&lt;T: FixedWidthInteger &amp; UnsignedInteger&gt;(</code>
<code>  upperBound: T</code>
<code>) -&gt; T {</code>
<code>  var random: T = next()</code>
<code>  var m = random.multipliedFullWidth(by: upperBound)</code>
<code>  if m.low &lt; upperBound {</code>
<code>    let t = (0 &amp;- upperBound) % upperBound</code>
<code>    while m.low &lt; t {</code>
<code>      random = next()</code>
<code>      m = random.multipliedFullWidth(by: upperBound)</code>
<code>    }</code>
<code>  }</code>
<code>  return m.high</code>
<code>}</code>
</pre>
 <p>A funny aspect of this algorithm is that it can, in theory, take <b>forever</b> to run as it has a <b>while</b> loop that continuously discards what it considers to be "low quality" values, but in reality, the odds of it being anything slower than "pretty much instant" are so low that you should never consider this.</p>
 <h2>randomElement()</h2>
 <p>To top it off, let's take a look at another API added in Swift 4.2: The <b>randomElement()</b> method for <b>Collections</b>, which returns a random element from the collection:</p>
 <pre>
<code>let string = ["Swift", "Rocks", "by", "Bruno", "Rocha"].randomElement()</code>
<code>// Bruno</code>
</pre>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p><b>randomElement()</b> is defined as a <b>Collection</b> extension, and simply grabs a random index through the <b>Int.random(in:)</b> method that we spelunked previously.</p>
 <pre>
<code>public func randomElement&lt;T: RandomNumberGenerator&gt;(</code>
<code>  using generator: inout T</code>
<code>) -&gt; Element? {</code>
<code>    guard !isEmpty else { return nil }</code>
<code>    let random = Int.random(in: 0 ..&lt; count, using: &amp;generator)</code>
<code>    let idx = index(startIndex, offsetBy: random)</code>
<code>    return self[idx]</code>
<code>}</code>
</pre>
 <p>Perhaps an interesting take here is that this is a global <b>Collection</b> extension, which means that this will work for <b>any</b> type of collection (usually, you would see something like this only for <b>RandomAccessCollections</b>). This also means that the runtime complexity of this method will vary depending on the collection, as <b>count</b> is only O(1) in <b>RandomAccessCollections</b>. In other types of collections, <b>count</b> is O(n).</p>
 <h2>References and Good Reads</h2>
 <a href="https://github.com/apple/swift/blob/master/stdlib/public/core/Random.swift">Random.swift</a>
 <br>
 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0202-random-unification.md">Random Unification</a>
 <br>
</div>]]></description>
</item>
<item>
    <title>iOS Responder Chain: UIResponder, UIEvent, UIControl and uses</title>
    <link>https://swiftrocks.com/understanding-the-ios-responder-chain</link>
    <guid>https://swiftrocks.com/understanding-the-ios-responder-chain</guid>
    <pubDate>Thu, 7 May 2020 10:00:00 GMT-3</pubDate>
<description><![CDATA[
 
  
  <!--WRITEIT_POST_NAME=iOS Responder Chain: UIResponder, UIEvent, UIControl and uses--> 
  <!--WRITEIT_POST_HTML_NAME=understanding-the-ios-responder-chain--> 
  <!--WRITEIT_POST_SITEMAP_DATE_LAST_MOD=2020-04-12T14:00:00+02:00--> 
  <!--WRITEIT_POST_SITEMAP_DATE=2020-05-07T13:00:00+00:00--> 
  <!--Add here the additional properties that you want each page to possess.--> 
  <!--These properties can be used to change content in the template page or in the page itself as shown here.--> 
  <!--Properties must start with 'WRITE_IT_POST'.--> 
  <!--Writeit provides and injects WRITEIT_POST_NAME and WRITEIT_POST_HTML_NAME by default.--> 
  <!--WRITEIT_POST_SHORT_DESCRIPTION=In iOS, the Responder Chain is the name given to an UIKit-generated linked list of UIResponder objects, and is the foundation for everything regarding events (like touch and motion) in iOS.--> 
  <title>iOS Responder Chain: UIResponder, UIEvent, UIControl and uses</title>  
 

<div class="blog-post"> 
 <div class="post-title-index">  
  <h1>iOS Responder Chain: UIResponder, UIEvent, UIControl and uses</h1>
 </div> 
 <div class="post-info"> 
  <div class="category category-ios">
   iOS
  </div> 
  <div class="post-info-text">
   Published on 01 Mar 2019 
  </div> 
 </div>   
 <i>What on earth is this "first responder" thing when I'm dealing with UITextFields?<br></i>
 <i>Why do UIViews subclass things like UIResponder?<br></i>
 <i>What's the point of these?<br><br></i>
 <p>In iOS, the <b>Responder Chain</b> is the name given to an UIKit-generated linked list of <code>UIResponder</code> objects, and is the foundation for everything regarding events (like touch and motion) in iOS.</p>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>The Responder Chain is something that you constantly deal with in the world of iOS development, and although you rarely have to directly deal with it outside of <code>UITextField</code> keyboard shenanigans, knowledge of how it works allows you to solve event-related problems in very easy/creative ways - you can even build architectures that rely on Responder Chains.</p>
 <h2>UIResponder, UIEvent and UIControl</h2>
 <p>In short, <code>UIResponder</code> instances represents objects that can handle and respond to arbitrary events. Many things in iOS are <code>UIResponders</code>, including <code>UIView</code>, <code>UIViewController</code>, <code>UIWindow</code>, <code>UIApplication</code> and <code>UIApplicationDelegate</code>.</p>
 <p>In turn, an <code>UIEvent</code> represents a single UIKit event that contains a type (touch, motion, remote-control and press) and an optional sub-type (like a specific device motion shake). When a system event like a screen touched is detected, UIKit internally creates <code>UIEvent</code> instances and dispatches it to the system event queue by calling <code>UIApplication.shared.sendEvent()</code>. When the event is retrieved from the queue, UIKit internally determines the first <code>UIResponder</code> capable of handling the event and sends it to the selected one. The selection process differs depending on the event type - while touch events go directly to the touched view itself, other event types will be dispatched to the so called <b>first responder</b>.</p>
 <p>In order to handle system events, <code>UIResponder</code> subclasses can register themselves as capable of handling specific <code>UIEvent</code> types by overriding the methods specific to that type:</p>
 <pre>
<code>open func touchesBegan(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?)</code>
<code>open func touchesMoved(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?)</code>
<code>open func touchesEnded(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?)</code>
<code>open func touchesCancelled(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?)</code>
<code>open func pressesBegan(_ presses: Set&lt;UIPress&gt;, with event: UIPressesEvent?)</code>
<code>open func pressesChanged(_ presses: Set&lt;UIPress&gt;, with event: UIPressesEvent?)</code>
<code>open func pressesEnded(_ presses: Set&lt;UIPress&gt;, with event: UIPressesEvent?)</code>
<code>open func pressesCancelled(_ presses: Set&lt;UIPress&gt;, with event: UIPressesEvent?)</code>
<code>open func motionBegan(_ motion: UIEvent.EventSubtype, with event: UIEvent?)</code>
<code>open func motionEnded(_ motion: UIEvent.EventSubtype, with event: UIEvent?)</code>
<code>open func motionCancelled(_ motion: UIEvent.EventSubtype, with event: UIEvent?)</code>
<code>open func remoteControlReceived(with event: UIEvent?)</code>
</pre>
 <p>In a way, you can see <code>UIEvents</code> as notifications on steroids. But although <code>UIEvents</code> can be subclassed and <code>sendEvent</code> can be manually called, they aren't really meant to played with - at least not through normal means. Because you can't create custom types, dispatching custom events is problematic as it's likely that your event will be incorrectly "handled" by an unintended responder. Still, there are ways for you to play with them - besides system events, <code>UIResponders</code> can also respond to arbitrary "actions" in the form of <code>Selectors</code>.</p>
 <p>The ability to do so was created to give macOS apps an easy way to respond to "menu" actions like select/copy/paste, as the existence of multiple windows in macOS makes simple delegation patterns are difficult to apply. In any case, they're also available for iOS and can be used for custom actions - which is exactly how <code>UIControls</code> like <code>UIButton</code> can dispatch actions after being touched. Consider the following button:</p>
 <pre>
<code>let button = UIButton(type: .system)</code>
<code>button.addTarget(myView, action: #selector(myMethod), for: .touchUpInside)</code>
</pre>
 <p>Although <code>UIResponders</code> can fully detect touch events, handling them isn't an easy task. How do you differ between different types of touches?</p>
 <p>That's where <code>UIControl</code> excels - these subclasses of <code>UIView</code> abstract the process of handling touch events and expose the ability to assign actions to specific touch events.</p>
 <p>Internally, touching this button results in the following:</p>
 <pre>
<code>let event = UIEvent(...) //An UIKit-generated touch event containing the touch position and properties.</code>
<code>//Dispatch a touch event.</code>
<code>//Through `hitTest()`, determine which UIView was "selected".</code>
<code>//Because an UIControl was selected, directly invoke its target:</code>
<code>UIApplication.shared.sendAction(#selector(myMethod), to: myView, from: button, for: event)</code>
</pre>
 <p>When a specific target is sent to <code>sendAction</code>, UIKit will directly attempt to call the desired selector at the desired target (crashing the app if it doesn't implement it) - but what if the target is <code>nil</code>?</p>
 <pre>
<code>final class MyViewController: UIViewController {</code>
<code>    @objc func myCustomMethod() {</code>
<code>        print("SwiftRocks!")</code>
<code>    }</code>
<code></code>
<code>    func viewDidLoad() {</code>
<code>        UIApplication.shared.sendAction(#selector(myCustomMethod), to: nil, from: view, for: nil)</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>If you run this, you'll see that even though the action was sent from a plain <code>UIView</code> with no target, <code>MyViewController's</code> <code>myCustomMethod</code> will be triggered!</p>
 <p>When no target is specified, UIKit will search for an <code>UIResponder</code> capable of handling this action just like in the plain <code>UIEvent</code> example. In this case, being able to handle an action relates to the following <code>UIResponder</code> method:</p>
 <pre>
<code>open func canPerformAction(_ action: Selector, withSender sender: Any?) -&gt; Bool</code>
</pre>
 <p>By default, this method simply checks if the responder implements the actual method. "Implementing" the method can be done in three ways, depending on how much info you want (this applies to any native action/target component in iOS!):</p>
 <pre>
<code>func myCustomMethod()</code>
<code>func myCustomMethod(sender: Any?)</code>
<code>func myCustomMethod(sender: Any?, event: UIEvent?)</code>
</pre>
 <p>Now, what if the responder doesn't implement the method? In this case, UIKit uses the following <code>UIResponder</code> method to determine how to proceed:</p>
 <pre>
<code>open func target(forAction action: Selector, withSender sender: Any?) -&gt; Any?</code>
</pre>
 <p>By default, this will return <b>another</b> <code>UIResponder</code> that <i>may or may not</i> be able to handle the desired action. This repeats until the action is handled or the app runs out of choices. But how does the responders know who to route actions to?</p>
 <h2>The Responder Chain</h2>
 <p>As mentioned in the beginning, UIKit handles this by dynamically managing a linked list of <code>UIResponders</code>. The so called <b>first responder</b> is simply the root element of the list, and if a responder can't handle a specific action/event, the action is recursively sent to the next responder of the list until someone can handle the action or the list ends.</p>
 <p>Although inspecting the actual first responder is protected by a private <code>firstResponder</code> property in <code>UIWindow</code>, you can check the Responder Chain for any given responder by checking the <code>next</code> property:</p>
 <pre>
<code>extension UIResponder {</code>
<code>    func responderChain() -&gt; String {</code>
<code>        guard let next = next else {</code>
<code>            return String(describing: self)</code>
<code>        }</code>
<code>        return String(describing: self) + " -&gt; " + next.responderChain()</code>
<code>    }</code>
<code>}</code>
<code></code>
<code>myViewController.view.responderChain()</code>
<code>// MyView -&gt; MyViewController -&gt; UIWindow -&gt; UIApplication -&gt; AppDelegate</code>
</pre>
 <div class="post-image margin-top-40 margin-bottom-40"> 
  <img src="https://i.imgur.com/922BVYT.png" alt="The Responder Chain"> 
 </div>
 <p>In the previous example where the action was handled by the <code>UIViewController</code>, UIKit first sent the action to the <code>UIView</code> first responder - but since it doesn't implement <code>myCustomMethod</code> the view forwarded the action to the next responder - the <code>UIViewController</code> which happened to have that method in its implementation.</p>
 <p>While in most cases the Responder Chain is simply be the order of the subviews, you can customize it to change the general flow order. Besides being able to override the <code>next</code> property to return something else, you can force an <code>UIResponder</code> to become the first responder by calling <code>becomeFirstResponder()</code> and have it go back to its position by calling <code>resignFirstResponder()</code>. This is commonly used in conjunction with <code>UITextField</code> to display a keyboard - <code>UIResponders</code> can define an optional <code>inputView</code> property that only shows up when the responder is the first responder, which is the keyboard in this case.</p>
 <h2>Responder Chain Custom Uses</h2>
 <p>Although the Responder Chain is fully handled by UIKit, you can use it in your favor to solve communication/delegation issues.</p>
 <p>In a way, you can see <code>UIResponder</code> actions as single-use notifications. Consider an app where almost every view supports a "blink" action for the purpose of helping the user navigate in a tutorial. How would make sure that only the current "active" view blinks when this action is triggered? Possible solutions include making every single view inherit a delegate or use a plain notification that everyone needs to ignore except the <code>"currentActiveView"</code>, but responder actions allow you to cleanly achieve this with zero delegates and minimal coding:</p>
 <pre>
<code>final class BlinkableView: UIView {</code>
<code>    override var canBecomeFirstResponder: Bool {</code>
<code>        return true</code>
<code>    }</code>
<code></code>
<code>    func select() {</code>
<code>        becomeFirstResponder()</code>
<code>    }</code>
<code></code>
<code>    @objc func performBlinkAction() {</code>
<code>        //Blinking animation</code>
<code>    }</code>
<code>}</code>
<code></code>
<code>UIApplication.shared.sendAction(#selector(BlinkableView.performBlinkAction), to: nil, from: nil, for: nil)</code>
<code>//Will precisely blink the last BlinkableView that had select() called.</code>
</pre>
 <p>This works pretty much like regular notifications, with the difference being that while notifications will trigger everyone that registers them, this efficiently iterates the Responder Chain and stops as soon as the first BlinkableView is found.</p>
 <p>As mentioned before, even architectures can be built out of this. Here's the skeleton of a Coordinator structure that defines a custom type of event and injects itself into the Responder Chain:</p>
 <pre>
<code>final class PushScreenEvent: UIEvent {</code>
<code></code>
<code>    let viewController: CoordenableViewController</code>
<code></code>
<code>    override var type: UIEvent.EventType {</code>
<code>        return .touches</code>
<code>    }</code>
<code></code>
<code>    init(viewController: CoordenableViewController) {</code>
<code>        self.viewController = viewController</code>
<code>    }</code>
<code>}</code>
<code></code>
<code>final class Coordinator: UIResponder {</code>
<code></code>
<code>    weak var viewController: CoordenableViewController?</code>
<code></code>
<code>    override var next: UIResponder? {</code>
<code>        return viewController?.originalNextResponder</code>
<code>    }</code>
<code></code>
<code>    @objc func pushNewScreen(sender: Any?, event: PushScreenEvent) {</code>
<code>        let new = event.viewController</code>
<code>        viewController?.navigationController?.pushViewController(new, animated: true)</code>
<code>    }</code>
<code>}</code>
<code></code>
<code>class CoordenableViewController: UIViewController {</code>
<code></code>
<code>    override var canBecomeFirstResponder: Bool {</code>
<code>        return true</code>
<code>    }</code>
<code></code>
<code>    private(set) var coordinator: Coordinator?</code>
<code>    private(set) var originalNextResponder: UIResponder?</code>
<code></code>
<code>    override var next: UIResponder? {</code>
<code>        return coordinator ?? super.next</code>
<code>    }</code>
<code></code>
<code>    override func viewDidAppear(_ animated: Bool) {</code>
<code>        //Fill info at viewDidAppear to make sure UIKit</code>
<code>        //has configured this view's next responder.</code>
<code>        super.viewDidAppear(animated)</code>
<code>        guard coordinator == nil else {</code>
<code>            return</code>
<code>        }</code>
<code>        originalNextResponder = next</code>
<code>        coordinator = Coordinator()</code>
<code>        coordinator?.viewController = self</code>
<code>    }</code>
<code>}</code>
<code></code>
<code>final class MyViewController: CoordenableViewController {</code>
<code>    //...</code>
<code>}</code>
<code></code>
<code>//From anywhere in the app:</code>
<code></code>
<code>let newVC = NewViewController()</code>
<code>UIApplication.shared.push(vc: newVC)</code>
</pre>
 <p>The way this works is that each <code>CoordenableViewController</code> holds a reference to its original next responder (the window), but overrides <code>next</code> to point to the <code>Coordinator</code> instead, which in turn points the window at its next responder.</p>
 <pre>
<code>// MyView -&gt; MyViewController -&gt; **Coordinator** -&gt; UIWindow -&gt; UIApplication -&gt; AppDelegate</code>
</pre>
 <p>This allows the <code>Coordinator</code> to receive system events, and by defining a new <code>PushScreenEvent</code> that contains info about a new view controller, we can dispatch a <code>pushNewScreen</code> action that is handled by these <code>Coordinators</code> to push new screens.</p>
 <p>With this structure, <code>UIApplication.shared.push(vc: newVC)</code> can be called from <b>anywhere</b> in the app without needing a single delegate or singleton as UIKit will make sure that only the current <code>Coordinator</code> is notified of this action, thanks to the Responder Chain.</p>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>The examples shown here were highly theoretical, but I hope this helped you understand the purpose and uses of the Responder Chain.</p>
 <p>Follow me on my Twitter - <a href="https://twitter.com/rockbruno_">@rockbruno_</a>, and let me know of any suggestions and corrections you want to share.</p>
 <h2>References and Good reads</h2>
 <a href="https://developer.apple.com/documentation/uikit/touches_presses_and_gestures/using_responders_and_the_responder_chain_to_handle_events">Using Responders and the Responder Chain to Handle Events</a>
 <br>
 <a href="https://developer.apple.com/documentation/uikit/uiresponder">UIResponder</a>
 <br>
 <a href="https://developer.apple.com/documentation/uikit/uievent">UIEvent</a>
 <br>
 <a href="https://developer.apple.com/documentation/uikit/uievent">UIControl</a>
 <br>
</div>]]></description>
</item>
<item>
    <title>Unit Testing Preprocessor Macros in Swift</title>
    <link>https://swiftrocks.com/unit-testing-preprocessor-macros-in-swift</link>
    <guid>https://swiftrocks.com/unit-testing-preprocessor-macros-in-swift</guid>
    <pubDate>Tue, 5 May 2020 09:00:00 GMT-3</pubDate>
<description><![CDATA[
 
  
  <!--WRITEIT_POST_NAME=Unit Testing Preprocessor Macros in Swift--> 
  <!--WRITEIT_POST_HTML_NAME=unit-testing-preprocessor-macros-in-swift--> 
  <!--Add here the additional properties that you want each page to possess.--> 
  <!--These properties can be used to change content in the template page or in the page itself as shown here.--> 
  <!--Properties must start with 'WRITEIT_POST'.--> 
  <!--Writeit provides and injects WRITEIT_POST_NAME and WRITEIT_POST_HTML_NAME by default.--> 
  <!--WRITEIT_POST_SHORT_DESCRIPTION=Macros are used to bring context to a build. Let's see how we can unit test their presence / absence while still keeping your app's unreachable code uncompiled.--> 
  <!--WRITEIT_POST_SITEMAP_DATE_LAST_MOD=2020-05-05T14:00:00+02:00--> 
  <!--WRITEIT_POST_SITEMAP_DATE=2020-05-05T14:00:00+02:00--> 
  <title>Unit Testing Preprocessor Macros in Swift</title>  
 

<div class="blog-post"> 
 <div class="post-title-index">  
  <h1>Unit Testing Preprocessor Macros in Swift</h1>
 </div> 
 <div class="post-info"> 
  <div class="category category-swift">
   Swift
  </div> 
  <div class="post-info-text">
   Published on 05 May 2020 
  </div> 
 </div>  
 <p><b>Preprocessor macros</b> are used to bring context to a build, allowing you to transform how your app is compiled depending on why it's being built.</p>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>In iOS, preprocessors are popularly used to determine which scheme was used to build an app. This allows you to build things such as <b>debug views</b> which are only visible in debug builds, additional logging for non-AppStore builds, and more. My favorite use of macros is using the Factory pattern to return mocked components for XCUITests:</p>
 <pre>
<code>enum HTTPClientFactory {</code>
<code>    static func createClient() -&gt; HTTPClient {</code>
<code>        #if TESTING</code>
<code>            return MockHTTPClient()</code>
<code>        #else</code>
<code>            return URLSessionHTTPClient()</code>
<code>        #end</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>Additionally, preprocessor macros have the incredible ability to change how your code is compiled. As the prefix "pre" implies, the value of a macro is tested <b>before</b> your code is compiled, meaning that everything in the "else" block of a preprocessor macros will <b>not</b> be present in the final binary. For things like debug views and mocked components, this is an amazing feature. As the code in the else block is ignored, a hacker that decompiles your app would not find a single trace that such features even existed.</p>
 <h2>Preprocessor Macros Unit Testing Issues</h2>
 <p>However, this same amazing feature also brings amazing problems. Since the code is ignored, you might have witnessed the fact that testing them can be very difficult. Unless you create multiple testing schemes with multiple macro settings (please don't do this), you are not easily able to test how your app behaves depending on the value of the macro -- only the value that your testing scheme is currently using. For example, in the <b>createClient()</b> snippet above, I would able to test that <b>createClient()</b> returns a <b>MockHTTPClient</b> as my testing scheme defines the <b>TESTING</b> macro, but I wouldn't be able to confirm that it returns a <b>URLSessionHTTPClient</b> in other situations.</p>
 <p>This might lead you to other alternatives, like using compiler arguments or a global property instead of the macro directly:</p>
 <pre>
<code>var isDebugging = false</code>
<code></code>
<code>func userDidShakeDevice() {</code>
<code>    if isDebugging {</code>
<code>        pushDebugMenu()</code>
<code>    }</code>
<code>}</code>
<code></code>
<code>func startApp() {</code>
<code>	#if DEBUG_SCHEME</code>
<code>	isDebugging = true</code>
<code>	#endif</code>
<code>	...</code>
<code>}</code>
</pre>
 <p>In this case, it's a lot easier for a unit test to override the value of the macro, as all we have to do is toggle the global <b>isDebugging</b> property. Unfortunately, while this works, you're giving up the macro's ability to erase your code. The usage of <b>if isDebugging</b> in this case tells the compiler that the execution of <b>userDidShakeDevice()</b> is <b>unknown</b> in compile time due to the fact that the value of that boolean can change any time. This would compile the <b>if</b> block even if you're running a non-debug build, allowing hackers to find the <b>pushDebugMenu()</b> method and use it for evil.</p>
 <h2>Leveraging Optimization Settings to Unit Test Preprocessor Macros</h2>
 <p>Fortunately, by leveraging the Swift Compiler's ability to ignore unused code, we can mix the best of both worlds and achieve macros that properly erase code and are easily testable at the same time.</p>
 <p>To explain how to achieve this, let's use a real example. In one of the companies I worked for, for bug-finding reasons, employees couldn't install AppStore builds -- only beta ones. This was done by detecting which build you had installed and checking your user's permissions to see if you were allowed to use it. Otherwise, you would get an alert showing you where to download the correct version. The detection part was done like this:</p>
 <pre>
<code>enum BuildType {</code>
<code>    case appStore</code>
<code>    case employeeBuild</code>
<code>    case xcodeBuild</code>
<code>}</code>
<code></code>
<code>var currentBuildType: BuildType {</code>
<code>    #if ENTERPRISE</code>
<code>    return .employeeBuild</code>
<code>    #elseif XCODE</code>
<code>    return .xcodeBuild</code>
<code>    #else</code>
<code>    return .appStore</code>
<code>    #endif</code>
<code>}</code>
</pre>
 <p>As we can see, this is exactly like our previous examples, with the exact same issues as we had no way to test that <b>currentBuildType</b> returned the correct build type for each build.</p>
 <p>Before learning how we can test this, let's clean this up by abstracting the macro checks into separate types:</p>
 <pre>
<code>enum EnterpriseMacro {</code>
<code>    static var active: Bool {</code>
<code>        #if ENTERPRISE</code>
<code>        return true</code>
<code>        #else</code>
<code>        return false</code>
<code>        #endif</code>
<code>    }</code>
<code>}</code>

<code>enum XcodeMacro {</code>
<code>    static var active: Bool {</code>
<code>        #if XCODE</code>
<code>        return true</code>
<code>        #else</code>
<code>        return false</code>
<code>        #endif</code>
<code>    }</code>
<code>}</code>
<code></code>
<code>var currentBuildType: BuildType {</code>
<code>    if EnterpriseMacro.active {</code>
<code>        return .employeeBuild</code>
<code>    } else if XcodeMacro.active {</code>
<code>        return .xcodeBuild</code>
<code>    } else {</code>
<code>        return .appStore</code>
<code>    }</code>
<code>}</code>
</pre>
 <h2>Wait! Doesn't this have the same problem as the global property example?</h2>
 <p>If this is what you thought, congratulations! The answer is <b>it depends</b>, and this is exactly what we're going to leverage to unit test this class. The global property is problematic because its value can change in runtime, but our macro type's <b>active</b> properties are <b>immutable</b>. If you compile your app without optimization (true for debug and testing builds), the compiler will behave exactly like in the global property example, but if you compile with optimization (true for release builds), since our active values are immutable, <b>the compiler will erase the unreachable parts of the code.</b></p>
 <p>We can confirm this by dumping Swift's SIL, which can be thought of as the final version of your code:</p>
 <pre>
<code>swiftc -emit-sil ./bla.swift -O -DXCODE</code>
</pre>
 <pre>
<code>// currentBuildType.getter</code>
<code>sil hidden @$s3bla16currentBuildTypeAA0cD0Ovg : $@convention(thin) () -&gt; BuildType {</code>
<code>bb0:</code>
<code>  %0 = enum $BuildType, #BuildType.xcodeBuild!enumelt // user: %1</code>
<code>  return %0 : $BuildType                          // id: %1</code>
<code>} // end sil function '$s3bla16currentBuildTypeAA0cD0Ovg'</code>
</pre>
 <p>The SIL indicates that when that file is compiled with optimization and the <b>XCODE</b> macro, <b>currentBuildType</b> instantly returns <b>.xcodeBuild</b>. Traces of the other build types in this method have been completely eliminated!</p>
 <p><i>(Note: This method still isn't hacker-proof because the other build types are still defined in the enum. Use this as an example of how to unit test macros, but consider the security necessities when implementing the trick shown in this article.)</i></p>
 <h2>Unit Testing the Macros</h2>
 <p>Finally, to test these macros, we can simply add a property to override its value when the macro isn't present:</p>
 <pre>
<code>protocol Macro {</code>
<code>    static var isOverridden: Bool { get set }</code>
<code>}</code>
<code></code>
<code>enum EnterpriseMacro: Macro {</code>
<code>    static var isOverridden = false</code>
<code></code>
<code>    static var active: Bool {</code>
<code>        #if ENTERPRISE</code>
<code>        return true</code>
<code>        #else</code>
<code>        return isOverridden</code>
<code>        #endif</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>Even though a hacker is able to force <b>isOverridden</b> to be <b>true</b>, nothing would be achieved as the code that ran as the result of the presence of this macro was never compiled.</p>
 <p>Changing <b>isOverridden</b> would only have an effect if we compiled our code without optimizations, which is exactly the case of unit testing targets. We can then use it to safely unit test <b>currentBuildType</b>.</p>
 <pre>
<code>func with&lt;T: Macro&gt;(macro: T.Type, block: () -&gt; Void) {</code>
<code>    macro.isOverridden = true</code>
<code>    block()</code>
<code>    macro.isOverridden = false</code>
<code>}</code>
<code></code>
<code>final class BuildTests: XCTestCase {</code>
<code>    func testEnterpriseBuild() {</code>
<code>        with(macro: EnterpriseMacro.self) {</code>
<code>            XCTAssertEqual(currentBuildType, .employeeBuild)</code>
<code>        }</code>
<code>    }</code>
<code></code>
<code>    func testDebugBuild() {</code>
<code>        with(macro: XcodeMacro.self) {</code>
<code>            XCTAssertEqual(currentBuildType, .xcodeBuild)</code>
<code>        }</code>
<code>    }</code>
<code></code>
<code>    func testProductionBuild() {</code>
<code>        // How it behaves when no macros are present</code>
<code>        XCTAssertEqual(currentBuildType, .appStore)</code>
<code>    }</code>
<code>}</code>
</pre>
 <p><i>(Note that because <b>isOverridden</b> only works when a macro isn't present in the build, your testing target should not contain macros whose's presence/absence needs to be tested.)</i></p>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>With this setup, we're able to test preprocessor macros while being sure that our final release builds will not contain code that's not meant to be executed. This same trick can be used to test macros in XCUITests.</p>
 <p>As a final note in the topic of security, note that if your intention is to <b>completely</b> get rid of something in runtime, everything needs to be wrapped by macro checks. In this case, if hiding the build types themselves was critical (and not just the logic of what's my current one), we would have to wrap the enum itself in macros, which would make unit testing it like this considerably harder, although still possible.</p>
</div>]]></description>
</item>
<item>
    <title>Discovering which DispatchQueue a method is running on</title>
    <link>https://swiftrocks.com/discovering-which-dispatchqueue-a-method-is-running-on</link>
    <guid>https://swiftrocks.com/discovering-which-dispatchqueue-a-method-is-running-on</guid>
    <pubDate>Tue, 28 Apr 2020 09:00:00 GMT-3</pubDate>
<description><![CDATA[
 
  
  <!--WRITEIT_POST_NAME=Discovering which DispatchQueue a method is running on--> 
  <!--WRITEIT_POST_HTML_NAME=discovering-which-dispatchqueue-a-method-is-running-on--> 
  <!--Add here the additional properties that you want each page to possess.--> 
  <!--These properties can be used to change content in the template page or in the page itself as shown here.--> 
  <!--Properties must start with 'WRITEIT_POST'.--> 
  <!--Writeit provides and injects WRITEIT_POST_NAME and WRITEIT_POST_HTML_NAME by default.--> 
  <!--WRITEIT_POST_SHORT_DESCRIPTION=DispatchQueue has lots of interesting and undocumented (unfortunately) hidden gems. Let's see how we can use one of these gems to get a method's current DispatchQueue -- a trick that can also be used to send and retrieve information from a DispatchQueue.--> 
  <!--WRITEIT_POST_SITEMAP_DATE_LAST_MOD=2020-04-30T15:40:00+02:00--> 
  <!--WRITEIT_POST_SITEMAP_DATE=2020-04-28T14:00:00+02:00--> 
  <title>Discovering which DispatchQueue a method is running on</title>  
 

<div class="blog-post"> 
 <div class="post-title-index">  
  <h1>Discovering which DispatchQueue a method is running on</h1>
 </div> 
 <div class="post-info"> 
  <div class="category category-ios">
   iOS
  </div> 
  <div class="post-info-text">
   Published on 28 Apr 2020 
  </div> 
 </div>  
 <p>The <b>DispatchQueue</b> class has lots of interesting and undocumented (unfortunately) hidden gems. Let's see how we can use one of these gems to <b>get a method's current DispatchQueue</b> -- a trick that can also be used to <b>send and retrieve information from a DispatchQueue</b>.</p>
 <h2>Why is this useful?</h2>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>When you have a specific method that can be executed from multiple queues, determining which queue it is running on can be useful. The reason I personally find this most useful for is <b>performance</b>: Imagine that you have a piece of code like this:</p>
 <pre>
<code>func doSomething() {</code>
<code>    queue.async { ... }</code>
<code>}</code>
</pre>
 <p>Dispatching code isn't very cheap, and if your queue has a low priority, there's no guarantee that it will be executed instantly. If <b>doSomething</b> is <b>already</b> running in the correct queue, you can detect this and avoid re-dispatching your code. For example, you can use the tricks from this article to prevent calling <b>DispatchQueue.main.async</b> unnecessarily when you need to update an UI element in the main queue. If you're already in the main queue, you can directly execute that piece of UI-updating code.</p>
 <p>Additionally, dispatching anything asynchronously can make you lose your stack trace. If something crashes inside an async queue, you might not be able to be see trace that precedes the execution of the dispatch queue as it might already be out of scope (after all, the code was dispatched asynchronously!). By avoiding unnecessary dispatches, you can have richer stack traces that will make debugging code and crashes easier.</p>
 <p>Lastly, as mentioned, you can also use this trick to <b>change how your method works depending on which queue it's running on</b>. Different queues can have different requirements -- especially lower priority ones. A low priority background thread can, for example, disable some logging features to make it run quicker.</p>
 <h2>Determining if a method is running on a specific DispatchQueue</h2>
 <p>Checking if a method is running on a specific queue can be done through a hidden gem: The <b>getSpecific</b> and <b>setSpecific</b> methods. <b>DispatchQueues</b> support holding a user info dictionary that behaves similarly to a <b>UserDefaults</b>, which can be retrieved globally without having access to the queue itself. You can use this to "tag" a queue and later determine if a method is running on it by checking if this tag exists in the method's current queue.</p>
 <p>To add data to a <b>DispatchQueue</b>'s dictionary, create a <b>DispatchSpecificKey&lt;T&gt;</b> instance that matches the type that you want to store and add to the queue by calling <b>setSpecific</b>.</p>
 <p>For example, here's how we can add an arbitrary string value a the queue:</p>
 <pre>
<code>let queue = DispatchQueue(label: "SwiftRocks")</code>
<code></code>
<code>let specificKey = DispatchSpecificKey&lt;String&gt;()</code>
<code>let valueToStore = "myValue"</code>
<code></code>
<code>queue.setSpecific(key: specificKey, value: valueToStore)</code>
</pre>
 <p>Now, from any method, you can check if it's running on this specific "SwiftRocks" queue by checking the result of <b>getSpecific</b>:</p>
 <pre>
<code>func doSomething() {</code>
<code>    if DispatchQueue.getSpecific(key: specificKey) == specificValue {</code>
<code>        print("Running on a thread from the 'SwiftRocks' queue.")</code>
<code>    } else {</code>
<code>        print("Not running on a thread from the 'SwiftRocks' queue.")</code>
<code>    }</code>
<code>}</code>
<code></code>
<code>doSomething() // Not running on a thread from the 'SwiftRocks' queue.</code>
<code>queue.sync { doSomething() } // Running on a thread from the 'SwiftRocks' queue.</code>
</pre>
 <h3>Passing information to a DispatchQueue</h3>
 <p>Storing multiple values that have the same type is slightly trickier, but doable. This is easy in the equivalent Objective-C <b>dispatch_queue_set_specific</b> method as the key value can be anything (just like a regular dictionary), but for some reason, in Swift this was bridged to the immutable <b>DispatchSpecificKey</b> type.</p>
 <p>Since everything is handled by reference, you can store multiple values of the same by creating different instances of <b>DispatchSpecificKey</b>. The downside is that you'll have to make sure that your methods can access the keys.</p>
 <pre>
<code>let recommendedNetworkTimeout = DispatchSpecificKey&lt;Int&gt;()</code>
<code>queue.setSpecific(key: recommendedNetworkTimeout, value: 30)</code>
<code></code>
<code>let recommendedRetryAmount = DispatchSpecificKey&lt;Int&gt;()</code>
<code>queue.setSpecific(key: recommendedRetryAmount, value: 3)</code>
<code></code>
<code>queue.sync {</code>
<code>    DispatchQueue.getSpecific(key: recommendedNetworkTimeout)</code>
<code>    DispatchQueue.getSpecific(key: recommendedRetryAmount)</code>
<code>}</code>
</pre>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>This is very useful if you need to create a set of "rules" that a method should follow that differs depending on the queue that it is running on. For example, like in the previous snippet, a background queue with a lower priority can have a shorter network retry amount than a user-facing one, and as another example, we could disable logging features for queues that are performance-critical:</p>
 <pre>
<code>public let loggingQueueKey = DispatchSpecificKey&lt;Bool&gt;()</code>
<code></code>
<code>extension DispatchQueue {</code>
<code>    public static var allowsLogging: Bool {</code>
<code>        return getSpecific(key: loggingQueueKey) ?? true</code>
<code>    }</code>
<code></code>
<code>    public func disableLogging() {</code>
<code>        setSpecific(key: loggingQueueKey, value: false)</code>
<code>    }</code>
<code></code>
<code>    public static func log(_ block: () -&gt; Void) {</code>
<code>        guard Self.allowsLogging else {</code>
<code>            return</code>
<code>        }</code>
<code>        block()</code>
<code>    }</code>
<code>}</code>
<code></code>
<code>queue.disableLogging()</code>
<code></code>
<code>func reloadContent() {</code>
<code>    DispatchQueue.log { print("Reloading content") }</code>
<code>    viewModel.reload()</code>
<code>    DispatchQueue.log { print("Content reloaded") }</code>
<code>}</code>
<code></code>
<code>reloadContent() // Prints</code>
<code>queue.sync { reloadContent() } // Doesn't print</code>
</pre>
 <p>This will allow you to have more control over your code, making choices that have performance benefits depending on a method's context, which leads to happier users.</p>
</div>]]></description>
</item>
<item>
    <title>Weak Dictionary Values in Swift</title>
    <link>https://swiftrocks.com/weak-dictionary-values-in-swift</link>
    <guid>https://swiftrocks.com/weak-dictionary-values-in-swift</guid>
    <pubDate>Tue, 14 Apr 2020 09:00:00 GMT-3</pubDate>
<description><![CDATA[
 
  
  <!--WRITEIT_POST_NAME=Weak Dictionary Values in Swift--> 
  <!--WRITEIT_POST_HTML_NAME=weak-dictionary-values-in-swift--> 
  <!--WRITEIT_POST_SITEMAP_DATE_LAST_MOD=2020-04-12T14:00:00+02:00--> 
  <!--WRITEIT_POST_SITEMAP_DATE=2020-04-14T14:00:00+02:00--> 
  <!--Add here the additional properties that you want each page to possess.--> 
  <!--These properties can be used to change content in the template page or in the page itself as shown here.--> 
  <!--Properties must start with 'WRITEIT_POST'.--> 
  <!--Writeit provides and injects WRITEIT_POST_NAME and WRITEIT_POST_HTML_NAME by default.--> 
  <!--WRITEIT_POST_SHORT_DESCRIPTION=When dealing with dictionaries and arrays in Swift, it's very important to know that any reference types used as a key or value will be retained by default.--> 
  <title>Weak Dictionary Values in Swift</title>  
 

<div class="blog-post"> 
 <div class="post-title-index">  
  <h1>Weak Dictionary Values in Swift</h1>
 </div> 
 <div class="post-info"> 
  <div class="category category-swift">
   Swift
  </div> 
  <div class="post-info-text">
   Published on 14 Apr 2020 
  </div> 
 </div>  
 <p>When dealing with dictionaries and arrays in Swift, it's very important to know that any reference types used as a key or value will be <b>retained by default.</b> Let's see some interesting cases where this behavior is problematic, and how we can use types like <code>NSMapTable</code>, <code>NSHashTable</code> and <code>NSPointerArray</code> to create weak collections that perform better than their Swift counterparts.</p>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>To visualize why the default memory management behavior of Swift dictionaries can sometimes be bad for you, let's attempt to build a system that uses dictionaries to store instances of some arbitrary types. We can use <a href="https://github.com/rockbruno/RouterService">RouterService's</a> dependency management system as an example:</p>
 <pre>
<code>protocol Dependency: AnyObject {</code>
<code>    static var identifier: String { get }</code>
<code>}</code>
<code></code>
<code>final class DependencyStore {</code>
<code></code>
<code>    var factories = [String: () -&gt; Dependency]()</code>
<code>    var cachedDependencies = [String: Dependency]()</code>
<code></code>
<code>    func register&lt;T: Dependency&gt;(dependencyFactory: @escaping () -&gt; T) {</code>
<code>        let key = T.identifier</code>
<code>        factories[key] = dependencyFactory</code>
<code>    }</code>
<code></code>
<code>    func getInstanceOf&lt;T: Dependency&gt;(dependencyType type: T.Type) -&gt; T? {</code>
<code>        let key = T.identifier</code>
<code>        let cachedInstance = cachedDependencies[key]</code>
<code>        if cachedInstance != nil {</code>
<code>            return cachedInstance as? T</code>
<code>        } else {</code>
<code>            let newInstance = factories[key]?()</code>
<code>            cachedDependencies[key] = newInstance</code>
<code>            return newInstance as? T</code>
<code>        }</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>In this dependency injection system, the app is able to register a <code>Dependency</code> by providing a closure that creates such dependency. When a feature states that this dependency is needed in order for it to work, the system creates an instance of it and stores it for future uses.</p>
 <p>However, <b>what happens when a feature doesn't need these dependencies anymore?</b> Because dictionary values are retained, the dependency instances will live <b>forever</b> in the app, even if the features that needed them are long gone.</p>
 <p>To solve this, you could create some complex system where features could warn the DependencyStore that they are going to close, or, you could create a <b>weak dictionary.</b> A weak dictionary works exactly like a normal one, with the difference being that it doesn't retain its values. If <code>cachedDependencies</code> was a weak dictionary, its values would automatically go out of scope if nobody else in the app was referencing them. This way, dependencies would correctly be created and disposed of as necessary by the app s lifecycle.</p>
 <h2>Creating a Weak Dictionary in Pure Swift</h2>
 <p>A way to solve this problem in pure Swift is to create some sort of wrapper class that has a weak reference inside, and stored our values there instead:</p>
 <pre>
<code>final class WeakRef {</code>
<code>    weak var value: AnyObject?</code>
<code>}</code>
<code></code>
<code>var cachedDependencies = [String: WeakRef]()</code>
<code></code>
<code>func getInstanceOf&lt;T: Dependency&gt;(dependencyType type: T.Type) -&gt; T? {</code>
<code>    let key = T.identifier</code>
<code>    let cachedInstance = cachedDependencies[key]?.value</code>
<code>    if cachedInstance != nil {</code>
<code>        print("Using old value!")</code>
<code>        return cachedInstance as? T</code>
<code>    } else {</code>
<code>        print("Using new value!")</code>
<code>        let newInstance = factories[key]?()</code>
<code>        let ref = WeakRef()</code>
<code>        ref.value = newInstance</code>
<code>        cachedDependencies[key] = ref</code>
<code>        return newInstance as? T</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>With some prints added to our function, we can confirm that it works by playing with pointers in a playground:</p>
 <pre>
<code>class MockDependency: Dependency {</code>
<code>    static let identifier: String = "mock"</code>
<code>}</code>
<code></code>
<code>let store = DependencyStore()</code>
<code></code>
<code>store.register(dependencyFactory: { MockDependency() })</code>
<code></code>
<code>var instance: MockDependency?</code>
<code></code>
<code>autoreleasepool {</code>
<code>    instance = store.getInstanceOf(dependencyType: MockDependency.self)</code>
<code>    // Using new value!</code>
<code>    _ = store.getInstanceOf(dependencyType: MockDependency.self)</code>
<code>    // Using old value!</code>
<code>    _ = store.getInstanceOf(dependencyType: MockDependency.self)</code>
<code>    // Using old value!</code>
<code>    instance = nil</code>
<code>}</code>
<code></code>
<code>instance = store.getInstanceOf(dependencyType: MockDependency.self)</code>
<code>// Using new value!</code>
<code>_ = store.getInstanceOf(dependencyType: MockDependency.self)</code>
<code>// Using old value!</code>
</pre>
 <p><i>(Note: An autoreleasepool block is used to force iOS to deallocate the instance after setting it to nil. <a href="https://swiftrocks.com/autoreleasepool-in-2019-swift">Check my article about autoreleasepool to learn more about it!</a>)</i></p>
 <p>While this works, it doesn't fully solve the problem. Although the instance of our dependencies will be correctly disposed of, our cache dictionary will still contain their <code>WeakRef</code> wrappers, which is an unnecessary memory overhead for us:</p>
 <pre>
<code>print(cachedDependencies)</code>
<code>// ["mock": WeakRef(value: nil)]</code>
</pre>
 <p>If we want to completely get rid of the dictionary entries, we must bring the big guns. Let's take a look at three classes that <code>Foundation</code> provides for this purpose.</p>
 <h2>NSMapTable</h2>
 <p>The <code>NSMapTable</code> class at first glance looks just like a plain <code>NSDictionary</code> / Swift <code>Dictionary&lt;&gt;</code>, but it supports a broader range of memory semantics.</p>
 <p><code>NSMapTable</code> is configured through its initializer, which allows you to pick different semantics for memory management and key equality. Here's how we can rewrite <code>DependencyStore</code> to use an <code>NSMapTable</code> that retains values weakly:</p>
 <pre>
<code>import Foundation</code>
<code></code>
<code>final class DependencyStore {</code>
<code></code>
<code>    var factories = [String: () -&gt; Dependency]()</code>
<code></code>
<code>    var cachedDependencies = NSMapTable&lt;NSString, AnyObject&gt;.init(</code>
<code>        keyOptions: .copyIn,</code>
<code>        valueOptions: .weakMemory</code>
<code>    )</code>
<code></code>
<code>    func register&lt;T: Dependency&gt;(dependencyFactory: @escaping () -&gt; T) {</code>
<code>        let key = T.identifier</code>
<code>        factories[key] = dependencyFactory</code>
<code>    }</code>
<code></code>
<code>    func getInstanceOf&lt;T: Dependency&gt;(dependencyType type: T.Type) -&gt; T? {</code>
<code>        let key = T.identifier</code>
<code>        let cachedInstance = cachedDependencies.object(forKey: key as NSString)</code>
<code>        if cachedInstance != nil {</code>
<code>            print("Using old value!")</code>
<code>            return cachedInstance as? T</code>
<code>        } else {</code>
<code>            print("Using new value!")</code>
<code>            let newInstance = factories[key]?()</code>
<code>            cachedDependencies.setObject(newInstance, forKey: key as NSString)</code>
<code>            return newInstance as? T</code>
<code>        }</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>If we try to run the previous example again we'll get the same output, but with the lovely difference that printing <code>NSMapTable</code> will reveal that the entire dictionary entry is gone when the dependencies are disposed!</p>
 <pre>
<code>print(cachedDependencies)</code>
<code>// NSMapTable {</code>
<code>// }</code>
</pre>
 <p>Here are some options supported by <code>NSMapTable</code>. Because the options argument is an <code>OptionSet</code>, you can use several of them at the same. <a href="https://swiftrocks.com/how-optionset-works-inside-the-swift-compiler">Here's my article about OptionSets if you're looking for more info on them!</a></p>
 <p> </p>
 <ul> 
  <li><b>.strongMemory</b> - Retains the data.</li> 
  <li><b>.weakMemory</b> - Do not retain the data.</li> 
  <li><b>.copyIn</b> - Create a copy of the data through <b>NSCopying</b>.</li> 
  <li><b>.objectPointerPersonality</b> - When used for keys, equality is determined based on pointer equality instead of <b>NSObject</b> hash equality.</li> 
 </ul>
 <p></p>
 <p>As an important disclaimer, note that <code>NSMapTable</code> is an Objective-C class. Besides only being able to use reference types with it, the equality of keys is not determined by the Swift <code>Hashable</code> protocol. If you do end up having to use these classes, I recommend using nothing but <code>NSStrings</code> as key types to prevent weird bugs.</p>
 <p>Additionally, you should be mindful when using this class with weak <b>keys</b>. Although the functionality is similar, weak keys are only removed when the map table is resized.</p>
 <h2>NSHashTable</h2>
 <p>For completion purposes, let's take a look at other <code>Foundation</code> classes that provide the same functionality. <code>NSHashTable</code> works exactly the same as an <code>NSMapTable</code>, but instead of providing additional memory options for dictionaries, it does so for a <code>Set</code>:</p>
 <pre>
<code>let stringRef = "AnUniqueString" as NSString</code>
<code></code>
<code>let weakSetOfStrings = NSHashTable&lt;NSString&gt;(options: .weakMemory)</code>
<code>weakSetOfStrings.add(stringRef)</code>
<code>weakSetOfStrings.contains(stringRef)</code>
</pre>
 <h2>NSPointerArray</h2>
 <p>Once again, <code>NSPointerArray</code> is very similar to <code>NSMapTable</code>, but with the difference being that it represents a plain array instead.</p>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>Unfortunately, unlike the other types, <code>NSPointerArray</code> doesn't support adding/retrieving objects directly. To use it, you must convert to and from raw pointer types.</p>
 <pre>
<code>let dependency = MockDependency()</code>
<code></code>
<code>let weakArray = NSPointerArray(options: .weakMemory)</code>
<code></code>
<code>let pointer = Unmanaged.passUnretained(dependency).toOpaque()</code>
<code>weakArray.addPointer(pointer)</code>
<code></code>
<code>let storedValue = Unmanaged&lt;MockDependency&gt;</code>
<code>                      .fromOpaque(weakArray.pointer(at: 0)!)</code>
<code>                      .takeUnretainedValue()</code>
</pre>
 <h2>Conclusion</h2>
 <p>Besides the obvious memory management differences between disposing of a value when it's not needed anymore versus keeping it alive forever, using weak collections when applicable can be very useful for performance reasons. As shown in the examples, while a bare Swift weak wrapper keeps existing when its value is gone, classes like <code>NSMapTable</code> clean their entries completely when values are disposed of. This reduced overhead can make a big difference in your app's lifecycle.</p>
</div>]]></description>
</item>
<item>
    <title>Understanding Swift's ObjectIdentifier</title>
    <link>https://swiftrocks.com/understanding-swifts-objectidentifier</link>
    <guid>https://swiftrocks.com/understanding-swifts-objectidentifier</guid>
    <pubDate>Tue, 31 Mar 2020 04:25:00 GMT-3</pubDate>
<description><![CDATA[
 
  
  <!--WRITEIT_POST_NAME=Understanding Swift's ObjectIdentifier--> 
  <!--WRITEIT_POST_HTML_NAME=understanding-swifts-objectidentifier--> 
  <!--WRITEIT_POST_SITEMAP_DATE_LAST_MOD=2020-04-12T14:00:00+02:00--> 
  <!--WRITEIT_POST_SITEMAP_DATE=2020-03-31T07:25:00+00:00--> 
  <!--Add here the additional properties that you want each page to possess.--> 
  <!--These properties can be used to change content in the template page or in the page itself as shown here.--> 
  <!--Properties must start with 'WRITEIT_POST'.--> 
  <!--Writeit provides and injects WRITEIT_POST_NAME and WRITEIT_POST_HTML_NAME by default.--> 
  <!--WRITEIT_POST_SHORT_DESCRIPTION=ObjectIdentifier is one of these obscure Swift types that you only see when looking at the answers for very specific problems in StackOverflow, and chances are that you have never really needed to use it. However, ObjectIdentifier plays an important part in Swift and is actually pretty useful as a solution to problems that involve metatypes. Let's take a look at why this type exists and what you can use it for.--> 
  <title>Understanding Swift's ObjectIdentifier</title>  
 

<div class="blog-post"> 
 <div class="post-title-index">  
  <h1>Understanding Swift's ObjectIdentifier</h1>
 </div> 
 <div class="post-info"> 
  <div class="category category-compiler">
   Compiler
  </div> 
  <div class="category category-swift">
   Swift
  </div> 
  <div class="post-info-text">
   Published on 31 Mar 2020 
  </div> 
 </div>  
 <p><code>ObjectIdentifier</code> is one of these obscure Swift types that you only see when looking at the answers for very specific problems in StackOverflow, and chances are that you have never really needed to use it. However, <code>ObjectIdentifier</code> plays an important part in Swift and is actually pretty useful as a solution to problems that involve metatypes. Let's take a look at why this type exists and what you can use it for.</p>
 <h2>Where you might have seen it</h2>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>If you're like me, your first contact with <code>ObjectIdentifier</code> might have involved trying to use metatypes as the key for a dictionary:</p>
 <pre>
<code>let routes = [Route.Type: String]</code>
<code>// Error: Route.Type does not conform to Hashable</code>
</pre>
 <p>Metatypes cannot be used as the key to dictionaries because metatypes do not conform <code>Hashable</code>, but you can't make them conform because you also <b>can't</b> extend metatypes! If you search for problems like this on StackOverflow, <code>ObjectIdentifier</code> will be revealed as one of the solutions.</p>
 <h2>What's ObjectIdentifier?</h2>
 <p><code>ObjectIdentifier</code> is a class defined in the Swift Standard Library that is able to provide an <b>unique identifier to reference types and metatypes.</b> This distinction is important -- value types like structs and enums cannot have unique identifiers because they do no have the concept of "identity" inside the language as we'll understand better shortly.</p>
 <p>Its usage is very simple: By initializing <code>ObjectIdentifier</code> with an <code>AnyObject</code> instance (any <code>class</code> instance) or a metatype, you'll have access to an object that represents an unique identifier to that reference.</p>
 <pre>
<code>class Foo: Equatable {</code>
<code>    let val: Int</code>
<code>    static func == (lhs: Foo, rhs: Foo) -&gt; Bool { lhs.val == rhs.val }</code>
<code>    init(_ val: Int) { self.val = val }</code>
<code>}</code>
<code></code>
<code>let fooA = Foo(1)</code>
<code></code>
<code>let identifierA = ObjectIdentifier(fooA)</code>
</pre>
 <p><code>ObjectIdentifier</code> has no public properties or methods, but it conforms to both <code>Equatable</code> and <code>Hashable</code>, which allows you to pinpoint and separate different instances of the same object. Here's an example: Can you guess the results of the following equality operations?</p>
 <pre>
<code>let fooA = Foo(1)</code>
<code>let fooB = Foo(1)</code>
<code></code>
<code>fooA == fooB // ?</code>
<code>ObjectIdentifier(fooA) == ObjectIdentifier(fooB) // ?</code>
</pre>
 <p>If you guessed <code>true</code> and <code>false</code>, you are correct. <code>fooA</code> is equal to <code>fooB</code> because they have the same value, but their <code>ObjectIdentifier</code> counterparts are <b>not</b> equal because they are <b>not</b> the same instance -- they are different representations of <code>Foo</code>. What about this one?</p>
 <pre>
<code>let fooC = fooA</code>
<code>ObjectIdentifier(fooA) == ObjectIdentifier(fooC) // ?</code>
</pre>
 <p>On the other hand, the previous comparison is <code>true</code> because <code>fooA</code> and <code>fooC</code> are representations of the same instance. This is why <code>ObjectIdentifier</code> only works for reference types and metatypes -- although it is possible to create references of value types if you try hard enough (for example, with <code>inout</code>), they do not have this specific assignment behavior.</p>
 <p>You might have noticed that the behavior of <code>ObjectIdentifier</code> is similar to the pointer equality operator <code>===</code> -- you might be interested to know that <code>===</code> is just a wrapper for <code>ObjectIdentifier</code> equality:</p>
 <pre>
<code>public func === (lhs: AnyObject?, rhs: AnyObject?) -&gt; Bool {</code>
<code>  switch (lhs, rhs) {</code>
<code>  case let (l?, r?):</code>
<code>    return ObjectIdentifier(l) == ObjectIdentifier(r)</code>
<code>  case (nil, nil):</code>
<code>    return true</code>
<code>  default:</code>
<code>    return false</code>
<code>  }</code>
<code>}</code>
</pre>
 <p>As mentioned before but not shown, you can also use <code>ObjectIdentifier</code> with metatypes to give them <code>Hashable</code> and <code>Equatable</code> capabilities. This is because metatypes are treated as single global instances of an object's type, and thus hold that concept of "identity".</p>
 <pre>
<code>let dict = [ObjectIdentifier: String]()</code>
<code>let metaObject = ObjectIdentifier(MyViewController.self)</code>
<code>dict[metaObject] = "SwiftRocks!"</code>
</pre>
 <h2>How ObjectIdentifier works internally</h2>
 <p>Internally, <code>ObjectIdentifier</code> is just a wrapper for an object's memory address.</p>
 <pre>
<code>public struct ObjectIdentifier {</code>
<code></code>
<code>  internal let _value: Builtin.RawPointer</code>
<code></code>
<code>  public init(_ x: AnyObject) {</code>
<code>    self._value = Builtin.bridgeToRawPointer(x)</code>
<code>  }</code>
<code></code>
<code>  public init(_ x: Any.Type) {</code>
<code>    self._value = unsafeBitCast(x, to: Builtin.RawPointer.self)</code>
<code>  }</code>
<code>}</code>
</pre>
 <p>Because the memory address is in its core a mere number, we can use it to give <code>ObjectIdentifier</code> <code>Equatable</code> and <code>Hashable</code> capabilities by simply comparing this number. Clever, isn't it?</p>
 <pre>
<code>extension ObjectIdentifier: Equatable {</code>
<code>  public static func == (x: ObjectIdentifier, y: ObjectIdentifier) -&gt; Bool {</code>
<code>    return Bool(Builtin.cmp_eq_RawPointer(x._value, y._value))</code>
<code>  }</code>
<code>}</code>
<code></code>
<code>extension ObjectIdentifier: Hashable {</code>
<code>  public func hash(into hasher: inout Hasher) {</code>
<code>    hasher.combine(Int(Builtin.ptrtoint_Word(_value)))</code>
<code>  }</code>
<code>}</code>
</pre>
 <p><code>ObjectIdentifier</code> is used internally in the compiler whenever identifying specific instances is needed, but one interesting use is that <code>ObjectIdentifier</code> is the default "identification method" for reference types in the <code>Identifiable</code> protocol:</p>
 <pre>
<code>public protocol Identifiable {</code>
<code>  associatedtype ID: Hashable</code>
<code>  var id: ID { get }</code>
<code>}</code>
<code></code>
<code>extension Identifiable where Self: AnyObject {</code>
<code>  public var id: ObjectIdentifier {</code>
<code>    return ObjectIdentifier(self)</code>
<code>  }</code>
<code>}</code>
</pre>
 <h2>Example: Using ObjectIdentifier to increase performance</h2>
 <p><code>ObjectIdentifier</code> can be used a way to bypass the limitation of metatypes in order to give them <code>Hashable</code> capabilities. If you're working on something that behaves like a plugin architecture, you'll find that being able to create <code>Sets</code> and <code>Dictionaries</code> based on metatypes is useful.</p>
 <p>Here's an example from one of my first apps. In <b>Rapiddo</b>, features were completely modularized. They were developed as <b>mini programs</b> that were registered into the main app and exposed some capabilities. One of these capabilities was called <b>Widget</b>, which represented views that could be displayed in the app's home's feed.</p>
 <pre>
<code>final class MainMiniProgram: MiniProgram {</code>
<code></code>
<code>    override class var supportedWidgets: [WidgetView.Type] {</code>
<code>        return [</code>
<code>            CircleCarrouselWidgetView.self,</code>
<code>            NewsFeedWidgetView.self,</code>
<code>            OngoingOrdersWidgetView.self,</code>
<code>            SimpleMessageWidgetView.self</code>
<code>        ]</code>
<code>    }</code>
<code></code>
<code>    ...</code>
<code></code>
</pre>
 <p>Sometimes the main app wanted to know if a mini program supported a specific type of widget. Because <code>supportedWidgets</code> is an array, the solution was to iterate all of the widgets:</p>
 <pre>
<code>func miniProgram&lt;T: Widget&gt;(framework: RapiddoCore.MiniProgram.Type, supportsWidget widgetMetaType: T.Type) -&gt; Bool {</code>
<code>    return framework.supportedWidgets.first { $0 == widgetMetaType }</code>
<code>}</code>
</pre>
 <p>Unfortunately, since it was possible for some mini programs to contain hundreds of widgets, this method was a big performance problem. The best solution is for <code>supportedWidgets</code> to be a <code>Set</code> to allow us to answer this question in constant time, but we can't have a <code>Set</code> of metatypes because they are not <code>Hashable</code>.</p>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>The solution? We can extend <code>MiniProgram</code> to pre-process our widget array into <code>Set&lt;ObjectIdentifier&gt;</code> and search from there.</p>
 <pre>
<code>extension MiniProgram {</code>
<code>    private static let _widgetSet: Set&lt;ObjectIdentifier&gt; = Set(supportedWidgets.map(ObjectIdentifier.init))</code>
<code></code>
<code>    static func supports
   <t: widget>
    (widgetType: T.Type) -&gt; Bool {
   </t:></code>
<code>        return _widgetSet.contains(ObjectIdentifier(widgetType))</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>With this code, the array of widgets will only be iterated the first time that <code>_widgetSet</code> is accessed. On subsequent calls, the set will be provided instantly due to the <code>lazy</code> behavior or static properties.</p>
 <h2>References and Good Reads</h2>
 <a href="https://github.com/apple/swift/blob/master/stdlib/public/core/ObjectIdentifier.swift">ObjectIdentifier.swift</a>
 <br>
</div>]]></description>
</item>
<item>
    <title>Useful Global Swift Functions</title>
    <link>https://swiftrocks.com/useful-global-swift-functions</link>
    <guid>https://swiftrocks.com/useful-global-swift-functions</guid>
    <pubDate>Tue, 24 Mar 2020 04:25:00 GMT-3</pubDate>
<description><![CDATA[
 
  
  <!--WRITEIT_POST_NAME=Useful Global Swift Functions--> 
  <!--WRITEIT_POST_HTML_NAME=useful-global-swift-functions--> 
  <!--WRITEIT_POST_SITEMAP_DATE_LAST_MOD=2020-04-12T14:00:00+02:00--> 
  <!--WRITEIT_POST_SITEMAP_DATE=2020-03-24T07:25:00+00:00--> 
  <!--Add here the additional properties that you want each page to possess.--> 
  <!--These properties can be used to change content in the template page or in the page itself as shown here.--> 
  <!--Properties must start with 'WRITEIT_POST'.--> 
  <!--Writeit provides and injects WRITEIT_POST_NAME and WRITEIT_POST_HTML_NAME by default.--> 
  <!--WRITEIT_POST_SHORT_DESCRIPTION=Global functions, or functions that can be accessed from anywhere without the scope of a specific type is an old concept that was popular in languages like C and Objective-C, but unrecommended in Swift as we would rather have things that are nicely typed and scoped ("swifty"). For historical reasons, the Swift Standard Library still has quite a few public global functions, and some of them are still useful to this day. Let's take a look at functions like zip() and dump().--> 
  <title>Useful Global Swift Functions</title>  
 

<div class="blog-post"> 
 <div class="post-title-index">  
  <h1>Useful Global Swift Functions</h1>
 </div> 
 <div class="post-info"> 
  <div class="category category-swift">
   Swift
  </div> 
  <div class="post-info-text">
   Published on 24 Mar 2020 
  </div> 
 </div>   
 <p><b>Global functions</b>, or functions that can be accessed from anywhere without the scope of a specific type is an old concept that was popular in languages like C and Objective-C, but unrecommended in Swift as we would rather have things that are nicely typed and scoped ("swifty").</p>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>For historical reasons, the Swift Standard Library still has quite a few public global functions, and some of them are still useful to this day. Let's take a look at functions like <code>zip()</code> and <code>dump()</code>.</p>
 <h2>zip()</h2>
 <p>Perhaps the most known global function, the <code>zip</code> function allows you to take two or more arrays and merge them into a single <code>Sequence</code> of a tuple. This is extremely useful if you need to iterate two things at the same time, as without <code>zip</code> you would have to manually build a <b>for</b> loop and access each index from each array individually. Using <code>zip</code> allows you access elements from all arrays in the more useful <b>for-in</b> fashion.</p>
 <p>For example, if we had a user registration form screen and we would like to update our textFields to render a list of validation results fetched from the backend, we could do something like this:</p>
 <pre>
<code>func present(validationResults: [FieldValidationResult],</code>
<code>             inTextFields textFields: [MyTextField]) {</code>
<code>    for i in 0..&lt;textFields.count {</code>
<code>        let field = textFields[i]</code>
<code>        let result = validationResults[i]</code>
<code>        field.render(validationResult: result)</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>With <code>zip</code>, we can remove all the manual indexing.</p>
 <pre>
<code>func present(validationResults: [FieldValidationResult],</code>
<code>             inTextFields textFields: [MyTextField]) {</code>
<code>    for (field, result) in zip(textFields, validationResults) {</code>
<code>        field.render(validationResult: result)</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>The return type of <code>zip</code> is a <code>Zip2Sequence</code> object that conforms to <code>Sequence</code>, and so all other sequence-related methods are applicable to it, including transforming it to a real array.</p>
 <h2>dump()</h2>
 <p>The <code>dump</code> function is a neat alternative to printing objects. While printing objects is just a syntax sugar for a type's <code>description</code> or <code>debugDescription</code> property, <code>dump</code> is a supercharged version of <code>Mirror(reflecting:)</code> that prints the contents of an object using reflection, which will usually result in considerably more info, including the hierarchy of the object.</p>
 <pre>
<code>class Foo: NSObject {</code>
<code>    let bar: String = "bar"</code>
<code>}</code>
<code></code>
<code>let foo = Foo()</code>
<code>print(foo)</code>
<code>// &lt;SwiftRocks.Foo: 0x1030b9250&gt;</code>
<code></code>
<code>dump(foo)</code>
<code>// ‚ñø &lt;SwiftRocks.Foo: 0x1030b9250&gt; #0</code>
<code>//     - super: NSObject</code>
<code>//    - bar: "bar"</code>
</pre>
 <h2>sequence()</h2>
 <p>The global <code>sequence()</code> function is a bit obscure, but it's a very cool function that lets you write recursive functions in a nicer syntax.</p>
 <p>Let's pretend that we're changing the background color of a subview and all of its parents. Perhaps you would build a <code>while</code> loop like this:</p>
 <pre>
<code>var currentView: UIView? = self</code>
<code>while currentView != nil {</code>
<code>    currentView?.backgroundColor = .green</code>
<code>    currentView = currentView?.superview</code>
<code>}</code>
</pre>
 <p>This is the best use case for <code>sequence()</code>, as the purpose of this function is to give you a <code>Sequence</code> that applies a specific closure over and over. As the recursive aspect of this method (<code>currentView = currentView?.superview</code>) is always the same, we can use <code>sequence()</code> to turn it into a simple <code>for</code> loop:</p>
 <pre>
<code>for view in sequence(first: self, next: { $0.superview } ) {</code>
<code>    view.backgroundColor = .green</code>
<code>}</code>
</pre>
 <p>The way this works is that <code>sequence()</code> returns a custom <code>UnfoldFirstSequence</code> type, a simple wrapper for a <code>Sequence</code> that keeps applying the closure over and over in its <code>next()</code> function.</p>
 <h2>isKnownUniquelyReferenced()</h2>
 <p>The <code>isKnownUniquelyReferenced</code> function receives a <code>class</code> object and returns a boolean that indicates if the object is being reference only one time, with the purpose of enabling you to implement <b>value semantics</b> to <b>reference types</b>. Although structs are value types themselves, the contents inside of it might not be. You might know that putting a class inside a struct doesn't mean it will be copied on assignment:</p>
 <pre>
<code>class Foo: NSObject {</code>
<code>    var bar: String = "bar"</code>
<code>}</code>
<code></code>
<code>struct FooHolder {</code>
<code>    let foo: Foo = Foo()</code>
<code>    var intValue: Int = 1</code>
<code>}</code>
<code></code>
<code>var fooHolder = FooHolder()</code>
<code>var fooHolder2 = fooHolder</code>
<code></code>
<code>fooHolder2.foo.bar = "bar2"</code>
<code>fooHolder2.intValue = 2</code>
<code></code>
<code>print(fooHolder.intValue)</code>
<code>// 1</code>
<code>print(fooHolder2.intValue)</code>
<code>// 2</code>
<code></code>
<code>print(fooHolder.foo.bar)</code>
<code>// bar2</code>
<code>print(fooHolder2.foo.bar)</code>
<code>// bar2</code>
</pre>
 <p>In this example, although <code>fooHolder2</code> and its underlying number are separate entities from the original holder, the underlying class is still shared between them. To fix this, we can use <code>isKnownUniquelyReferenced</code> to detect when this property is being accessed and create a new instance of the class if necessary:</p>
 <pre>
<code>struct FooHolder {</code>
<code>    private var _foo: Foo = Foo()</code>
<code></code>
<code>    var foo: Foo {</code>
<code>        mutating get {</code>
<code>            if isKnownUniquelyReferenced(&amp;_foo) {</code>
<code>                return _foo</code>
<code>            } else {</code>
<code>                let newFoo = Foo()</code>
<code>                newFoo.bar = _foo.bar</code>
<code>                _foo = newFoo</code>
<code>                return _foo</code>
<code>            }</code>
<code>        } set {</code>
<code>            _foo = newValue</code>
<code>        }</code>
<code>    }</code>
<code></code>
<code>    var intValue: Int = 1</code>
<code>}</code>
</pre>
 <p>You might be interested to know that this is exactly how the Swift Standard Library enables <b>copy-on-write</b> semantics to Arrays and Strings -- <a href="https://swiftrocks.com/memory-management-and-performance-of-value-types">something that I've mentioned in my article about the memory management of value types.</a></p>
 <h2>repeatElement()</h2>
 <p>The <code>repeatElement()</code> does exactly what it says. Given an object and a number, the result is a <code>Sequence</code> that can be iterated to give you that object that specific amount of times.</p>
 <pre>
<code>let repeated: Repeated&lt;String&gt; = repeatElement("SwiftRocks", count: 3)</code>
<code>for value in repeated {</code>
<code>    print(value)</code>
<code>}</code>
<code>//SwiftRocks</code>
<code>//SwiftRocks</code>
<code>//SwiftRocks</code>
</pre>
 <p>Repeating elements is a common operation in Swift, especially to fill in gaps in <code>Strings</code> and <code>Arrays</code>. in fact, most of these types even have a specific initializer for this:</p>
 <pre>
<code>let array = [Int](repeating: 0, count: 10)</code>
</pre>
 <p><b>So why would you use repeatElement?</b> The reason is performance. The return type of <code>repeatElement()</code> is a <code>Repeated&lt;T&gt;</code> <code>Sequence</code> type, similar to <code>Zip2Sequence</code> in terms that it does nothing besides provide this "repeating" functionality. Let's say you would like to replace a specific section of the array of numbers with another number; one way to achieve this would be to use <code>replaceSubrange</code> with another array:</p>
 <pre>
<code>array.replaceSubrange(2...7, with: [Int](repeating: 1, count: 6))</code>
<code>print(array)</code>
<code>// [0, 0, 1, 1, 1, 1, 1, 1, 0, 0]</code>
</pre>
 <p>While this works, the usage of <code>[Int](repeating:)</code> comes with all the overhead of having to initialize array buffers that will serve no purpose here. If you <b>only</b> need the repeating functionality, then using <code>repeatElement</code> will perform much better.</p>
 <pre>
<code>array.replaceSubrange(2...7, with: repeatElement(1, count: 6))</code>
</pre>
 <h2>stride()</h2>
 <p>Also fairly popular, the <code>stride()</code> function was added to Swift as a way to create for loops that could skip certain elements, as the equivalent C-style way to do so was removed from the language:</p>
 <pre>
<code>for (int i = 0; i &lt; 10; i += 2) { ... }</code>
</pre>
 <p>Now, you can use <code>stride()</code> to achieve the same behavior:</p>
 <pre>
<code>for i in stride(from: 0, to: 10, by: 2) {</code>
<code>    // from 0 to 9, skipping odd numbers.</code>
<code>}</code>
</pre>
 <p>The arguments for <code>stride()</code> are arguments that conform to the <code>Strideable</code> protocol, which represents objects that can represent the concept of distances. For example, here's how we could add the concept of "day difference" in <code>Date</code> objects to that they can be used in <code>stride()</code>:</p>
 <pre>
<code>extension Date: Strideable {</code>
<code>    func advanced(by n: Int) -&gt; Date {</code>
<code>        return Calendar.current.date(byAdding: .day,</code>
<code>                                     value: n,</code>
<code>                                     to: self)!</code>
<code>    }</code>
<code></code>
<code>    func distance(to other: Date) -&gt; Int {</code>
<code>        return Calendar.current.dateComponents([.day],</code>
<code>                                               from: other,</code>
<code>                                               to: self).day!</code>
<code>    }</code>
<code>}</code>
<code></code>
<code>let startDate = Date()</code>
<code>let finalDate = startDate.advanced(by: 5)</code>
<code></code>
<code>for date in stride(from: startDate, to: finalDate, by: 1) {</code>
<code>    print(date)</code>
<code>}</code>
<code>// March 24th</code>
<code>// March 25th</code>
<code>// March 26th</code>
<code>// March 27th</code>
<code>// March 28th</code>
</pre>
 <p><i>(Note that Date already has an implementation of Strideable methods that strides in seconds, so copying this to a project won't work.)</i></p>
 <h2>Other Useful Functions</h2>
 <h3>Math</h3>
 <p><code>max()</code> - Returns the maximum value of the arguments</p>
 <p><code>min()</code> - Returns the minimum value of the arguments</p>
 <p><code>abs()</code> - Returns the absolute value of the argument (useful in competitive programming questions)</p>
 <h3>Values</h3>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p><code>swap()</code> - Swaps the value of two objects. This is not mentioned in its own section in this article because if you need to swap array elements the correct method to use is <code>Array.swapAt()</code>. However, you can still use <code>swap()</code> in other situations where you would need to create a fake "aux" property to hold a value.</p>
 <h2>Conclusion</h2>
 <p>As we can see, although none of these methods are necessary to make things happen, using them allows you write code that is easier to maintain and some times even more performant than old school solutions.</p>
</div>]]></description>
</item>
<item>
    <title>How Collection Diffing works in Swift</title>
    <link>https://swiftrocks.com/how-collection-diffing-works-internally-in-swift</link>
    <guid>https://swiftrocks.com/how-collection-diffing-works-internally-in-swift</guid>
    <pubDate>Wed, 18 Mar 2020 04:25:00 GMT-3</pubDate>
<description><![CDATA[
 
  
  <!--WRITEIT_POST_NAME=How Collection Diffing works in Swift--> 
  <!--WRITEIT_POST_HTML_NAME=how-collection-diffing-works-internally-in-swift--> 
  <!--WRITEIT_POST_SITEMAP_DATE_LAST_MOD=2020-04-12T14:00:00+02:00--> 
  <!--WRITEIT_POST_SITEMAP_DATE=2020-03-18T07:25:00+00:00--> 
  <!--Add here the additional properties that you want each page to possess.--> 
  <!--These properties can be used to change content in the template page or in the page itself as shown here.--> 
  <!--Properties must start with 'WRITEIT_POST'.--> 
  <!--Writeit provides and injects WRITEIT_POST_NAME and WRITEIT_POST_HTML_NAME by default.--> 
  <!--WRITEIT_POST_SHORT_DESCRIPTION=Ordered Collection Diffing is a feature added in Swift 5.1 that allows you to calculate and apply the difference between two collections. Using diffing libraries is common in iOS for a few reasons, the most popular one being to handle the addition and removal of elements in UITableViews. With the addition of this feature, developers can now diff Collections without having to bother with external libraries. Have you wondered what efficiently diffing something looks like? In this article, we'll see and analyze the diffing APIs as well as the diffing algorithm used by the Swift Standard Library.--> 
  <title>How Collection Diffing works in Swift</title>  
 

<div class="blog-post"> 
 <div class="post-title-index">  
  <h1>How Collection Diffing works in Swift</h1>
 </div> 
 <div class="post-info"> 
  <div class="category category-compiler">
   Compiler
  </div> 
  <div class="category category-swift">
   Swift
  </div> 
  <div class="post-info-text">
   Published on 18 Mar 2020 
  </div> 
 </div>   
 <p><b>Ordered Collection Diffing</b> is a feature added in Swift 5.1 that allows you to calculate and apply the difference between two collections. Using diffing libraries is common in iOS for a few reasons, the most popular one being to handle the addition and removal of elements in <code>UITableViews</code>. With the addition of this feature, developers can now diff <code>Collections</code> without having to bother with external libraries.</p>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>Have you wondered what efficiently diffing something looks like? In this article, we'll see and analyze the diffing APIs as well as the <b>Myers's Diffing Algorithm</b> used by the Swift Standard Library -- the same used in <b>git</b>.</p>
 <h2>Collection Diffing APIs</h2>
 <p>The diffing APIs are available as an extension for any <code>BidirectionalCollection</code>, with an abstracted helper type for ones whose's elements are <code>Equatable</code>:</p>
 <pre>
<code>extension BidirectionalCollection {</code>
<code>  public func difference&lt;C: BidirectionalCollection&gt;(</code>
<code>    from other: C,</code>
<code>    by areEquivalent: (C.Element, Element) -&gt; Bool</code>
<code>  ) -&gt; CollectionDifference&lt;Element&gt;</code>
<code>  where C.Element == Self.Element {</code>
<code>    return ... // Article spoilers removed!</code>
<code>  }</code>
<code>}</code>
</pre>
 <pre>
<code>extension BidirectionalCollection where Element: Equatable {</code>
<code>  public func difference&lt;C: BidirectionalCollection&gt;(</code>
<code>    from other: C</code>
<code>  ) -&gt; CollectionDifference&lt;Element&gt; where C.Element == Self.Element {</code>
<code>    return difference(from: other, by: ==)</code>
<code>  }</code>
<code>}</code>
</pre>
 <p>The return type for diffing operations is an <code>CollectionDifference</code> object -- basically an array of "moves" necessary to turn the first collection into the second one. The "moves" are represented as an enum of additions and removals, and the <code>CollectionDifference</code> object holds all of them.</p>
 <pre>
<code>public struct CollectionDifference&lt;ChangeElement&gt; {</code>
<code>  /// A single change to a collection.</code>
<code>  @frozen</code>
<code>  public enum Change {</code>
<code>    case insert(offset: Int, element: ChangeElement, associatedWith: Int?)</code>
<code>    case remove(offset: Int, element: ChangeElement, associatedWith: Int?)</code>
<code>  }</code>
<code></code>
<code>  public let insertions: [Change]</code>
<code>  public let removals: [Change]</code>
<code>}</code>
</pre>
 <p><code>CollectionDifference</code> is a <code>Collection</code> itself, which means that it can be iterated. <b>An important aspect of this is that the iteration will happen in a specific order: First, all the removals from highest to lowest offset, followed by insertions from lowest to highest.</b> This is both for performance reasons (removing elements from the end of an array is faster from the beginning, and adding elements to the front when there are fewer elements is faster than when there's a lot), and for visual reasons as we'll see when the underlying algorithm is inspected.</p>
 <p>We can see this behavior with a real example. Let's calculate the difference between these two strings:</p>
 <pre>
<code>let a = "ABCABBA"</code>
<code>let b = "CBABAC"</code>
</pre>
 <p>There are tons of ways of transforming <code>a</code> into <code>b</code>, but our interest is doing so in the least amount of steps. When calling <code>difference(_:)</code> and iterating the result, we'll see one of these solutions:</p>
 <pre>
<code>let diff = b.difference(from: a)</code>
<code>diff.forEach { print($0) }</code>
<code>// remove(offset: 5, element: "B", associatedWith: nil)</code>
<code>// remove(offset: 1, element: "B", associatedWith: nil)</code>
<code>// remove(offset: 0, element: "A", associatedWith: nil)</code>
<code>// insert(offset: 1, element: "B", associatedWith: nil)</code>
<code>// insert(offset: 5, element: "C", associatedWith: nil)</code>
</pre>
 <p>(We'll leave the explanation of the algorithm itself for the last section because it's a bit complicated.)</p>
 <p>From here, you can use the resulting <code>CollectionDifference</code> object as you see fit, like animating the addition and removal of rows from an <code>UITableView</code>. The neat thing is that Swift provides an <code>applying(_:)</code> method that allows you to directly apply a <code>CollectionDifference</code> object into a <code>Collection</code>:</p>
 <pre>
<code>let newB = a.applying(diff)</code>
<code>//CBABAC</code>
</pre>
 <p>This particular example looks useless, so here's something where applying diffs is useful: The same three-way merge process that <b>git</b> uses as a strategy to merge commits!</p>
 <pre>
<code>// Split the contents of the sources into lines</code>
<code>let baseLines = base.components(separatedBy: "\n")</code>
<code>let theirLines = theirs.components(separatedBy: "\n")</code>
<code>let myLines = mine.components(separatedBy: "\n")</code>
<code></code>
<code>// Create a difference from base to theirs</code>
<code>let diff = theirLines.difference(from:baseLines)</code>
<code></code>
<code>// Apply it to mine, if possible</code>
<code>guard let patchedLines = myLines.applying(diff) else {</code>
<code>    print("Merge conflict applying patch, manual merge required")</code>
<code>    return</code>
<code>}</code>
<code></code>
<code>// Reassemble the result</code>
<code>let patched = patchedLines.joined(separator: "\n")</code>
<code>print(patched)</code>
</pre>
 <h2>How applying() works</h2>
 <p>The <code>applying(_:)</code> method works by creating a new, empty <code>Collection</code> instance that gets filled as the changes are iterated. Because the changes are iterated in the specific high removals -&gt; low removals -&gt; low insertions -&gt; high insertions, the algorithm is able to build the final result through ranges instead of individual elements. For example, if you have a 10 character string and the first step is to remove the 5th character, we know right off the bat that the final result will contain the range <code>5...9</code> in that same order, so "removing the 5th character" is equivalent to adding everything that comes after it. The same logic is applied until all the changes are processed. Because of the interaction with ranges, <code>applying(_:)</code> is only available to <code>RangeReplaceableCollections</code>.</p>
 <p>It is possible for this process to fail, for example, when the desired element to be removed doesn't exist, which is possible in cases like the <b>git</b> example due to conflicting information in the data. In these cases, <code>applying(_:)</code> returns <code>nil</code>.</p>
 <p>The actual method is a bit long and hard to read, <a href="https://github.com/apple/swift/blob/master/stdlib/public/core/Diffing.swift#L71">so I'll leave the link to it</a> instead of showing it here.</p>
 <h2>The complex part: How difference() works</h2>
 <p>Now that we've seen how the APIs work, we're ready to take a look at what Swift does to generate the final <code>CollectionDifference</code> object.</p>
 <p>As stated before, there are many ways to transform a <code>Collection</code> into another one. For example, to transform <code>a: ABCABBA</code> to <code>b: CBABAC</code>, we could simply remove every single element from <code>a</code> and append the ones from <code>b</code>. Easy peasy!</p>
 <p>However, at a best case of <code>a.count + b.count</code> "moves", that would be very inefficient. One way to find the best way possible to do this change is to transform this into a <b>graph problem</b>. Imagine that we have a <b>matrix</b> where the columns are characters from <code>a</code> and rows are characters from <code>b</code>:</p>
 <pre>
<code>  -  A  B  C  A  B  B  A</code>
<code></code>
<code>-</code>
<code></code>
<code>C</code>
<code></code>
<code>B</code>
<code></code>
<code>A</code>
<code></code>
<code>B</code>
<code></code>
<code>A</code>
<code></code>
<code>C</code>
<code></code>
</pre>
 <p>In this matrix, the top-left position 0,0 represents the original <code>ABCABBA</code> string, while the bottom-right position represents the final <code>CBABAC</code> string. Moving <b>right</b> in this matrix represents <b>removing</b> an element from the original string, while moving <b>down</b> represents <b>adding</b> an element from the new one. Each of these movements counts as a step, but if the elements from both strings at a specific position <b>match</b> (like the position 1,3 - two Cs), you can <b>diagonally move down and to the right</b> for "free", as no changes are necessary for that position.</p>
 <p>Given this description, we can transform this problem into another one: <b>How can we reach the bottom right of the matrix in the least amount of steps (a.k.a maximizing the number of diagonal moves)?</b></p>
 <p>If you ever studied graphs you might remember that finding the shortest path between two nodes in an unweighted graph is a classical computer science problem! This problem is solved by the popular graph search algorithm <a href="https://www.geeksforgeeks.org/breadth-first-search-or-bfs-for-a-graph/">Breadth-First Search</a> -- because the graph is unweighted, taking turns on checking the neighbors of each node is guaranteed to discover the shortest path between a source node to a target one. Applying the algorithm in the previous example will show us a path that transforms our string in <b>5</b> moves (remember that diagonal moves do not count as moves):</p>
 <pre>
<code>  -  A  B  C  A  B  B  A</code>
<code></code>
<code>- 0  1  2</code>
<code></code>
<code>C          2  3</code>    
<code></code>         
<code>B                3</code>
<code></code>     
<code>A                4</code>
<code></code>
<code>B                   4</code>
<code></code>
<code>A                      4</code>
<code></code>
<code>C                      5</code>
<code></code>                     
</pre>
 <p>The implementation behind the true diffing algorithms is very similar to this, but with a few (unfortunately, relatively complicated) important twists. Although we're looking for the shortest edit path between two <code>Collections</code>, we're not exactly looking for <b>any</b> short path. Especially for visual applications like <b>git</b>, the overall order of how deletions and insertions are present is important. When you're looking at the merge diff in git, you would expect the diff to be somewhat "intelligent" in terms of knowing what was really added and deleted by your changes instead of randomly saying that things were "added" and "deleted" because it fulfills the shortest path condition.</p>
 <pre>
<code>Good:   class Foo {                  Bad:    class Foo {</code>
<code>          init(bar: String) {                  init(bar: String) {</code>
<code>            self.bar = bar                       self.bar = bar</code>
<code>          }                                +   }</code>
<code>      +                                    +</code>
<code>      +   func inspect() {                 +   func inspect() {</code>
<code>      +     print(bar)                     +     print(bar)</code>
<code>      +   }                                    }</code>
<code>        }                                    }</code>
</pre>
 <p>Diffing algorithms carefully choose the paths that Breadth-First Search is going to traverse in order to provide a meaningful diff.</p>
 <h2>Swift's Diffing Algorithm: Myers's Diffing Algorithm</h2>
 <p>Swift uses Myers's Diffing Algorithm <a href="http://www.xmailserver.org/diff2.pdf">(paper here)</a> as part of the diffing APIs. Given two collections, the result is the <b>Shortest Edit Script</b> that transforms A into B. Much like the abstracted <code>CollectionDifference</code> type, the Shortest Edit Script is a list of additions and removals. In order to provide a good diff, Myers's prefers deleting over inserting, and it differs from Breadth-First Search by prioritizing what seems to be "good" paths instead of blindly switching nodes like the original algorithm.</p>
 <p>This is done by adding two additional components to the matrix: How <b>deep</b> we are into the graph (number of moves, in the X-axis), and the <b>ratio</b> of additions versus deletions, which is a value <b>k</b> that increases by one every time we remove a value (moving right), and decreases by one every time we add a value (moving down), in the Y-axis. This is better seen if we shift a graph by 45 degrees (note that this graph doesn't contain the diagonal connections that make the paths shorter):</p>
 <pre>
<code>    |     0     1     2     3     4     5</code>
<code>    +--------------------------------------</code>
<code> 5  |                                   5,0</code>
<code>    |                                 /</code>
<code> 4  |                             4,0 </code>
<code>    |                           /     \</code>
<code> 3  |                       3,0         4,1</code>
<code>    |                     /     \     /</code>
<code> 2  |                 2,0         3,1</code>
<code>    |               /     \     /     \</code>
<code> 1  |           1,0         2,1         3,2</code>
<code>    |         /     \     /     \     /      ...</code>
<code> 0  |     0,0         1,1         2,2</code>
<code>    |         \     /     \     /     \</code>
<code>-1  |           0,1         1,2         2,3</code>
<code>    |               \     /     \     /</code>
<code>-2  |                 0,2         1,3</code>
<code>    |                     \     /     \</code>
<code>-3  |                       0,3   ...  1,4</code>
</pre>
 <p>To find the perfect path, the algorithm iterates the possible <b>depth</b> values. For each <b>depth</b>, it iterates the possible <b>k values</b> at that depth (<code>-d...d</code>) and determines the best move it can make at that point for that <b>k value</b>.</p>
 <p>The best move is determined based on a few rules we'll see soon, but the important part here is that this is done based on the decisions made on the previous depth iteration. To make the current iteration not mess with the previous moves, the <b>k values</b> are iterated in steps of 2.</p>
 <pre>
<code>var result = [KValues]()</code>
<code>var currentKValues = KValues()</code>
<code>currentKValues[1] = 0 // Ignore this for now, explained later!</code>
<code></code>
<code>outer: for d in 0...(a.count + b.count) {</code>
<code></code>
<code>    result.append(currentKValues)</code>
<code>    let previousKValues = currentKValues</code>
<code>    currentKValues = KValues()</code>
<code></code>
<code>    for k in stride(from: -d, through: d, by: 2)</code>
<code>        // Determine the best moves for the current K values</code>
<code>    }</code>
<code>}</code>
<code>return backtrackPath(fromKValues: result) // Additions and Deletions</code>
</pre>
 <p>"Determining" the best move means deciding to go right or down from the positions recorded in the previous depth iteration. We should always move right if <code>k == -d</code> (bottom of the currently "accessible" graph), and always down if <code>k == +d</code> (right edge of the currently "accessible" graph). Otherwise, we should pick the position based on the current adjacent k's best values that leads us to the highest x value -- this way, we prioritize deletion.</p>
 <pre>
<code>let currX: Int</code>
<code>if k == -d {</code>
<code>    currX = previousKValues[k+1] // Moving down</code>
<code>} else if k == d {</code>
<code>    currX = previousKValues[k-1] + 1 // Moving to the right</code>
<code>} else if previousKValues[k-1] &lt; previousKValues[k+1] {</code>
<code>    currX = previousKValues[k+1] // Moving down</code>
<code>} else {</code>
<code>    currX = previousKValues[k-1] + 1 // Moving to the right</code>
<code>}</code>
<code>let currY = currX - k</code>
</pre>
 <p>This loop is the reason why we need to start the algorithm with the <code>1</code> <b>k value</b> set to 0. This makes sure that the first iteration determines that the "first best move" is to go down to 0,0 -- the beginning of the graph. This allows everything else to proceed as normal.</p>
 <p>Once the best move is found, we try to move diagonally as much as we can to claim our free steps.</p>
 <pre>
<code>while currX &lt; a.count &amp;&amp; currY &lt; b.count {</code>
<code>    if a[currX] == b[currY] {</code>
<code>      break</code>
<code>    }</code>
<code>    x &amp;+= 1</code>
<code>    y &amp;+= 1</code>
<code>}</code>
</pre>
 <p>Finally, we store the best X value we've found for the current <b>k value</b> and halt the algorithm if we've reached the bottom right. Note how we only store X: Because <b>k</b> is a ratio of X and Y, we can infer Y from it and thus do not need to store Y.</p>
 <pre>
<code>currentKValues[k] = currX</code>
<code>if currX &gt;= a.count &amp;&amp; currY &gt;= b.count {</code>
<code>    break outer</code>
<code>}</code>
</pre>
 <p>You might wonder how subscripting <code>currentKValues</code> works if k can be negative -- the Standard Library <a href="https://github.com/apple/swift/blob/9de3db97bdbabc503a2445ceb2f6699755aace23/stdlib/public/core/Diffing.swift#L189">created a custom type</a> that translates such negative indexes into positive ones. The idea is to create an array long enough to fit both positive and negative values and treat the indexes inside.</p>
 <p><a href="https://github.com/apple/swift/blob/9de3db97bdbabc503a2445ceb2f6699755aace23/stdlib/public/core/Diffing.swift#L228">The complete algorithm from Swift can be found here.</a></p>
 <p>The result of this implementation of Myers's is an array representing how far each <b>k value</b> has traveled in the X-axis in a specific depth. To get the actual path, all we have to do is backtrack from the only <b>k value</b> that has reached the maximum depth. This is done through a similar loop: For each current value, move up or to the left based on who has the largest X value in the previous iteration of the original method. Here's how this is implemented in the Standard Library (with <code>_V</code> being their version of my <code>KValues</code> type):</p>
 <pre>
<code>// Backtrack through the trace generated by the Myers descent to produce the changes that make up the diff</code>
<code>func _formChanges(</code>
<code>  from a: UnsafeBufferPointer&lt;C.Element&gt;,</code>
<code>  to b: UnsafeBufferPointer&lt;C.Element&gt;,</code>
<code>  using trace: [_V]</code>
<code>) -&gt; [CollectionDifference&lt;C.Element&gt;.Change] {</code>
<code>  var changes = [CollectionDifference&lt;C.Element&gt;.Change]()</code>
<code>  changes.reserveCapacity(trace.count)</code>
<code>  var x = a.count</code>
<code>  var y = b.count</code>
<code>  for d in stride(from: trace.count &amp;- 1, to: 0, by: -1) {</code>
<code>    let v = trace[d]</code>
<code>    let k = x &amp;- y</code>
<code>    let prev_k = (k == -d || (k != d &amp;&amp; v[k &amp;- 1] &lt; v[k &amp;+ 1])) ? k &amp;+ 1 : k &amp;- 1</code>
<code>    let prev_x = v[prev_k]</code>
<code>    let prev_y = prev_x &amp;- prev_k</code>
<code></code>
<code>    while x &gt; prev_x &amp;&amp; y &gt; prev_y {</code>
<code>      // No change at this position.</code>
<code>      x &amp;-= 1</code>
<code>      y &amp;-= 1</code>
<code>    }</code>
<code></code>
<code>    if y != prev_y {</code>
<code>      changes.append(.insert(offset: prev_y, element: b[prev_y], associatedWith: nil))</code>
<code>    } else {</code>
<code>      changes.append(.remove(offset: prev_x, element: a[prev_x], associatedWith: nil))</code>
<code>   }</code>
<code></code>
<code>    x = prev_x</code>
<code>    y = prev_y</code>
<code>  }</code>
<code></code>
<code>  return changes</code>
<code>}</code>
</pre>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>Now that we have the final <code>CollectionDifference</code> type, we can finally return it and conclude the diffing algorithm. The worst case for Myers's is <code>O(a * b)</code> as it is possible for us to traverse all of the nodes of the graph.</p>
 <h2>Conclusion</h2>
 <p>As always, I like to finish these by saying that knowing what's inside of what you're using allows you to make better decisions in code. Different algorithms are meant for different use-cases, and knowing how to make trade-offs is useful everywhere. Plus, you get to learn cool little pieces of trivia -- did you know that Myers's is one of the merging strategies in <b>git</b>? :)</p>
 <h2>References and Good Reads</h2>
 <a href="http://www.xmailserver.org/diff2.pdf">Myers's Paper</a>
 <br>
 <a href="https://github.com/apple/swift/blob/master/stdlib/public/core/Diffing.swift">Diffing.swift</a>
 <br>
 <a href="https://github.com/apple/swift/blob/master/stdlib/public/core/CollectionDifference.swift">CollectionDifference.swift</a>
 <br>
 <a href="https://blog.jcoglan.com/2017/02/12/the-myers-diff-algorithm-part-1/">The Myers Diff Algorithm Explanation - Great read!</a>
 <br>
</div>]]></description>
</item>
<item>
    <title>Swift Codable: Decoding / Encoding With Context</title>
    <link>https://swiftrocks.com/swift-codable-decodingencoding-with-context</link>
    <guid>https://swiftrocks.com/swift-codable-decodingencoding-with-context</guid>
    <pubDate>Wed, 5 Feb 2020 04:25:00 GMT-3</pubDate>
<description><![CDATA[
 
  
  <!--WRITEIT_POST_NAME=Swift Codable: Decoding / Encoding With Context--> 
  <!--WRITEIT_POST_HTML_NAME=swift-codable-decodingencoding-with-context--> 
  <!--WRITEIT_POST_SITEMAP_DATE_LAST_MOD=2020-04-12T14:00:00+02:00--> 
  <!--WRITEIT_POST_SITEMAP_DATE=2020-02-05T07:25:00+00:00--> 
  <!--Add here the additional properties that you want each page to possess.--> 
  <!--These properties can be used to change content in the template page or in the page itself as shown here.--> 
  <!--Properties must start with 'WRITEIT_POST'.--> 
  <!--Writeit provides and injects WRITEIT_POST_NAME and WRITEIT_POST_HTML_NAME by default.--> 
  <!--WRITEIT_POST_SHORT_DESCRIPTION=The Codable protocols are one of the coolest recent additions to Swift. Even though it works similarly to its community counterparts like Unbox, Codable has the advantage of being powered by the compiler. One of my favorite features in Unbox was to give a context to the decoding operation. Let's take a look at how we can achieve the same with Codable and how I use to power a type-erased Decodable type.--> 
  <title>Swift Codable: Decoding / Encoding With Context</title> 
 

<div class="blog-post"> 
 <div class="post-title-index">  
  <h1>Swift Codable: Decoding / Encoding With Context</h1>
 </div> 
 <div class="post-info"> 
  <div class="category category-swift">
   Swift
  </div> 
  <div class="post-info-text">
   Published on 05 Feb 2020 
  </div> 
 </div>   
 <p>The <code>Codable</code> protocols are one of the coolest recent additions to Swift. Even though it works similarly to its community counterparts like <code>Unbox</code>, <code>Codable</code> has the advantage of being powered by the compiler.</p>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>One of my favorite features in <code>Unbox</code> was to give a <b>context</b> to the decoding operation. Let's take a look at how we can achieve the same with <code>Codable</code>.</p>
 <h2>Example 1: Giving different values to the same property</h2>
 <p>Decoding with "context" refers to the ability to change how types are decoded depending on what's going on in your app. Let's say that our app is sending a request asking for information regarding a header that should be displayed on the screen, with our app locally storing an additional <code>textColor</code> property into the model:</p>
 <pre>
<code>struct HeaderInformation: Decodable {</code>
<code>    let title: String</code>
<code>    let imageUrl: String</code>
<code>    var textColor: UIColor {</code>
<code>        return .black</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>Now, imagine the following situation: What if we want <code>textColor</code> to be <b>different</b> depending on which screen such header is being presented? For example, displaying headers on the app's home could have a green text, while headers at the profile screen could be blue.</p>
 <p>There are multiple ways to achieve this, but let's focus on <code>Codable</code>. <code>Codable</code> allows you to provide context to a <code>JSONDecoder</code>/<code>JSONEncoder</code> through their <code>userInfo</code> property:</p>
 <pre>
<code>/// Contextual user-provided information for use during decoding.</code>
<code>open var userInfo: [CodingUserInfoKey : Any]</code>
</pre>
 <p>The <code>CodingUserInfoKey</code> is a <code>RawRepresentable</code> string enum, so you can add pretty much anything to <code>userInfo</code>. When this is done, the same <code>userInfo</code> values will be accessible as part of the inner <code>Decoder</code>/<code>Encoder</code> instance:</p>
 <pre>
<code>struct HeaderInformation: Decodable {</code>
<code>    let title: String</code>
<code>    let imageUrl: String</code>
<code>    let textColor: UIColor</code>
<code></code>
<code>    static var textColorUserInfoKey: CodingUserInfoKey {</code>
<code>        return CodingUserInfoKey(rawValue: "textColor")!</code>
<code>    }</code>
<code></code>
<code>    init(from decoder: Decoder) throws {</code>
<code>        let container = try decoder.container(keyedBy: CodingKeys.self)</code>
<code>        title = try container.decode(String.self, forKey: .title)</code>
<code>        imageUrl = try container.decode(String.self, forKey: .imageUrl)</code>
<code></code>
<code>        textColor = decoder.userInfo[Self.textColorUserInfoKey] as? UIColor ?? .black</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>To make this work, simply fill the <code>userInfo</code> dictionary before decoding the data.</p>
 <pre>
<code>let decoder = JSONDecoder()</code>
<code></code>
<code>decoder.userInfo[HeaderInformation.textColorUserInfoKey] = UIColor.red</code>
<code></code>
<code>let headerInfo = decoder.decode(HeaderInformation.self, from: data)</code>
</pre>
 <p><code>CodingUserInfoKey</code> requires force-unwrapping because it is <code>RawRepresentable</code>, but doing so will never result in a crash. To hide it, I like to abstract it inside an extension that takes a regular <code>String</code> instead:</p>
 <pre>
<code>extension Decoder {</code>
<code>    func getContext(forKey key: String) -&gt; Any? {</code>
<code>        let infoKey = CodingUserInfoKey(rawValue: key)!</code>
<code>        return userInfo[infoKey]</code>
<code>    }</code>
<code>}</code>
<code></code>
<code>extension JSONDecoder {</code>
<code>    func set(context: Any?, forKey key: String) {</code>
<code>        let infoKey = CodingUserInfoKey(rawValue: key)!</code>
<code>        userInfo[infoKey] = context</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>We can now use the type's own <code>CodingKeys</code> as the userInfo key, resulting in the following improvements:</p>
 <pre>
<code>let key = HeaderInformation.CodingKeys.textColor.stringValue</code>
<code>decoder.set(context: UIColor.red, forKey: key)</code>
<code>//</code>
<code>textColor = decoder.getContext(forKey: CodingKeys.textColor.stringValue)</code>
</pre>
 <h2>Example 2: Powering modularized type-erased structs</h2>
 <p>One cool example of how I use <code>Codable</code> contexts is how <code>AnyRoute</code> works in <a href="https://github.com/rockbruno/RouterService">the RouterService library:</a></p>
 <pre>
<code>/// A type-erased container for a `Route`, used for route decoding purposes.</code>
<code>public struct AnyRoute {</code>
<code>    public let value: Route</code>
<code>    public let routeString: String</code>
<code>}</code>
</pre>
 <p>In short, we have the following environment:</p>
 <p>- Apps can define their own "routes", which are structs used to navigate between screens.</p>
 <p>- These routes are registered into a <code>RouterService</code> instance, which receives said routes and pushes the related view controllers.</p>
 <p>- Routes can be decoded from a specific string format, allowing your backend to dictate which screen the app should navigate to.</p>
 <p>The latter is done through <code>AnyRoute</code> -- an erased <code>Route</code> type that knows how to decode such string format into the actual <code>Route</code> type defined by the app. The problem is: <b>because AnyRoute is defined inside the RouterService library, it has no access to the app's Routes. How can it decode the correct Route type?</b></p>
 <p>This can be achieved by using <code>Codable</code>'s context features. Because <code>Routes</code> have to be registered in the main <code>RouterService</code> instance, we can inject it into the decoding operation and have it determine which <code>Route</code> should be decoded:</p>
 <pre>
<code>extension AnyRoute: Decodable {</code>
<code>    static var contextUserInfoKey: CodingUserInfoKey {</code>
<code>        // swiftlint:disable:next force_unwrapping</code>
<code>        return CodingUserInfoKey(rawValue: "routerservice_anyroute_context")!</code>
<code>    }</code>
<code></code>
<code>    public init(from decoder: Decoder) throws {</code>
<code>        let ctx = decoder.userInfo[AnyRoute.contextUserInfoKey]</code>
<code></code>
<code>        guard let context = ctx as? RouterServiceAnyRouteDecodingProtocol else {</code>
<code>            preconditionFailure("TRIED TO DECODE ANYROUTE WITHOUT A CONTEXT!")</code>
<code>        }</code>
<code></code>
<code>        let data = try context.decodeAnyRoute(fromDecoder: decoder)</code>
<code></code>
<code>        self.value = data.0</code>
<code>        self.routeString = data.1</code>
<code>    }</code>
<code>}</code>
<code></code>
<code>public protocol RouterServiceAnyRouteDecodingProtocol {</code>
<code>    func decodeAnyRoute(fromDecoder decoder: Decoder) throws -&gt; (Route, String)</code>
<code>}</code>
</pre>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>Assuming that <code>RouterService</code> was injected into the <code>JSONDecoder</code>, the decoding operation will be deferred to it:</p>
 <pre>
<code>extension RouterService: RouterServiceAnyRouteDecodingProtocol {</code>
<code>    public func decodeAnyRoute(fromDecoder decoder: Decoder) throws -&gt; (Route, String) {</code>
<code>        let container = try decoder.singleValueContainer()</code>
<code>        let identifier = try container.decode(String.self)</code>
<code></code>
<code>        guard let routeString = RouteString(fromString: identifier) else {</code>
<code>            throw RouteDecodingError.failedToParseRouteString</code>
<code>        }</code>
<code></code>
<code>        guard let routeType = registeredRoutes[routeString.scheme]?.0 else {</code>
<code>            throw RouteDecodingError.unregisteredRoute</code>
<code>        }</code>
<code></code>
<code>        do {</code>
<code>            let value = try routeType.decode(JSONDecoder(), routeString.parameterData)</code>
<code>            return (value, routeString.originalString)</code>
<code>        } catch {</code>
<code>            throw error</code>
<code>        }</code>
<code>    }</code>
<code></code>
<code>    public enum RouteDecodingError: Swift.Error {</code>
<code>        case unregisteredRoute</code>
<code>        case failedToParseRouteString</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>This decentralized behavior is especially important for modular apps (which is <code>RouterService</code>'s use case), as different targets can reference and decode <code>AnyRoutes</code> without having access to the app's real <code>Routes</code>.</p>
</div>]]></description>
</item>
<item>
    <title>Reducing iOS Build Times by using Interface Modules</title>
    <link>https://swiftrocks.com/reducing-ios-build-times-by-using-interface-modules</link>
    <guid>https://swiftrocks.com/reducing-ios-build-times-by-using-interface-modules</guid>
    <pubDate>Thu, 23 Jan 2020 03:00:00 GMT-3</pubDate>
<description><![CDATA[
 
  
  <!--WRITEIT_POST_NAME=Reducing iOS Build Times by using Interface Modules--> 
  <!--WRITEIT_POST_HTML_NAME=reducing-ios-build-times-by-using-interface-modules--> 
  <!--WRITEIT_POST_SITEMAP_DATE_LAST_MOD=2020-06-15T11:00:00+02:00--> 
  <!--WRITEIT_POST_SITEMAP_DATE=2020-01-23T06:00:00+00:00--> 
  <!--Add here the additional properties that you want each page to possess.--> 
  <!--These properties can be used to change content in the template page or in the page itself as shown here.--> 
  <!--Properties must start with 'WRITEIT_POST'.--> 
  <!--Writeit provides and injects WRITEIT_POST_NAME and WRITEIT_POST_HTML_NAME by default.--> 
  <!--WRITEIT_POST_SHORT_DESCRIPTION=While dividing an app into several modules can improve the build time of an iOS app, the result heavily depends on what is being changed. If you're not careful with how your dependency graph is laid out, you can often have results that are worse< than non-modularized apps. Let's take a look at a technique used at iFood to have big and consistent improvements to the build times of our app.--> 
  <title>Reducing iOS Build Times by using Interface Modules</title> 
 

<div class="blog-post"> 
 <div class="post-title-index">  
  <h1>Reducing iOS Build Times by using Interface Modules</h1>
 </div> 
 <div class="post-info"> 
  <div class="category category-theory">
   Theory
  </div> 
  <div class="category category-swift">
   Swift
  </div> 
  <div class="post-info-text">
   Published on 23 Jan 2020 
  </div> 
 </div>  
 <p>While dividing an app into several modules can improve the build time of an iOS app, the result heavily depends on what is being changed. If you're not careful with how your dependency graph is laid out, you can often have results that are <b>worse</b> than non-modularized apps. Let's take a look at a technique used at iFood to have big and consistent improvements to the build times of our app.</p>
 <h2>Context: The process to modularize an app</h2>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>Before jumping into the actual techniques, let's add some context to this so we have a better idea of <b>why</b> they are necessary.</p>
 <p><i>(For the purposes of this article, we ignore the concept of Xcode's incremental build feature as I personally never saw it make a considerable difference in build times compared to the improvements you get by properly modularizing the app. This is geared towards apps that are built on top of monorepo systems that cache builds between CI builds)</i></p>
 <p>When tasked to develop a small project, a developer's first idea will usually be to create a <b>single module</b> that contains absolutely all the code and resources:</p>
 <div class="post-image margin-top-40 margin-bottom-40" style="text-align: center;"> 
  <img src="https://i.imgur.com/Td17sGi.png" alt="Big module"> 
 </div>
 <p>This is how beginners usually develop their first few apps, and how seasoned developers still develop apps that are sufficiently small for this approach to be useful.</p>
 <p>This approach is the easiest one in terms of project maintainability, but the worse one in terms of build times. Because everything is packed together, changing <b>anything</b> results in <b>everything</b> being recompiled, even if they have nothing to do with what's changed. While this not much of a problem for small apps, big ones take massive performance hits with this approach, easily reaching build times of over twenty minutes.</p>
 <p>Because of that, more seasoned developers will often opt for a modularized structure when developing apps. This time, instead of having a single monster modules, we divide our code and resources into several smaller ones, which are then linked together either manually inside Xcode, or through a dependency manager like CocoaPods / monorepo build system like Buck (what we personally use at iFood)</p>
 <div class="post-image margin-top-40 margin-bottom-40" style="text-align: center;"> 
  <img src="https://i.imgur.com/M69uv4R.png" alt="App with some modules"> 
 </div>
 <p>In this specific diagram, because the modules have no connection to each other, making changes to a feature will make so that other features <b>do not</b> get recompiled, which provides a massive boost to the app's build time. Hooray!</p>
 <p>Unfortunately, this statement is only true to this specific diagram. As an app grows, it's more likely that you will end with something like this:</p>
 <div class="post-image margin-top-40 margin-bottom-40" style="text-align: center;"> 
  <img src="https://i.imgur.com/7R1dewm.png" alt="Bad dependency cycle"> 
 </div>
 <p>While the previous condition is still true if the changes are made to the modules in the lower end of this graph (<code>AppFeature1</code>, <code>AppFeature2</code>, <code>AppFeature3</code>), it is not true for the rest.</p>
 <p>Take the <code>HTTPClient</code> module for example: Because <b>everyone</b> depends on it, making changes to it will make the <b>entire app need to be recompiled</b>, even if the changes have nothing to do with the modules themselves, like a simple code quality improvement!</p>
 <p>Another common problem of this approach is how <code>AppFeature1</code> is structured: It has a dependency on <code>AppFeature4</code>, which on its turn has a dependency on <code>AppFeature5</code>. An example of how this can happen is if these features represent <code>UIViewControllers</code> -- making so a module needs to import another one for a view to be able to be pushed. This <b>linear dependency</b> between these modules has three major problems:</p>
 <p>- Because the dependency is linear, you are unable to compile them in parallel, which is a major performance problem.</p>
 <p>- Changing <code>AppFeature5</code> will recompile <code>AppFeature4</code> and <code>AppFeature1</code> even if the changes have nothing to do with them, just because they depend on it!</p>
 <p>- Finally, the fact that they completely depend on each other is overkill. They are dependencies only for the purpose of being able to navigate between each other -- they don't need access to anything else of the respective modules. This makes the previous problem even more critical as these features will be recompiled for no reason almost 100% of the time!</p>
 <p>The problems of this diagram are a good representation of how iFood looked like for a long time, and although the modularization itself improved build times in some cases, most of the cases still provided very bad build times.</p>
 <p>In order to achieve the best possible build times, we need to make our dependency graph as <b>horizontal</b> as possible. If everything is independent, everything can be compiled in parallel.</p>
 <div class="post-image margin-top-40 margin-bottom-40" style="text-align: center;"> 
  <img src="https://i.imgur.com/gnne0rL.png" alt="Horizontal dependency"> 
 </div>
 <p>Unfortunately, this is impossible in our case. Because our modules need to navigate between each other's <code>UIViewControllers</code>, they need to be able to reference each other somehow. The same applies to components like <code>HTTPClient</code> -- as they need to somehow have access to it in order to make HTTP requests, they can never be truly independent. ...or can they?</p>
 <p>The true answer is, well, no. However, through dependency injection, there's a technique we can apply to get pretty close to it.</p>
 <h2>"Interface" modules: Never depend on concrete modules</h2>
 <p>Let's focus on the problems caused by the previously mentioned <b>linear dependency</b> of some of the modules: These features depend on the modules of the features they navigate to, but they don't access anything of these modules besides the <code>UIViewController</code> that they are navigating to.</p>
 <div class="post-image margin-top-40 margin-bottom-40" style="text-align: center;"> 
  <img src="https://i.imgur.com/XAQ4CtN.png" alt="Problem"> 
 </div>
 <p>If this problem is caused because the features are depending on more than they need to, what if we divide the navigation aspect of a feature from its actual contents? Having this in mind, instead of a having a massive "feature" module that has everything, we can separate the relevant navigation content into its own "interface" module:</p>
 <div class="post-image margin-top-40 margin-bottom-40" style="text-align: center;"> 
  <img src="https://i.imgur.com/u0sF8SF.png" alt="App with interfaces" style="height: 250px; width: 300px;"> 
 </div>
 <p>"Interface" modules don't contain any concrete code or dependencies -- they just contain protocols that are used by the modules that depend on it to reference some piece of code that is defined in the real, concrete module.</p>
 <p>For example, assuming that <code>AppFeature1</code> wants to push a <code>UIViewController</code> that lives in <code>AppFeature2</code>, instead of having <code>AppFeature1</code> depend on <code>AppFeature2</code> and directly reference such <code>UIViewController</code>, we can have it depend on a hypothetical <code>AppFeature2Interface</code> module that has a protocol that serves no purpose but to expose the existence of that view to <code>AppFeature1</code>:</p>
 <pre>
<code>protocol Feature2ViewProtocol {}</code>
</pre>
 <p><code>AppFeature2</code> can then implement this protocol into the related, concrete <code>UIViewController</code>:</p>
 <pre>
<code>import AppFeature2Interface</code>
<code>class Feature2ViewController: UIViewController, Feature2ViewProtocol</code>
</pre>
 <p>With this setup, <code>AppFeature1</code> can now reference <code>AppFeature2's</code> <code>UIViewController</code> without actually importing it:</p>
 <pre>
<code>import AppFeature2Interface</code>
<code>let viewTypeToBePushed = Feature2ViewProtocol.self</code>
</pre>
 <p>While <code>AppFeature1</code> still imports the interface itself, its size is considerably smaller than the actual feature's module, while the final result (getting a view to be pushed) is the same. <code>AppFeature1</code> now imports only what it really needs, making so it will only be recompiled by changes that actually affect it. </p>
 <p>However, there's a small catch. You might notice that this example doesn't make sense: While <code>AppFeature1</code> has access to the protocol that references <code>AppFeature2's</code> <code>UIViewController</code>, it can't actually push it. If we only have access to the bare <code>protocol</code>, we are unable to create an instance of the concrete <code>class</code> that only exists in <code>AppFeature2</code>.</p>
 <p>This is because we're missing a key component in this structure: <b>a dependency injector.</b> In an app like this, because there's no way for modules to reference the concrete information from other modules, there needs to be a global system that is capable of returning the (now hidden) concrete information to modules when a certain protocol is given. At iFood, we solved this by creating a dependency injector called <code>RouterService</code> -- here, each feature's module's interface only exposes a series of <code>Route</code> structs, while each feature's concrete module connects these <code>Routes</code> to the related <code>UIViewController</code>.</p>
 <p>With this information exposed, iFood's AppDelegate creates an instance of a <code>RouterService</code> which receives every feature's routes and related <code>UIViewControllers</code>. When a feature asks for a specific <code>Route</code> from another feature's interface to be executed, the <code>RouterService</code> automatically locates which <code>UIViewController</code> should be pushed. The process to create something like was detailed in my previous article, <a href="https://swiftrocks.com/using-type-erasure-to-build-a-dependency-injector-in-swift">Using Type Erasure to Build a Dependency Injecting Routing Framework in Swift.</a> Here's a simplified example of how the previous example looks like in our app:</p>
 <pre>
<code>// AppFeature2Interface, which depends on RouterServiceInterface</code>
<code>public struct Feature2Route: Route { ... }</code>
</pre>
 <pre>
<code>// AppFeature2</code>
<code>import AppFeature2Interface</code>
<code></code>
<code>class Feature2ViewController: Feature { ... }</code>
<code></code>
<code>public class Feature2RouteHandler: RouteHandler { </code>
<code>    var routes: [Route.Type] {</code>
<code>        return [Feature2Route.self]</code>
<code>    }</code>
<code></code>
<code>    func featureFor(route: Route) -&gt; AnyFeature {</code>
<code>        return AnyFeature(Feature2ViewController.self)</code>
<code>    }</code>
<code>}</code>
</pre>
 <pre>
<code>// iFood's AppDelegate</code>
<code>import AppFeature1</code>
<code>import AppFeature2</code>
<code></code>
<code>let routerService = RouterService()</code>
<code>routerService.register(Feature1RouteHandler())</code>
<code>routerService.register(Feature2RouteHandler())</code>
<code>routerService.start(fromRoute: Feature1Route.self)</code>
</pre>
 <pre>
<code>// AppFeature1</code>
<code>import AppFeature2Interface</code>
<code></code>
<code>func goToFeature2() {</code>
<code>    routerService.navigate(toRoute: Feature2Route())</code>
<code>    // RouterService translates Feature2Route into the actual Feature2ViewController</code>
<code>    // and pushes the related UIViewController.</code>
<code>}</code>
</pre>
 <p>In terms of build time, because <code>AppFeature1</code> doesn't depend on <code>AppFeature2</code> anymore, changes to <code>AppFeature2</code> will <b>not</b> recompile <code>AppFeature1</code>. If you had multiple modules depending on each other, an app that runs entirely on this structure will provide a massive boost in build performance!</p>
 <p>As a bonus, this structure can be applied to everything that can be injected. Using the previous complete diagram as an example, we could also add an interface to the <code>HTTPClient</code> that contains only the protocol that defines how requests are made. This allows modules to only reference this protocol, while the dependency injector becomes responsible for injecting the actual concrete class into the modules that reference such protocol. In the end, we can end up with the following diagram:</p>
 <div class="post-image margin-top-40 margin-bottom-40" style="text-align: center;"> 
  <img src="https://i.imgur.com/6sn22b4.png" alt="Full app with interfaces"> 
 </div>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p><i>(Not shown: In our case, everyone depends on something called a <code>RouterServiceInterface</code>, with the main module depending on the concrete <code>RouterService</code>, which dynamically links the interfaces to their actual classes.)</i></p>
 <p>Note how the graph is considerably more <b>horizontal</b> than its counterpart -- even though everyone depends on <code>HTTPClientInterface</code>, changes to the actual <code>HTTPClient</code> will have no repercussions on the other modules, making the app compile considerably faster. With an entire app running on this structure, you should only have bad compilation times if the interfaces themselves are changed -- something that should be a rare occurrence. In general, every module is going to be completely independent of each other, which can be especially useful and productive when developing inside the module's specific scheme in Xcode.</p>
</div>]]></description>
</item>
<item>
    <title>How Hashable works in Swift</title>
    <link>https://swiftrocks.com/how-hashable-works-in-swift</link>
    <guid>https://swiftrocks.com/how-hashable-works-in-swift</guid>
    <pubDate>Mon, 13 Jan 2020 03:00:00 GMT-3</pubDate>
<description><![CDATA[
 
  
  <!--WRITEIT_POST_NAME=How Hashable works in Swift--> 
  <!--WRITEIT_POST_HTML_NAME=how-hashable-works-in-swift--> 
  <!--WRITEIT_POST_SITEMAP_DATE_LAST_MOD=2020-04-12T14:00:00+02:00--> 
  <!--WRITEIT_POST_SITEMAP_DATE=2020-01-13T06:00:00+00:00--> 
  <!--Add here the additional properties that you want each page to possess.--> 
  <!--These properties can be used to change content in the template page or in the page itself as shown here.--> 
  <!--Properties must start with 'WRITEIT_POST'.--> 
  <!--Writeit provides and injects WRITEIT_POST_NAME and WRITEIT_POST_HTML_NAME by default.--> 
  <!--WRITEIT_POST_SHORT_DESCRIPTION=Hashing algorithms are functions that map an arbitrary string to a seemingly "random" output with a fixed length. Commonly associated as a component of Sets and Dictionaries, hashing algorithms are a major component of several branches of computer science, including cryptography. The internal algorithm used to calculate a type's `hashValue` (now `Hasher` in Swift 4.2) and the related compiler features changed several times throughout Swift's releases, ant it was only after Swift 4.2 that a real universal hashing algorithm was added to Swift. To see how this is implemented today, let's take a look at how this looked like throughout the history of Swift.--> 
  <title>How Hashable works in Swift</title>  
 

<div class="blog-post"> 
 <div class="post-title-index">  
  <h1>How Hashable works in Swift</h1>
 </div> 
 <div class="post-info"> 
  <div class="category category-compiler">
   Compiler
  </div> 
  <div class="category category-swift">
   Swift
  </div> 
  <div class="post-info-text">
   Published on 13 Jan 2020 
  </div> 
 </div>   
 <p>Hashing algorithms are functions that map an arbitrary string to a seemingly "random" output with a fixed length. Commonly associated as a component of <code>Sets</code> and <code>Dictionaries</code>, hashing algorithms are a major component of several branches of computer science, including cryptography.</p>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>In Swift, the <code>Hashable</code> protocol is the main component used to provide hashing capabilities to custom types. It is most commonly used to allow types to be used as the key of <code>Dictionaries</code> and <code>Sets</code>, but it also gives you access to `Sequence` helper methods like `contains(_:)`.</p>
 <p>The way it works is that <code>Hashable</code> exposes a <code>hashValue</code> property (now <code>Hasher</code> in Swift 4.2), which is an <code>Int</code> that represents a not-guaranteed-but-hopefully-most-of-the-times <b>unique</b> number that represents the contents of that type. In the case of <code>Dictionaries</code>, this number is used to calculate where in memory a key's value should be stored to later allow you to retrieve that same value in constant time. As the implementations of the protocol aren't the scope of this article, <a href="https://www.youtube.com/watch?v=shs0KM3wKv8">here's a video on hash tables</a> if you need more information on this.</p>
 <p>The internal algorithm used to calculate a type's <code>hashValue</code> (now <code>Hasher</code> in Swift 4.2) and the related compiler features changed several times throughout Swift's releases, and it was only after Swift 4.2 that a real universal hashing algorithm was added to Swift. To see how this is implemented today, let's take a look at how this looked like throughout the history of Swift.</p>
 <h2>Swift 4.0 and below - A lawless world</h2>
 <p>Throughout the history of Swift up until Swift 4.0, the internal implementation of a <code>Int's</code> <code>hashValue</code> simply returned their own value, while <code>Strings</code> alternated between using the MurmurHash2 algorithm (Swift 3.0 and below) and SipHash1-3 (Swift 4.0 forward).</p>
 <p>Although <code>Strings</code> were doing fine in terms of algorithms, adding <code>Hashable</code> conformance to custom types in that period of time was usually an annoyance. If you were around that time, then you probably remember that Apple's recommended way to implement <code>hashValue</code> was to XOR all properties together:</p>
 <pre>
<code>struct Foo: Hashable {</code>
<code>    let someProperty: String</code>
<code>    let anotherProperty: String</code>
<code></code>
<code>    var hashValue: Int {</code>
<code>        return someProperty.hashValue ^ anotherProperty.hashValue</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>As there was no automatic synthesis at the time, this is how things worked for a long time.</p>
 <p>Although this did the trick in terms of hashing, the necessity of having users do this in first place was fundamentally flawed:</p>
 <p>- Good hashing algorithms are very complex, so it's unreasonable to expect that your average developer will be able to determine if simply XORing properties is enough for the desired use-case.<br> - Because this is a manual bit manipulation process, this is very easy to screw up.<br> </p>
 <p>- Good hashing algorithms have guarantees in terms of collision resistance, distribution and safety, while XORing properties have none of them.</p>
 <p>As Swift is known to be very user-friendly, changes were definitely expected -- and they came.</p>
 <h2>Swift 4.1: Synthesize Hashable with _mixInt</h2>
 <p>Alongside the changes to synthesize conformance to Equatable types, Swift 4.1 attempted to treat this problem for the first time by synthesizing a custom type's conformance to Hashable as well.</p>
 <p>(We won't talk about how compiler synthesis works because it was already covered in <a href="https://swiftrocks.com/how-caseiterable-works-internally-in-swift">How CaseIterable Works Internally in Swift</a>, and Hashable synthesis works pretty much exactly the same as the CaseIterable one. If you want more info on that, check that article out!)</p>
 <p>With the proposed changes, while the synthetized <code>hashValue</code> would still XOR a type's properties's <code>hashValues</code>, the values that are being XORed would not be the <code>hashValues</code> themselves -- but a "scrambled" version of them, provided by an internal method called <code>_mixInt</code>:</p>
 <pre>
<code>struct Foo: Hashable {</code>
<code>    let someProperty: String</code>
<code>    let anotherProperty: String</code>
<code></code>
<code>//////// Compiler Generated ///////// </code>
<code></code>
<code>    var hashValue: Int {</code>
<code>        return _mixInt64(someProperty.hashValue) ^ _mixInt64(anotherProperty.hashValue)</code>
<code>    }</code>
<code></code>
<code>/////////////////////////////////////</code>
<code>}</code>
</pre>
 <p>The implementation of <code>_mixInt</code> progressively multiplies and shifts the original integer's bits based on a randomly picked hardcoded value. Because most of the original value's bit information will be lost during the shifting steps, this will make the resulting value appear to be completely random, which is a very important trait of a hashing algorithm.</p>
 <pre>
<code>static func hash16Bytes(_ low: UInt64, _ high: UInt64) -&gt; UInt64 {</code>
<code>  let mul: UInt64 = 0x9ddfea08eb382d69</code>
<code>  var a: UInt64 = (low ^ high) &amp;* mul</code>
<code>  a ^= (a &gt;&gt; 47)</code>
<code>  var b: UInt64 = (high ^ a) &amp;* mul</code>
<code>  b ^= (b &gt;&gt; 47)</code>
<code>  b = b &amp;* mul</code>
<code>  return b</code>
<code>}</code>
</pre>
 <p>If this looks like a bunch of gibberish to you, welcome to hashing algorithms! In fact, as having pseudorandom results is an important quality of good hashing algorithms, you'll see that most hashing algorithms are based on even weirder non-sense. It's exactly what they are supposed to do!</p>
 <p>Although <code>_mixInt</code> is an implementation of its own, its behavior was inspired by a widely-used hashing algorithm called MurmurHash -- which works in a similar fashion of progressively multiplying, shifting and XORing values, although in a more complex way.</p>
 <p>While this is better than simply XORing properties, this approach still had some flaws. First of all, while <code>_mixInt</code> ticked a few boxes of what defines a good hashing algorithm, like having <i>avalanche behavior</i> (minor changes in the input have catastrophic, pseudorandom effects in the output), it was never intended to be used to combine hash values.</p>
 <p>A second problem is that <code>_mixInt</code> was private, so manual implementations of <code>Hashable</code> were still flawed in the same ways of the past Swift versions.</p>
 <p>As a third problem, another issue is that just like MurmurHash, <code>_mixInt</code> is an <b>unsafe</b> algorithm. <i>But whoah! Why would they add something unsafe to the language?</i></p>
 <p>Don't worry! In the world of hashing algorithms, this term is not necessarily a bad thing. Before continuing on why this is bad in this specific case, let's understand what this means.</p>
 <h3>What makes a hashing algorithm "safe"?</h3>
 <p>In the world of hashing algorithms, safety is measured by how viable an algorithm is in the context of cryptography. This is measured by how well the algorithms fit some key requirements, like:</p>
 <p>- Given a hash, it should be extremely hard to find the input that created it. (pre-image resistance)<br> - Given an input and a hash, it should be extremely hard to find another input that generates the same hash (collision resistance)<br> - The output should appear to be completely random. (pseudorandomness)<br> - Hashes from different inputs should have no concrete relation to each other, even if the inputs have clear similarities (non-malleability)<br> - The algorithm should be fast, but slow enough so that brute-forcing your way through the previous requirements is unfeasible.</p>
 <p>An example of an algorithm that fits most of these boxes is SHA, which is today's standard for checking the integrity of files.</p>
 <p>Because Swift needs hashing for the purposes of efficiently storing values in <code>Dictionaries</code> and <code>Sets</code>, having strong cryptographic abilities is simply not important here. Instead, hashing algorithms for purposes like Swift's tend to focus more on speed (as there isn't much to be brute-forced) and good distribution of values in order to minimize (but for performance reasons, not completely avoid) collisions.</p>
 <p>Unfortunately, the lack of cryptographic abilities makes unsafe algorithms susceptible to some attacks. In Swift's case, <code>_mixInt</code> was weak to hash flooding: An attack where someone purposively feeds inputs that they know will produce the same final index in a hash table in order to cause as many collisions as possible, in an attempt to bring down the service that is hosting this hash table.</p>
 <p>Unsafe algorithms are supposed to be used in environments where the lack of safety isn't a problem, which is not 100% true for hash tables. Fortunately, the solution to these problems came in Swift 4.2 with the addition of <code>Hasher</code>.</p>
 <h2>Swift 4.2 - Hasher brings SipHash-1-3 for everyone</h2>
 <p>As part of <code>Hashable's</code> revamp in Swift 4.2, The <code>Hasher</code> type was added as a public API to abstract the process of creating <code>hashValues</code> from the user. Now, instead of manually providing a <code>hashValue</code>, the property was replaced by <code>Hashable's</code> new <code>hash(into:)</code> method which receives a reference to a <code>Hasher</code> instance.</p>
 <pre>
<code>struct Foo: Hashable {</code>
<code>    let someProperty: String</code>
<code>    let anotherProperty: String</code>
<code></code>
<code>//////// Compiler Generated /////////</code>
<code></code>
<code>    func hash(into hasher: inout Hasher) {</code>
<code>        hasher.combine(someProperty)</code>
<code>        hasher.combine(anotherProperty)</code>
<code>    }</code>
<code></code>
<code>/////////////////////////////////////</code>
<code></code>
<code>}</code>
</pre>
 <p>Because <code>Hasher</code> abstracts the hashing process, this means that manual implementations don't have to hope that XORing things together was good enough -- you can now just send everything to <code>Hasher</code> and let it handle the rest with its internal algorithms.</p>
 <p>The addition of <code>Hasher</code> also meant that Swift now officially had a universal hashing algorithm, as everything in the Standard Library (including <code>Ints</code> and <code>Strings</code>) was modified to exclusively use <code>Hasher</code> when building hash values.</p>
 <p>This algorithm is SipHash -- which at first glance might not look too different from <code>_mixInt</code> as things are still based on random values and operations:</p>
 <pre>
<code>extension Hasher {</code>
<code>  // FIXME: Remove @usableFromInline and @frozen once Hasher is resilient.</code>
<code>  // rdar://problem/38549901</code>
<code>  @usableFromInline @frozen</code>
<code>  internal struct _State {</code>
<code>    // "somepseudorandomlygeneratedbytes"</code>
<code>    private var v0: UInt64 = 0x736f6d6570736575</code>
<code>    private var v1: UInt64 = 0x646f72616e646f6d</code>
<code>    private var v2: UInt64 = 0x6c7967656e657261</code>
<code>    private var v3: UInt64 = 0x7465646279746573</code>
<code></code>
<code>    @inline(__always)</code>
<code>    internal init(rawSeed: (UInt64, UInt64)) {</code>
<code>      v3 ^= rawSeed.1</code>
<code>      v2 ^= rawSeed.0</code>
<code>      v1 ^= rawSeed.1</code>
<code>      v0 ^= rawSeed.0</code>
<code>    }</code>
<code>  }</code>
<code>}</code>
<code></code>
<code>extension Hasher._State {</code>
<code>  @inline(__always)</code>
<code>  private static func _rotateLeft(_ x: UInt64, by amount: UInt64) -&gt; UInt64 {</code>
<code>    return (x &amp;&lt;&lt; amount) | (x &amp;&gt;&gt; (64 - amount))</code>
<code>  }</code>
<code></code>
<code>  @inline(__always)</code>
<code>  private mutating func _round() {</code>
<code>    v0 = v0 &amp;+ v1</code>
<code>    v1 = Hasher._State._rotateLeft(v1, by: 13)</code>
<code>    v1 ^= v0</code>
<code>    v0 = Hasher._State._rotateLeft(v0, by: 32)</code>
<code>    v2 = v2 &amp;+ v3</code>
<code>    v3 = Hasher._State._rotateLeft(v3, by: 16)</code>
<code>    v3 ^= v2</code>
<code>    v0 = v0 &amp;+ v3</code>
<code>    v3 = Hasher._State._rotateLeft(v3, by: 21)</code>
<code>    v3 ^= v0</code>
<code>    v2 = v2 &amp;+ v1</code>
<code>    v1 = Hasher._State._rotateLeft(v1, by: 17)</code>
<code>    v1 ^= v2</code>
<code>    v2 = Hasher._State._rotateLeft(v2, by: 32)</code>
<code>  }</code>
<code></code>
<code>  @inline(__always)</code>
<code>  private func _extract() -&gt; UInt64 {</code>
<code>    return v0 ^ v1 ^ v2 ^ v3</code>
<code>  }</code>
<code>}</code>
</pre>
 <p>However, there is a fundamental difference between the two.</p>
 <p>While algorithms like MurmurHash only need the input to produce the output, SipHash is a <b>keyed hash function</b> which also requires an arbitrary secret key value to perform the hashing. Hashing equal values with different keys will produce completely different results, which means that attackers cannot perform hash flooding attacks against SipHash-powered systems without knowing the key that's being used.</p>
 <p>For safety, in Swift, SipHash's key is <b>randomly generated during runtime.</b> This is why Apple tells you to never save/compare <code>hashValues</code> of a property between sessions: The same property will have different hash values in different executions of an app because SipHash's key will be different:</p>
 <pre>
<code>static swift::_SwiftHashingParameters initializeHashingParameters() {</code>
<code>  auto determinism = getenv("SWIFT_DETERMINISTIC_HASHING");</code>
<code>  if (determinism &amp;&amp; 0 == strcmp(determinism, "1")) {</code>
<code>    return { 0, 0, true };</code>
<code>  }</code>
<code>  __swift_uint64_t seed0 = 0, seed1 = 0;</code>
<code>  swift::swift_stdlib_random(&amp;seed0, sizeof(seed0));</code>
<code>  swift::swift_stdlib_random(&amp;seed1, sizeof(seed1));</code>
<code>  return { seed0, seed1, false };</code>
<code>}</code>
</pre>
 <p>As shown in the previous code, if you require deterministic hash values for the purposes of unit testing, Swift allows you to disable random seeding by adding <code>SWIFT_DETERMINISTIC_HASHING</code> as an environment variable. Note that there's no guarantee that the values will be the same between different Swift releases, so ideally you should never use it.</p>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>SipHash will also hash an input multiple times before producing the final output, which is determined by the numbers in the name of the algorithm. In our case, Swift uses SipHash-1-3, which means that there's one round of hashing per message block, with three finalization rounds. This makes SipHash slightly slower than your average unsafe algorithm, which alongside its keyed hash properties allows SipHash to be considered a <b>safe</b> hashing algorithm.</p>
 <pre>
<code>extension Hasher._State {</code>
<code>  @inline(__always)</code>
<code>  internal mutating func compress(_ m: UInt64) {</code>
<code>    v3 ^= m</code>
<code>    _round()</code>
<code>    v0 ^= m</code>
<code>  }</code>
<code></code>
<code>  @inline(__always)</code>
<code>  internal mutating func finalize(tailAndByteCount: UInt64) -&gt; UInt64 {</code>
<code>    compress(tailAndByteCount)</code>
<code>    v2 ^= 0xff</code>
<code>    for _ in 0..&lt;3 {</code>
<code>      _round()</code>
<code>    }</code>
<code>    return _extract()</code>
<code>  }</code>
<code>}</code>
</pre>
 <p>Although SipHash's key-hashing feature is meant to be used as a network traffic authenticator, the improved defense against hash flooding makes it a very good hashing algorithm for hash tables, which is now being used by programming languages like Perl 5, Ruby, Rust and now Swift.</p>
 <h2>References and Good Reads</h2>
 <a href="https://github.com/apple/swift">The Swift Source Code</a>
 <br>
 <a href="https://131002.net/siphash/">SipHash</a>
 <br>
 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0206-hashable-enhancements.md">SE-0206 Hashable Enhancements</a>
 <br>
 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0185-synthesize-equatable-hashable.md">SE-0185 Synthesize Hashable</a>
 <br>
</div>]]></description>
</item>
<item>
    <title>Using Type Erasure to Build a Dependency Injecting Routing Framework in Swift</title>
    <link>https://swiftrocks.com/using-type-erasure-to-build-a-dependency-injector-in-swift</link>
    <guid>https://swiftrocks.com/using-type-erasure-to-build-a-dependency-injector-in-swift</guid>
    <pubDate>Thu, 2 Jan 2020 03:00:00 GMT-3</pubDate>
<description><![CDATA[
 
  
  <!--WRITEIT_POST_NAME=Using Type Erasure to Build a Dependency Injecting Routing Framework in Swift--> 
  <!--WRITEIT_POST_HTML_NAME=using-type-erasure-to-build-a-dependency-injector-in-swift--> 
  <!--WRITEIT_POST_SITEMAP_DATE_LAST_MOD=2020-04-12T14:00:00+02:00--> 
  <!--WRITEIT_POST_SITEMAP_DATE=2020-01-02T06:00:00+00:00--> 
  <!--Add here the additional properties that you want each page to possess.--> 
  <!--These properties can be used to change content in the template page or in the page itself as shown here.--> 
  <!--Properties must start with 'WRITEIT_POST'.--> 
  <!--Writeit provides and injects WRITEIT_POST_NAME and WRITEIT_POST_HTML_NAME by default.--> 
  <!--WRITEIT_POST_SHORT_DESCRIPTION=With Swift being a very type-safe and namespaced language, you'll find that certain tasks are really hard to complete if at some point you can't determine the types that are being handled‚Ää-‚Äämostly when generics are involved. Using an automatic dependency injector as an example, let's see how generic arguments and closures can be "erased" to trick the compiler into compiling code that it would otherwise claim to be impossible (when it's clearly not!). While this isn't your usual SwiftRocks-compiler-feature-deconstruction article, we'll take an exciting look at how the treatment of methods/closures as properties can be used in this context to bypass one of the Swift Compiler's most annoying compilation errors.--> 
  <title>Using Type Erasure to Build a Dependency Injecting Routing Framework in Swift</title>  
 

<div class="blog-post"> 
 <div class="post-title-index">  
  <h1>Using Type Erasure to Build a Dependency Injecting Routing Framework in Swift</h1>
 </div> 
 <div class="post-info"> 
  <div class="category category-theory">
   Theory
  </div> 
  <div class="category category-swift">
   Swift
  </div> 
  <div class="post-info-text">
   Published on 02 Jan 2020 
  </div> 
 </div>   
 <p>With Swift being a very type-safe and namespaced language, you'll find that certain tasks are really hard to complete if at some point you can't determine the types that are being handled‚Ää--‚Äämostly when generics are involved. Using an automatic dependency injector as an example, let's see how generic arguments and closures can be "erased" to trick the compiler into compiling code that it would otherwise claim to be impossible (when it's clearly not!).</p>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>While this isn't your usual SwiftRocks-compiler-feature-deconstruction article, we'll take an exciting look at how the treatment of methods/closures as properties can be used in this context to bypass one of the Swift Compiler's most annoying compilation errors.</p>
 <h2>For Context: What's Type Erasure?</h2>
 <p>In programming languages with support for generics, <b>Type Erasure</b> is the process of abstracting constrained, generic types inside an <b>unconstrained non-generic type</b> that can be passed around freely.</p>
 <p>If you don't know why that's necessary, consider that we have a <code>Shape</code> protocol and a few shapes:</p>
 <pre>
<code>protocol Shape {}</code>
<code></code>
<code>struct Circle: Shape {}</code>
<code>struct Triangle: Shape {}</code>
</pre>
 <p>Assuming that we're developing an image editor of some sort where the user can create shapes, we could store the user's latest created shapes like this:</p>
 <pre>
<code>var userShapes = [Shape]()</code>
<code>func userDidCreate(shape: Shape)</code>
<code>    userShapes.append(shape)</code>
<code>}</code>
</pre>
 <p>In Swift, this will work perfectly if there are no constraints on the <code>Shape</code> protocol, but what if it contained <code>Self</code> requirements -- like the presence of a method that checks if a shape is bigger than another shape of the same type?</p>
 <pre>
<code>protocol Shape {</code>
<code>    func isBigger(thanShape shape: Self) -&gt; Bool</code>
<code>}</code>
</pre>
 <p>If that was the case, our approach to storing shapes would fall apart as the compiler is now unable to represent <code>Shape</code> without knowing the underlying type:</p>
 <pre>
<code>var userShapes = [Shape]() // Can't do!</code>
<code>// Error: Protocol 'Shape' can only be used as a generic constraint</code>
<code>// because it has Self or associated type requirements</code>
</pre>
 <p>While that's great for type safety, that's a bummer for our little Shapes app. Even though the presence of the underlying type is necessary to access their inner methods, they shouldn't be necessary to store them.</p>
 <p>To fix this, we could store it as an <code>[Any]</code> array, but then we would be unable to cast it back to the original type, unless we tried all possibilities of Shapes. Yikes!</p>
 <pre>
<code>var userShapes = [Any]()</code>
<code>func userDidCreate&lt;T: Shape&gt;(shape: T) {</code>
<code>    userShapes.append(shape)</code>
<code>    // Works, but now we can't easily use the shapes.</code>
<code>}</code>
</pre>
 <p>The same problem surfaces if the protocol contained generic constraints or associated types.</p>
 <h3>Does the compiler really care about this?</h3>
 <p>There are multiple efficient ways to solve this problem, but before going into that, it's interesting to know why these errors exist -- is this really a problem for the compiler?</p>
 <p>The answer is not really -- these errors only exist inside your IDE as a means to prevent you from making silly code mistakes. Think of access control properties like <code>public</code> and <code>private</code>: They are good examples of concepts that have absolute no impact on the final binary -- in the end, everything is accessible from everywhere, but inside your IDE, the compiler forces access control conventions to be followed so at the very least you are able to write code that is used the way you intended it to be used.</p>
 <p>The issue here with generic constraints is similar -- the compiler <b>does</b> know what the underlying type of a <code>Shape</code> is in runtime, but because Swift is very type-safe, for safety reasons, if it can't be determined in compile time, it can't be done in the IDE. This is the complete opposite of Objective-C, where you could easily do whatever you wanted for the (very big) cost of compile-time safety.</p>
 <h3>Type Erasing with Closures</h3>
 <p>To bypass this problem, we can use the concept of Type Erasure. Instead of representing our stored shapes as <code>Any</code>, we abstract our constrained, boring <code>Shape</code> into an <code>AnyShape</code> type that has no constraints:</p>
 <pre>
<code>class AnyShape {</code>
<code>    let value: Any</code>
<code></code>
<code>    init&lt;T: Shape&gt;(_ shape: T) {</code>
<code>        self.value = shape</code>
<code>    }</code>
<code>}</code>
</pre>
 <p><i>Isn't this the same as defining the array as an <code>[Any]</code>?</i></p>
 <p>In this case, yes. But consider what would happen if we needed to call our <code>isBigger(_:)</code> method from the array of shapes: With type erasure, we can abuse the fact that our <code>init</code> method is <b>already constrained</b> to create <b>unconstrained abstracted versions of them, as closure properties!</b>:</p>
 <pre>
<code>class AnyShape {</code>
<code>    let value: Any</code>
<code>    let isBigger: (AnyShape) -&gt; Bool</code>
<code></code>
<code>    init&lt;T: Shape&gt;(_ shape: T) {</code>
<code>        self.value = shape</code>
<code>        self.isBigger = { any in</code>
<code>            return shape.isBigger(thanShape: any.value as! T)</code>
<code>        }</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>Even though the <code>Shape</code> protocol is still constrained, putting one inside a <code>AnyShape</code> class will allow you to freely move it around in contexts where knowing the underlying type is unnecessary.</p>
 <pre>
<code>var userShapes = [AnyShape]()</code>
<code>func userDidCreate&lt;T: Shape&gt;(shape: T)</code>
<code>    userShapes.append(AnyShape(shape))</code>
<code>}</code>
<code></code>
<code>func sortSimilarShapes(_ shapes: [AnyShape]) -&gt; [AnyShape] {</code>
<code>    return shapes.sorted { $0.isBigger($1) }</code>
<code>}</code>
</pre>
 <h3>Isn't doing this unsafe because of the force-unwrapping?</h3>
 <p>Because type erasure with closures often relies on force casting into the proper generic type, doing this is indeed unsafe. In fact, one of the ways to solve this problem would be to simply treat everything as <code>Any</code> instead of putting constraints into the protocol in the first place, but this would be a bad choice for clear reasons -- Swift's enforces type safety precisely so your code works properly and is predictable.</p>
 <p>Because type erasure relies on <code>Any</code>, you'll want to restrict its usage to places where the underlying type is predictable. Type erasures often only have the initializer exposed -- all usage is controlled internally to guarantee the force-unwraps will never fail. In the previous snippet for example, it would be assumed that the <code>AnyShapes</code> from <code>sortSimilarShapes</code> are all abstractions of the same type.</p>
 <h2>Using Type Erasure To Build a Dependency Injector</h2>
 <p>Using these concepts, let's see how we can build a <b>dependency injector that can automatically fetch a feature's initializer and instantiate it with the relevant arguments.</b></p>
 <p>To do so, we need an environment where this would be useful in first place. Dependency injectors are often used with routing mechanisms, allowing one <code>UIViewController</code> to push another one without having to explicitly instantiate and push it. In practice, this allows you to create apps where any screen can be pushed from anywhere without having to manually route dependencies forward or rely on singletons as the <code>UIViewController</code> still has a regular initializer -- but a dependency injector completely abstracts the process of calling it.</p>
 <p>Let's assume that we have the concept of a <code>Feature</code>: A protocol that contains an <code>associatedtype</code> that answers what are the dependencies of this <code>Feature</code> and a <code>build(_:)</code> method that receives such dependencies and generates the <code>UIViewController</code> related to this feature:</p>
 <pre>
<code>public protocol Feature {</code>
<code>    associatedtype Dependencies</code>
<code>    static func build(dependencies: Dependencies) -&gt; UIViewController</code>
<code>}</code>
</pre>
 <p>With this, let's create a hypothetical <b>FeatureOne</b> that depends on a hypothetical HTTPClient/Persistence module combo:</p>
 <pre>
<code>class HTTPClient { ... }</code>
<code>class Persistence { ... }</code>
<code></code>
<code>enum FeatureOne: Feature {</code>
<code>    struct Dependencies {</code>
<code>        let client: HTTPClient</code>
<code>        let persistence: Persistence</code>
<code>    }</code>
<code></code>
<code>    static func build(dependencies: FeatureOne.Dependencies) -&gt; UIViewController {</code>
<code>        return FeatureOneViewController(dependencies: dependencies)</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>In a regular iOS app architecture, assuming that we had a hold of instances of these dependencies, we could manually create and push this feature from the code:</p>
 <pre>
<code>func startFeatureOne() {</code>
<code>    let deps = FeatureOne.Dependencies(client: client, persistence: persistence)</code>
<code>    let feature = FeatureOne.build(dependencies: deps)</code>
<code>    navigationController?.pushViewController(feature, animated: true)</code>
<code>}</code>
</pre>
 <p>But <b>what if I want to start FeatureOne from somewhere that doesn't have access to these dependencies?</b> We could definitely use singletons, but our app would then take a massive hit in terms of testability. The ideal solution is to use this exact same structure, but abstract the process of initializing a feature's <code>UIViewController</code>.</p>
 <h3>Preparing the environment: Registering Dependencies</h3>
 <p>To abstract a <code>Feature's</code> initializer, we first need to be able to generate its dependencies. For this, we'll create a <code>Dependency</code> protocol:</p>
 <pre>
<code>protocol Dependency {}</code>
<code></code>
<code>extension HTTPClient: Dependency</code>
<code>extension Persistence: Dependency</code>
</pre>
 <p>In order to call a <code>Feature's</code> <code>Dependencies</code> struct's initializer, we need to have access to instances of these dependencies. Some dependency injectors allow you to determine how these instances are generated, but for simplicity, let's assume that we have one global instance that is reused for all features. A common way to store these global instances is through the use of a <code>Store</code> class that handles a dependency dictionary: since we're building a dependency injector for the purposes of managing our app's flow, let's assume that we have a <code>RouterService</code> class that is able to register <code>Dependencies</code> into a <code>Store</code>:</p>
 <pre>
<code>public final class RouterService: Dependency {</code>
<code></code>
<code>    var store = Store()</code>
<code></code>
<code>    public init() {</code>
<code>        register(dependency: self)</code>
<code>    }</code>
<code></code>
<code>    public func register(dependency: Dependency) {</code>
<code>        store.register(dependency)</code>
<code>    }</code>
<code></code>
<code>}</code>
<code></code>
<code>final class Store {</code>
<code></code>
<code>    var dependencies = [String: Any]()</code>
<code></code>
<code>    func get&lt;T&gt;(_ dependencyType: T.Type) -&gt; T {</code>
<code>        let name = String(describing: dependencyType)</code>
<code>        return dependencies[name] as! T</code>
<code>    }</code>
<code></code>
<code>    func register(_ dependency: Dependency) {</code>
<code>        let name = String(describing: type(of: dependency))</code>
<code>        dependencies[name] = dependency</code>
<code>    }</code>
<code>}</code>
</pre>
 <p><i>(Notice how the RouterService itself is also a dependency -- this is because this is the interface that ViewControllers will use to navigate the app.)</i></p>
 <p>In our AppDelegate, we can now register our dependencies and inject the service into our first screen (a fake splash, in this case):</p>
 <pre>
<code>@UIApplicationMain</code>
<code>class AppDelegate: UIResponder, UIApplicationDelegate {</code>
<code></code>
<code>    var window: UIWindow?</code>
<code>    let routerService = RouterService()</code>
<code></code>
<code>    func application(</code>
<code>        _ application: UIApplication,</code>
<code>        didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?</code>
<code>    ) -&gt; Bool {</code>
<code></code>
<code>        routerService.register(HTTPClient())</code>
<code>        routerService.register(Persistence())</code>
<code></code>
<code>        let splash = SplashViewController(routerService: routerService)</code>
<code></code>
<code>        self.window = UIWindow(frame: UIScreen.main.bounds)</code>
<code>        self.window?.rootViewController = splash</code>
<code>        self.window?.makeKeyAndVisible()</code>
<code></code>
<code>        return true</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>Now, how can we route from <code>SplashViewController</code> to <code>FeatureOne</code> without having direct access to its dependencies?</p>
 <h3>Type Erasing Initializers</h3>
 <p>Ideally, we want our <code>RouterService</code> to have a <code>navigate(_:)</code> method that can handle this only by having the desired <code>Feature</code>'s type:</p>
 <pre>
<code>func navigate&lt;T: Feature&gt;(</code>
<code>    toFeature: T.Type,</code>
<code>    fromView viewController: UIViewController</code>
<code>) {</code>
<code>    let deps = ??????????</code>
<code>    let viewController = T.build(dependencies: deps)</code>
<code>    viewController.navigationController?.pushViewController(viewController, animated: true)</code>
<code>}</code>
</pre>
 <p>While the last two lines are straight-forward, we have a massive problem: because we're dealing with an <code>associatedtype</code> inside a generic method, we simply don't know what that <code>Feature's</code> <code>Dependencies</code> struct is. If we don't know exactly what the dependencies are, because of the generic constraints, we won't be able to create an instance of it.</p>
 <p>However, from the beginning of the article, we've seen that <b>we can use type erasure to abstract constrained types into unconstrained ones -- even generic closures!</b> With this concept, we can abstract the Dependencies's constrained initializer into a closure that receives our <code>RouterService's</code> plain <code>Store</code> instead.</p>
 <p>Let's take another look at the initializer of <code>FeatureOne's</code> <code>Dependencies:</code> </p>
 <pre>
<code>struct Dependencies {</code>
<code>    let client: HTTPClient</code>
<code>    let persistence: Persistence</code>
<code>}</code>
</pre>
 <p>In Swift, <b>closures are types</b>, and <b>initializers/methods are closures.</b> This means that in practice, <code>FeatureOne.Dependencies(client:persistence:)</code> <b>can be stored and used as a</b> <code>(HTTPClient, Persistence) -&gt; FeatureOne.Dependencies</code> <b>closure</b>.</p>
 <pre>
<code>let initializer = FeatureOne.Dependencies.init</code>
<code>// (HTTPClient, Persistence) -&gt; FeatureOne.Dependencies</code>
</pre>
 <p>Which, in generic terms, can be treated as a <code>(T, U) -&gt; V</code> closure.</p>
 <p>To type erase this into something our <code>RouteService</code> understands, we can abstract this closure into an unconstrained <code>(Store) -&gt; Any</code> closure where the type erasure fetches the registered instances of <code>T</code> and <code>U</code> and uses them to create <code>V</code> (as <code>Any</code>). We can call this <code>AnyInitializer</code>:</p>
 <pre>
<code>public final class AnyInitializer {</code>
<code></code>
<code>    public let build: (Store) -&gt; Any</code>
<code></code>
<code>    public init&lt;T: Dependency, U: Dependency, V&gt;(_ function: @escaping (T, U) -&gt; V) {</code>
<code>        build = { store in</code>
<code>            let t: T = store.get(T.self)</code>
<code>            let u: U = store.get(U.self)</code>
<code>            return function(t, u)</code>
<code>        }</code>
<code>    }</code>
<code></code>
<code>}</code>
</pre>
 <p>Assuming that we have access to a <code>Store</code> that has the proper dependencies registered, we can now <b>generate instances</b> of any dependency initializer that fulfills the <code>(T, U) -&gt; V</code> constraint!</p>
 <pre>
<code>let erasedInit = AnyInitializer(FeatureOne.Dependencies.init)</code>
<code>let dependencies = erasedInit(routerService.store) as! FeatureOne.Dependencies</code>
</pre>
 <p>But what if it <b>doesn't</b> fulfill the constraint? For example, a feature with <b>three</b> dependencies would need an additional generic argument, and a feature with <b>no</b> dependencies would only need the generic argument that represents the final result.</p>
 <p><b>Unfortunately, Swift doesn't support variadic generics.</b> This means that <code>AnyInitializer</code> needs to support multiple initializers with varied sizes:</p>
 <pre>
<code>public final class AnyInitializer {</code>
<code></code>
<code>    public let build: (Store) -&gt; Any</code>
<code></code>
<code>    public init&lt;T&gt;(_ function: @escaping () -&gt; T) {</code>
<code>        build = { store in</code>
<code>            return function()</code>
<code>        }</code>
<code>    }</code>
<code></code>
<code>    public init&lt;T: Dependency, U&gt;(_ function: @escaping (T) -&gt; U) {</code>
<code>        build = { store in</code>
<code>            let t: T = store.get(T.self)</code>
<code>            return function(t)</code>
<code>        }</code>
<code>    }</code>
<code></code>
<code>    public init&lt;T: Dependency, U: Dependency, V&gt;(_ function: @escaping (T, U) -&gt; V) {</code>
<code>        build = { store in</code>
<code>            let t: T = store.get(T.self)</code>
<code>            let u: U = store.get(U.self)</code>
<code>            return function(t, u)</code>
<code>        }</code>
<code>    }</code>
<code></code>
<code>    public init&lt;T: Dependency, U: Dependency, V: Dependency, W&gt;(_ function: @escaping (T, U, V) -&gt; W) {</code>
<code>        build = { store in</code>
<code>            let t: T = store.get(T.self)</code>
<code>            let u: U = store.get(U.self)</code>
<code>            let v: V = store.get(V.self)</code>
<code>            return function(t, u, v)</code>
<code>        }</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>While this looks weird, <a href="https://twitter.com/rockbruno_/status/1194225536949792769">you may be interested to know that this is exactly how Apple handles SwiftUI's subviews.</a> Unfortunately, this is a problem with the Swift language itself.</p>
 <h3>Finishing Touches: Retrieving <code>AnyInitializer</code></h3>
 <p>To complete our <code>RouterService's</code> <code>navigate(_:)</code> method, we need to be able to retrieve a <code>Feature's</code> <code>Dependencies</code> <code>AnyInitializer</code>. We can do so by adding it to the <code>Feature</code> protocol:</p>
 <pre>
<code>public protocol Feature {</code>
<code>    associatedtype Dependencies</code>
<code>    static var dependenciesInitializer: AnyInitializer { get }</code>
<code>    static func build(dependencies: Dependencies) -&gt; UIViewController</code>
<code>}</code>
</pre>
 <p>To implement it, our <code>FeatureOne</code> simply needs to pass around its <code>Dependencies</code> initializer:</p>
 <pre>
<code>static var dependenciesInitializer: AnyInitializer {</code>
<code>    return AnyInitializer(Dependencies.init)</code>
<code>}</code>
</pre>
 <p>...which finally allows our <code>navigate(_:)</code> method to access it, passing its inner <code>Store</code> as an argument.</p>
 <pre>
<code>func navigate&lt;T: Feature&gt;(</code>
<code>    toFeature: T.Type,</code>
<code>    fromView viewController: UIViewController</code>
<code>) {</code>
<code>    let deps = T.dependenciesInitializer.build(store) as! T.Dependencies</code>
<code>    let viewController = T.build(dependencies: deps)</code>
<code>    viewController.navigationController?.pushViewController(viewController, animated: true)</code>
<code>}</code>
</pre>
 <p>With the <code>RouterService</code> added as one of the Feature's argument, the relevant <code>UIViewController</code> can now push any other <code>Feature</code> without needing to have direct access to their dependencies.</p>
 <pre>
<code>routerService.navigate(toFeature: AnotherFeature.self, fromView: self)</code>
</pre>
 <p>As a nice complement, because <code>AnyInitializer</code> is constrained to <code>Dependency</code> arguments, you are guaranteed to never have misconfigured features as the compiler would fail to build otherwise.</p>
 <h2>Conclusion: Where to go from here?</h2>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>The shown <code>RouterService</code> and its related components is a very simplified version of a navigation framework being tested at iFood. This can be evolved into a structure (which we use) that relies on Codable <code>Routes</code> and <code>RouteHandlers</code> instead of directly invoking features, allowing you to have a very smart deep link structure where your backend can dictate where the app's flow should go to.</p>
 <p>Type Erasures are a very nice way to temporarily tell the compiler to "stop" type-checking your code. This allows you to conceive all sorts of complex structures without giving up type safety -- as long as you are careful with where they are used.</p>
</div>]]></description>
</item>
<item>
    <title>Faster Array Operations With CollectionOfOne in Swift</title>
    <link>https://swiftrocks.com/faster-swift-array-operations-with-collectionofone</link>
    <guid>https://swiftrocks.com/faster-swift-array-operations-with-collectionofone</guid>
    <pubDate>Mon, 23 Dec 2019 03:00:00 GMT-3</pubDate>
<description><![CDATA[
 
  
  <!--WRITEIT_POST_NAME=Faster Array Operations With CollectionOfOne in Swift--> 
  <!--WRITEIT_POST_HTML_NAME=faster-swift-array-operations-with-collectionofone--> 
  <!--WRITEIT_POST_SITEMAP_DATE_LAST_MOD=2020-04-12T14:00:00+02:00--> 
  <!--WRITEIT_POST_SITEMAP_DATE=2019-12-23T06:00:00+00:00--> 
  <!--Add here the additional properties that you want each page to possess.--> 
  <!--These properties can be used to change content in the template page or in the page itself as shown here.--> 
  <!--Properties must start with 'WRITEIT_POST'.--> 
  <!--Writeit provides and injects WRITEIT_POST_NAME and WRITEIT_POST_HTML_NAME by default.--> 
  <!--WRITEIT_POST_SHORT_DESCRIPTION=CollectionOfOne is a type inside the Swift Standard Library that defines a <b>collection of a single element.</b> While this sounds a bit weird, there's a good reason for this to exist. Let's check out why.--> 
  <title>Faster Array Operations With CollectionOfOne in Swift</title>  
 

<div class="blog-post"> 
 <div class="post-title-index">  
  <h1>Faster Array Operations With CollectionOfOne in Swift</h1>
 </div> 
 <div class="post-info"> 
  <div class="category category-compiler">
   Compiler
  </div> 
  <div class="category category-swift">
   Swift
  </div> 
  <div class="post-info-text">
   Published on 23 Dec 2019 
  </div> 
 </div>  
 <p><code>CollectionOfOne</code> is a type inside the Swift Standard Library that defines a <b>collection of a single element.</b> While this sounds a bit weird, there's a good reason for this to exist. Let's check out why.</p>
 <h2>Operating on single elements</h2>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>Personally, I am guilty of creating single-element arrays to make simple operations like this:</p>
 <pre>
<code>someArray += [someElement]</code>
</pre>
 <p>I used to do things like this for readability reasons (as you may or may not agree that this looks better than an <code>append()</code> call in some cases), but it turns out <b>this is bad</b> for multiple reasons. Here's what happens internally when you do something like this:</p>
 <p>* The compiler translates the array literal into <code>Array's</code> <code>ExpressibleByArrayLiteral</code> initializer.</p>
 <p>* The array initializer will create a buffer to hold the single element.</p>
 <p>* The single element is copied into that buffer.</p>
 <p>* += is a wrapper for <code>appendContents(of:)</code>, which first increases the buffer's capacity based on the number of elements being added.</p>
 <p>* Finally, the elements are copied from their original buffer to the one of the array they're being added to.</p>
 <p>That's an enormous amount of stuff for something as simple as dealing with a single element! We're creating the entire stack for an array structure just for a simple <code>append()</code> when all we needed to do was get a hold of the single element and copy it into the original buffer.</p>
 <p>Usually, this sort of innocent mistake is optimized by the compiler, but in this case, even with higher optimization levels, the <b>compiler does not appear to know how to optimize the array allocation part out of single-element operations.</b> If we extract the SIL out of that line of code, we'll get multiple references for array allocations:</p>
 <pre>
<code>// function_ref _allocateUninitializedArray&lt;A&gt;(_:)</code>
</pre>
 <h2>CollectionOfOne - Collections, but not really</h2>
 <p>To treat cases like this where the operation relies on a collection but you're only dealing with one element, the <code>CollectionOfOne</code> type can be used to efficiently represent these elements without having to worry about anything else that would normally come from the <code>Collection</code> protocol.</p>
 <p>The way this works is straight-forward: the <code>CollectionOfOne</code> type implements <code>Collection</code>, meaning that it's able to respond to iterations and more. But instead of implementing these things with buffers like in an <code>Array</code>, the <code>CollectionOfOne</code> type simply holds a reference to the element:</p>
 <pre>
<code>@frozen // trivial-implementation</code>
<code>public struct CollectionOfOne&lt;Element&gt; {</code>
<code>  @usableFromInline // trivial-implementation</code>
<code>  internal var _element: Element</code>
<code></code>
<code>  /// Creates an instance containing just the given element.</code>
<code>  ///</code>
<code>  /// - Parameter element: The element to store in the collection.</code>
<code>  @inlinable // trivial-implementation</code>
<code>  public init(_ element: Element) {</code>
<code>    self._element = element</code>
<code>  }</code>
<code>}</code>
</pre>
 <p>Because it doesn't need to rely on buffers and all of that, it can directly return the element when being iterated:</p>
 <pre>
<code>public mutating func next() -&gt; Element? {</code>
<code>  let result = _elements</code>
<code>  _elements = nil</code>
<code>  return result</code>
<code>}</code>
</pre>
 <p>And because we're dealing with a single element, we don't need to worry about moving indexes or keeping track of element counts:</p>
 <pre>
<code>public var startIndex: Index {</code>
<code>  return 0</code>
<code>}</code>
<code></code>
<code>public var endIndex: Index {</code>
<code>  return 1</code>
<code>}</code>
<code></code>
<code>public func index(after i: Index) -&gt; Index {</code>
<code>  _precondition(i == startIndex)</code>
<code>  return 1</code>
<code>}</code>
<code></code>
<code>public func index(before i: Index) -&gt; Index {</code>
<code>  _precondition(i == endIndex)</code>
<code>  return 0</code>
<code>}</code>
<code></code>
<code>public var count: Int {</code>
<code>  return 1</code>
<code>}</code>
</pre>
 <p>This makes <code>CollectionOfOne</code> a very efficient way to represent a single element. If we modify the original example to use <code>CollectionOfOne</code>, we can give our app a small performance boost.</p>
 <pre>
<code>// Adding 10 million elements</code>
<code>someArray += [someElement]                // 8 seconds</code>
<code>someArray += CollectionOfOne(someElement) // 6.9 seconds</code>
</pre>
 <p><b>Note:</b> Adding to an array was used as the example because I believe it's the most common way of reaching this problem, but this is actually a bad use case of <code>CollectionOfOne</code>. In this case, the best performance you can get is by using <code>append()</code> directly as that'll ensure the element is directly copied into the array's buffer without any overhead.</p>
 <pre>
<code>someArray.append(someElement) // 4.9 seconds</code>
</pre>
 <p>The cases where using <code>CollectionOfOne</code> is the best approach possible is when you are forced to operate on <code>Collections</code>. In the Standard Library for example, <code>CollectionOfOne</code> is used to insert elements in specific positions of an <code>Array</code>:</p>
 <pre>
<code>public mutating func insert(_ newElement: __owned Element, at i: Int) {</code>
<code>  _checkIndex(i)</code>
<code>  self.replaceSubrange(i..&lt;i, with: CollectionOfOne(newElement))</code>
<code>}</code>
</pre>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>Because <code>replaceSubrange</code> replaces a <code>Collection</code> with another one, cases where the replacement is only a single element can greatly benefit from using <code>CollectionOfOne</code>.</p>
 <h2>Conclusion</h2>
 <p>When the performance gain isn't very high, I believe you should always value readability and maintainability over the gain. However, its always a good idea to understand the possible options and their trade-offs. Even if you never use <code>CollectionOfOne</code> directly, knowing of its existence and why it exists may help you make better decisions in the future.</p>
 <h2>References and Good Reads</h2>
 <a href="https://github.com/apple/swift/blob/master/stdlib/public/core/Array.swift">Array.swift</a>
 <br>
 <a href="https://github.com/apple/swift/blob/master/stdlib/public/core/CollectionOfOne.swift">CollectionOfOne.swift</a>
 <br>
 <a href="https://github.com/apple/swift">The Swift Source Code</a>
 <br>
</div>]]></description>
</item>
<item>
    <title>How OptionSet works inside the Swift Compiler</title>
    <link>https://swiftrocks.com/how-optionset-works-inside-the-swift-compiler</link>
    <guid>https://swiftrocks.com/how-optionset-works-inside-the-swift-compiler</guid>
    <pubDate>Tue, 3 Dec 2019 03:00:00 GMT-3</pubDate>
<description><![CDATA[
 
  
  <!--WRITEIT_POST_NAME=How OptionSet works inside the Swift Compiler--> 
  <!--WRITEIT_POST_HTML_NAME=how-optionset-works-inside-the-swift-compiler--> 
  <!--WRITEIT_POST_SITEMAP_DATE_LAST_MOD=2020-04-12T14:00:00+02:00--> 
  <!--WRITEIT_POST_SITEMAP_DATE=2019-12-03T06:00:00+00:00--> 
  <!--Add here the additional properties that you want each page to possess.--> 
  <!--These properties can be used to change content in the template page or in the page itself as shown here.--> 
  <!--Properties must start with 'WRITEIT_POST'.--> 
  <!--Writeit provides and injects WRITEIT_POST_NAME and WRITEIT_POST_HTML_NAME by default.--> 
  <!--WRITEIT_POST_SHORT_DESCRIPTION=Swift's OptionSet protocol is the bridged version of Objective-C's NS_OPTIONS enum -- a handy tool that allows you to very efficiently define a combination of "options" that can be used for a specific operation. Let's see what this protocol is, why OptionSets are preferred over a regular Set in some cases and finally what compiler magics it possesses.--> 
  <title>How OptionSet works inside the Swift Compiler</title>  
 

<div class="blog-post"> 
 <div class="post-title-index">  
  <h1>How OptionSet works inside the Swift Compiler</h1>
 </div> 
 <div class="post-info"> 
  <div class="category category-compiler">
   Compiler
  </div> 
  <div class="category category-swift">
   Swift
  </div> 
  <div class="post-info-text">
   Published on 03 Dec 2019 
  </div> 
 </div>  
 <p>Swift's <code>OptionSet</code> protocol is the bridged version of Objective-C's <code>NS_OPTIONS</code> enum -- a handy tool that allows you to very efficiently define a combination of "options" that can be used for a specific operation.</p>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>If for example we were developing a JSON serializer, it would be nice if we allowed the user to control how certain aspects of the serialization process happened, such as if the keys are sorted or if indentation should be applied to the final JSON. In fact, this is how <code>Foundation's</code> <code>JSONSerialization</code> works:</p>
 <pre>
<code>try JSONSerialization.data(withJSONObject: json, options: [.prettyPrinted, .sortedKeys])</code>
</pre>
 <p>From a "list" of options (the quotes will make sense later!), the <code>OptionSet</code> protocol contains a <code>contains(_:)</code> method to see if a specific option is inside the "list". Having several options passed together means that all these options should be considered, and passing no options can be done through an empty array.</p>
 <p>But despite the looks, the <code>options</code> parameter <b>is not an array</b> but a <code>WritingOptions</code> <b>struct</b> that conforms to the <code>OptionSet</code> protocol. How the hell does it behaves like a <code>Set</code> even though it is not?!</p>
 <p>If you've been following this blog, you'll know that the answer is a bunch of Swift compiler magic. Let's see what this protocol is, why <code>OptionSets</code> are preferred over a regular <code>Set</code> in this case, and finally what magic is done to provide the final behavior.</p>
 <h2>Context: Objective-C's <code>NS_OPTIONS</code></h2>
 <p>Before analyzing the Swift compiler code that allows a regular <code>struct</code> to behave like a <code>Set</code>, let's see where <code>OptionSet</code> came from.</p>
 <p>The Objective-C equivalent of <code>OptionSet</code> was the <code>NS_OPTIONS</code> macro, a glorified enum that allowed the same option-mixing gimmick. With it, you can define your options just like an integer enum, like these hypothetical options for browsing SwiftRocks articles:</p>
 <pre>
<code>typedef NS_OPTIONS(NSUInteger, SwiftRocksOptions) {</code>
<code>    DarkMode     = 1 &lt;&lt; 0,</code>
<code>    NoJavaScript = 1 &lt;&lt; 1,</code>
<code>    NoImages     = 1 &lt;&lt; 2,</code>
<code>};</code>
</pre>
 <p>However, instead of using sequential numbers like 0, 1 and 2 in a regular enum, the idea is that you would use <b>powers of two</b> (easier represented by the number one 1 left-shifted (&lt;&lt;) by some value.):</p>
 <p>If the usage of powers of two sounds confusing, consider how a three-bit number <b>0</b> looks like in binary:</p>
 <pre>
<code>0 0 0</code>
</pre>
 <p>In contrast, this is how a three-bit number <b>7</b> looks like in binary:</p>
 <pre>
<code>1 1 1</code>
</pre>
 <p>Since we have four bits and each of these bits can be zeroes or ones, what if we treated each bit as an option?</p>
 <p>The first bit (from the right) could be the first option (DarkMode), the second bit the second option (NoJavaScript), and the third bit the third option (NoImage). if a bit is set to <b>one</b>, it means that option is "selected". This means that we could represent the selection of DarkMode as the number <b>1</b> (0 0 1), the selection of NoJavaScript as the number <b>2</b> (0 1 0), the selection of NoImage as the number <b>4</b> (1 0 0), and a potential combination of NoJavascript and NoImages as the number <b>6</b> (1 1 0).</p>
 <p>The process of creating such numbers is generally referred to as <b>bitmasking</b> and is a very efficient way to treat the existence/combination of arbitrary values. While using a regular Array or Set would require us to store the actual elements in memory, the bitmasked requires just the memory space of the integer itself used to process the mask.</p>
 <p>Adding and checking options in a mask is done through bitwise operators. The bitwise OR operator (|) returns a number that has a specific bit set to one if any of the numbers in the operation do so, so since we're using powers of two, using it on two options return a number that represents their combination:</p>
 <pre>
<code>NSUInteger options = SwiftRocksOptionsNoJavaScript | SwiftRocksOptionsNoImages</code>
<code>// 1 1 0 (6)</code>
</pre>
 <p>On the other hand, the bitwise AND (&amp;) operator returns a number that has a specific bit set to one only if <b>both</b> numbers in the operation do so. If we use it with the set of options along with the specific option that we're checking, because we're using powers of two, we'll get a value different from zero if the option exists in the set (or zero if it doesn't):</p>
 <pre>
<code>(options &amp; SwiftRocksOptionsDarkMode)     != 0 // false</code>
<code>(options &amp; SwiftRocksOptionsNoJavaScript) != 0 // true</code>
<code>(options &amp; SwiftRocksOptionsNoImages)     != 0 // true</code>
</pre>
 <p>Option bitmasking is a very clever use of the binary representation of a number. While unrelated to the article, I like to mention that doing option bitmasks like this is also used as the (current) most efficient solution to the famous Traveling Salesman problem.</p>
 <h2>How <code>NS_OPTIONS</code> is bridged to <code>OptionSet</code></h2>
 <p>In Swift, you don't have to create enums and manually generate these masks. The <code>OptionSet</code> protocol abstracts the process of creating such bitmasks. Hooray!</p>
 <p>But what about things that come from Objective-C? If the Clang importer section of the compiler detects a <code>NS_OPTIONS</code> macro, it will convert it to a <code>struct</code> that inherits from <code>OptionSet</code>. <code>OptionSet</code> itself inherits from <code>RawRepresentable</code>, so the enum elements are converted into <code>static let</code> properties that take a <code>rawValue</code>. Here's an example of a converted <code>JSONSerialization.WritingOptions</code>:</p>
 <pre>
<code>public struct WritingOptions: OptionSet {</code>
<code></code>
<code>    public typealias RawValue = Int</code>
<code></code>
<code>    public let rawValue: RawValue</code>
<code></code>
<code>    public init(rawValue: RawValue) {</code>
<code>        self.rawValue = rawValue</code>
<code>    }</code>
<code></code>
<code>    public static let prettyPrinted = WritingOptions(rawValue: 1 &lt;&lt; 0)</code>
<code>    public static let sortedKeys = WritingOptions(rawValue: 1 &lt;&lt; 1)</code>
<code>    public static let fragmentsAllowed = WritingOptions(rawValue: 1 &lt;&lt; 2)</code>
<code>    public static let withoutEscapingSlashes = WritingOptions(rawValue: 1 &lt;&lt; 3)</code>
<code>}</code>
</pre>
 <h2>How OptionSet is defined in the Standard Library</h2>
 <p>Although the <code>OptionSet</code> is used with integers and bitmasking, it can, in theory, be used with anything else as the protocol is just a <code>rawValue</code> and some algebra methods:</p>
 <pre>
<code>public protocol OptionSet: RawRepresentable, SetAlgebra {</code>
<code>    associatedtype Element = Self // from SetAlgebra</code>
<code></code>
<code>    init(rawValue: Self.RawValue)</code>
<code></code>
<code>    public func union(_ other: Self) -&gt; Self</code>
<code>    public func intersection(_ other: Self) -&gt; Self</code>
<code>    public func symmetricDifference(_ other: Self) -&gt; Self</code>
<code>    public func contains(_ member: Self) -&gt; Bool</code>
<code>    public mutating func insert(_ newMember: Self.Element) -&gt; (Bool, Self.Element)</code>
<code>    public mutating func remove(_ member: Self.Element) -&gt; Self.Element?</code>
<code>    public mutating func update(with newMember: Self.Element) -&gt; Self.Element?</code>
</pre>
 <p>However, implementing these methods isn't required -- if the <code>rawValue</code> type is a number that isn't a floating-point, you'll get default implementations in the form of the bitmasking techniques seen before!</p>
 <pre>
<code>public mutating func formUnion(_ other: Self) {</code>
<code>    self = Self(rawValue: self.rawValue | other.rawValue)</code>
<code>}</code>
<code></code>
<code>public mutating func formIntersection(_ other: Self) {</code>
<code>    self = Self(rawValue: self.rawValue &amp; other.rawValue)</code>
<code>}</code>
</pre>
 <h2>OptionSet Syntax Sugars</h2>
 <p>We've seen how to work with <code>OptionSet</code> through its methods, but where does this behavior come from?</p>
 <pre>
<code>options: [.prettyPrinted, .sortedKeys]</code>
</pre>
 <p>Even though the options argument is the struct itself, we're sending an array of them to the type -- and it works.</p>
 <p>Interestingly enough this syntax sugar has nothing to do with <code>OptionSet</code> itself. IT comes from an inner protocol of which it inherits from: <code>SetAlgebra</code>.</p>
 <p>The <code>SetAlgebra</code> protocol is the backbone for mathematical set operations in the Standard Library and is used by types like <code>Set</code> and <code>OptionSet</code>:</p>
 <pre>
<code>public protocol SetAlgebra: Equatable {</code>
<code>    associatedtype Element</code>
<code></code>
<code>    public func union(_ other: Self) -&gt; Self</code>
<code>    public func intersection(_ other: Self) -&gt; Self</code>
<code>    public func symmetricDifference(_ other: Self) -&gt; Self</code>
<code>    public func contains(_ member: Self) -&gt; Bool</code>
<code>    ...</code>
</pre>
 <p>(This looks very similar to <code>OptionSet</code> itself, and is because <code>OptionSet</code> can be seen as just a light abstraction of <code>SetAlgebra</code> that provides the bitmasking features through a rawValue.)</p>
 <p>The magic comes from this little extension:</p>
 <pre>
<code>extension SetAlgebra: ExpressibleByArrayLiteral {</code>
<code>    public init(arrayLiteral: Element...) {</code>
<code>        self.init(arrayLiteral)</code>
<code>    }</code>
<code></code>
<code>    public init&lt;S: Sequence&gt;(_ sequence: S) where S.Element == Element {</code>
<code>        self.init()</code>
<code>        for e in sequence { insert(e) }</code>
<code>    }</code>
<code>}</code>
</pre>
 <p><code>SetAlgebra</code> inherits from <code>ExpressibleByArrayLiteral</code>, which allow it to be represented directly as an array. This triggers an <code>insert()</code> call for every element, which for our <code>OptionSet</code> types means that we'll progressively trigger bitwise AND (|) operations, resulting in a final <code>OptionSet</code> that represents the combination of all the options. Hooray!</p>
 <h2>How <code>ExpressibleByArrayLiteral</code> works internally</h2>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p><a href="https://swiftrocks.com/swift-expressibleby-protocols-how-they-work-internally-in-the-compiler">The innards of the ExpressibleBy family are covered in detail in my previous article,</a> but as a short explanation, we can say that when the type checker finds a literal being attributed to an explicit type, it checks if it conforms to the related <code>ExpressibleBy</code> protocol and coverts the expression to the designated initializer from the protocol if it does (and throws a compilation error if it does not). For more details, check the linked article.</p>
 <h2>Conclusion</h2>
 <p>The <code>OptionSet</code> protocol itself is hardly used nowadays, but its existence has some history and shows some of the importance of analyzing what you're developing in terms of performance. You can always use a regular <b>Array</b> or <b>Set</b> to define these options, but should you? For these case where you have a limited set of unique options, using a bitmask is considerably quicker and less resource-intensive, something which your user's device will be very grateful for :)</p>
 <h2>References and Good reads</h2>
 <a href="https://github.com/apple/swift">The Swift Source Code</a>
 <br>
</div>]]></description>
</item>
<item>
    <title>NSCopying uses in Swift</title>
    <link>https://swiftrocks.com/nscopying-nszone-uses-in-swift</link>
    <guid>https://swiftrocks.com/nscopying-nszone-uses-in-swift</guid>
    <pubDate>Tue, 5 Nov 2019 03:00:00 GMT-3</pubDate>
<description><![CDATA[
 
  
  <!--WRITEIT_POST_NAME=NSCopying uses in Swift--> 
  <!--WRITEIT_POST_HTML_NAME=nscopying-nszone-uses-in-swift--> 
  <!--WRITEIT_POST_SITEMAP_DATE_LAST_MOD=2020-04-12T14:00:00+02:00--> 
  <!--WRITEIT_POST_SITEMAP_DATE=2019-11-05T06:00:00+00:00--> 
  <!--Add here the additional properties that you want each page to possess.--> 
  <!--These properties can be used to change content in the template page or in the page itself as shown here.--> 
  <!--Properties must start with 'WRITEIT_POST'.--> 
  <!--Writeit provides and injects WRITEIT_POST_NAME and WRITEIT_POST_HTML_NAME by default.--> 
  <!--WRITEIT_POST_SHORT_DESCRIPTION=Even in apps written in full Swift, interfacing with Objective-C is still a very big part of iOS development. Many types and semantics from Objective-C are hidden underneath the code we write today, and understanding where they come from can help you make better code decisions and just better understand the platform in general. This time, we'll take a look at what NSCopying and its companion class NSZone are and what they can do for Swift apps.--> 
  <title>NSCopying uses in Swift</title> 
 

<div class="blog-post"> 
 <div class="post-title-index">  
  <h1>NSCopying uses in Swift</h1>
 </div> 
 <div class="post-info"> 
  <div class="category category-ios">
   iOS
  </div> 
  <div class="category category-swift">
   Swift
  </div> 
  <div class="post-info-text">
   Published on 05 Nov 2019 
  </div> 
 </div>  
 <p>Even in apps written in full Swift, interfacing with Objective-C is still a very big part of iOS development. Many types and semantics from Objective-C are hidden underneath the code we write today, and understanding where they come from can help you make better code decisions and just better understand the platform in general. This time, we'll take a look at what <code>NSCopying</code> and its companion class <code>NSZone</code> are and what they can do for Swift apps.</p>
 <h2>Context: How copying objects worked in Objective-C</h2>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>Objective-C is notable for its weird syntax and for being completely dynamic, but the superset of C was very clever in the way its problems were solved. I mentioned in previous articles that one of my favorite things in Swift is that many compiler features are tied to actual protocols inside the language, and this is the case for Objective-C as well.</p>
 <p>In Objective-C, everything was an <b>object.</b> To support the language's dynamic features, objects provided type information to the run time by subclassing <code>NSObject</code>. Subclassing it also provided multiple helper methods like equality methods like <code>isEqual</code>, message routing methods like <code>respondsToSelector</code>, memory management methods like <code>retain/release</code> and type helper methods like <code>isKindOfClass</code>. <code>NSObject</code> is still used to this day in Swift -- many old iOS delegate protocols require the receiver to be an object as they need to check which methods the object can respond to.</p>
 <p>An important aspect of the language was that in Objective-C, <b>every object is a reference type</b>. Because the language is insanely dynamic, there's no way to know if the object you're creating in compile time is actually going to look like that in runtime. Everything can be changed in runtime, and because of that, allocating objects on the stack was simply not possible. Everything has to work through shared pointers and dynamic heap allocations, similar to how <code>classes</code> behave in Swift.</p>
 <pre>
<code>NSString blogName;</code>
<code>// Compiler error: Interface type cannot be statically allocated</code>
</pre>
 <pre>
<code>NSMutableString *blogNameBuilder = [[NSMutableString alloc] initWithString:@"Swift"];</code>
<code>NSString* blogName = blogNameBuilder;</code>
<code>[blogNameBuilder appendString:@"Rocks"];</code>
<code>NSLog(@"%@", blogNameBuilder); // SwiftRocks</code>
<code>NSLog(@"%@", blogName); // SwiftRocks</code>
</pre>
 <p>Because working with references is not always a good idea, languages have means to differentiate between reference semantics and value semantics, and the common way of achieving <b>value semantics</b> in Swift is to use a <code>struct</code>. Because Objective-C doesn't have those for objects, its is very different -- instead of having a clear distinction of reference types versus value types like in Swift, Objective-C allowed reference types to <b>opt-in</b> to value semantics through the <code>copy</code> property accessor:</p>
 <pre>
<code>@property (copy, nonatomic) NSString* blogName;</code>
<code></code>
<code>---</code>
<code></code>
<code>_blogName = @""; // Initialize the ivar</code>
<code>NSMutableString *blogNameBuilder = [[NSMutableString alloc] initWithString:@"Swift"];</code>
<code>self.blogName = blogNameBuilder;</code>
<code>[blogNameBuilder appendString:@"Rocks"];</code>
<code>NSLog(@"%@", blogNameBuilder); // SwiftRocks</code>
<code>NSLog(@"%@", self.blogName); // Swift</code>
</pre>
 <p>With <code>copy</code> as one of the property's accessors, attributing a value to the property's generated setter will instead attribute a copy-on-write copy of the original value instead of the regular pointer. <code>copy</code> in Objective-C works by changing the synthesized setter of the property -- instead of simply assigning the new value to the <i>ivar</i>, the synthesized setter calls a <code>copy()</code> method on the value:</p>
 <pre>
<code>// Created by the runtime:</code>
<code>- (void)setBlogName:(NSString *)blogName {</code>
<code>    _blogName = [blogName copy];</code>
<code>}</code>
</pre>
 <p>Calling <code>copy()</code> returns a new instance of the type, completely separated from the original one. But where does this method comes from?</p>
 <h2><code>NSCopying</code></h2>
 <p>The <code>copy()</code> method comes from <code>NSCopying</code> -- a protocol built to do exactly what it implies: giving objects the ability to generate copies of themselves. Instead of tying the accessor to an internal compiler feature, The <code>copy</code> accessor works through <code>NSCopying</code> so value semantics on properties can also be applied to your own custom types as well. As expected, the <code>copy</code> accessor in Objective-C only works with types that inherit from <code>NSCopying</code>, and its usage in setters is simply a syntax sugar to calling the protocol manually.</p>
 <p><code>copy()</code> is the only method defined by <code>NSCopying</code>, and implementing it is simply a matter of returning a new instance of your type. Let's use a <code>Box</code> pattern as an example: In Swift, a common way to bring reference semantics to a value type is to "box" a value inside a <code>class</code>:</p>
 <pre>
<code>class Box&lt;T&gt; {</code>
<code>    let element: T</code>
<code></code>
<code>    init(element: T) {</code>
<code>        self.element = element</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>This allows us to create references to an arbitrary <code>T</code> type, but what if for some reason we wanted to make a copy of this entire box, including the underneath value?</p>
 <p>One way to achieve this would be to simply create a new instance:</p>
 <pre>
<code>func copyBox() -&gt; Box&lt;T&gt; {</code>
<code>    let newElement = element</code>
<code>    let newBox = Box(element: newElement)</code>
<code>    return newBox</code>
<code>}</code>
</pre>
 <p>This approach, however, was a small issue: Although we are indeed creating a new instance of the box, we don't really know if the underneath <code>element</code> is going to be copied appropriately. If the <code>T</code> type requires doing additional actions to actually copy its contents, the <code>newElement</code> property would still be partially referencing the original <code>element</code> one.</p>
 <p>One way to fix this would be to make <code>T</code> inherit from some "copying" protocol, giving us the ability to be sure that we're handling a new copy of the element. Luckily we don't need to, because that's exactly what <code>NSCopying</code> is for!</p>
 <pre>
<code>class Box&lt;T: NSCopying&gt;: NSCopying {</code>
<code>    let element: T</code>
<code></code>
<code>    init(element: T) {</code>
<code>        self.element = element</code>
<code>    }</code>
<code></code>
<code>    func copy(with zone: NSZone? = nil) -&gt; Any {</code>
<code>        guard let newElement = element.copy() as? T else {</code>
<code>            fatalError("Couldn't copy element")</code>
<code>        }</code>
<code>        let newBox = Box(element: newElement)</code>
<code>        return newBox</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>By calling <code>copy()</code> on our box which internally calls <code>copy()</code> on the element as well, we're now sure that we're handling a reference to a unique copy.</p>
 <pre>
<code>var nsString = NSMutableString(string: "Swift")</code>
<code></code>
<code>let stringBox: Box&lt;NSString&gt; = Box(element: nsString)</code>
<code>let stringBoxCopy = stringBox.copy() as! Box&lt;NSString&gt;</code>
<code></code>
<code>// Getting memory addresses</code>
<code>print(Unmanaged.passUnretained(stringBox).toOpaque()) // 0x0000600003620da0</code>
<code>print(Unmanaged.passUnretained(stringBoxCopy).toOpaque()) // 0x0000600003620e20</code>
<code></code>
<code>nsString.append("Rocks")</code>
<code>// Checking if the inner string was copied as well</code>
<code>print(stringBox.element) // SwiftRocks</code>
<code>print(stringBoxCopy.element) // Swift</code>
</pre>
 <p>(I used <code>NSString</code> in this case because it inherits from <code>NSCopying</code> and is easy to use for tests like this.)</p>
 <p><code>NSCopying</code> can be used in Swift as a generic way to create copies of classes (reference types), and as a bonus, making a Swift type inherit from <code>NSCopying</code> will also allow it to make use of the <code>copy</code> property accessor in Objective-C bridges.</p>
 <pre>
<code>@property (copy, nonatomic) MyBridgedNSCopyingSwiftClass* foo;</code>
</pre>
 <h2>What the hell is the <code>NSZone</code> argument?</h2>
 <p>You might have noticed that <code>copy()</code> takes a <code>NSZone</code> argument that is ignored -- what is that and why is it ignored?</p>
 <p>If you're looking for a short answer, you'll be happy to know that <code>NSZone</code> <b>is deprecated and you can completely ignore it.</b> For a bit of iOS history, keep on reading this section.</p>
 <p>A common problem with heap allocation algorithms is <b>memory fragmentation.</b> We need to scan the heap to find a place to allocate an object, but if we're not careful about <b>where</b> we place it, deallocating objects can end up dividing our available memory into very small pieces of memory that are unusable by larger objects.</p>
 <p>To visualize this, let's assume that we have a 16 bits block of free memory:</p>
 <pre>
<code>|                |</code>
</pre>
 <p>Now, let's allocate a 4 bit object called 1, an 8 bit object called 2, and another 4 bit object called 3 to fill our memory:</p>
 <pre>
<code>|1111222222223333|</code>
</pre>
 <p>Now, let's deallocate objects 1 and 3, but <b>not</b> 2:</p>
 <pre>
<code>|    22222222    |</code>
</pre>
 <p>We now have 8 bits of free memory, but if you actually try to allocate an object that has 8 bits of size at this point, you'll not be able to! Even though we do have this space available, this space is <b>fragmented</b> into two blocks of 4 bits that can't be used by larger objects unless we deallocate or move object 2.</p>
 <p>The solution to mitigate this at the time was to create <b>zones</b> of memory. Instead of putting everything into one big memory space, an algorithm that allocated/deallocated a lot of memory could create a separate allocation zone to prevent the rest of the physical memory from being fragmented. In this case, the algorithm that creates the large 8 bit object could create a separate 8 bit zone:</p>
 <pre>
<code>Main: |11113333| Zone: |22222222|</code>
</pre>
 <p>After deallocating objects 1 and 3, we'll now have the 8 bits of memory unfragmented and ready to be used by an object of equal size.</p>
 <pre>
<code>Main: |        | Zone: |22222222|</code>
</pre>
 <p>This is exactly what <code>NSZone</code> does. Foundation provided a default object pointing to the "main" zone, but custom ones would be created with custom sizes and granularities.</p>
 <pre>
<code>NSZone* defaultZone = NSDefaultMallocZone();</code>
<code>NSZone* customZone = NSCreateZone(8, 0, YES);</code>
</pre>
 <p>However, as mentioned before, the usage of <code>NSZone</code> was deprecated long ago. The Objective-C runtimes ignores them completely, and Swift doesn't even let you reference them:</p>
 <pre>
<code>let zone = NSDefaultMallocZone()</code>
<code>// 'NSDefaultMallocZone' is unavailable in Swift: Zone-based memory management is unavailable</code>
</pre>
 <p>The reason is that the creation of ARC rendered it unnecessary as its memory management algorithms were smart enough to prevent fragmentation. Also, fragmentation wasn't much of an issue in iOS anyway -- allocating in virtual memory is much more flexible than in physical memory, and iPhones have enough physical memory to make this a rare occurrence.</p>
 <h2>NSMutableCopying</h2>
 <p>For completion purposes, it's important to also mention that Foundation also has a <code>NSMutableCopying</code> protocol that defines a similar <code>mutableCopy()</code> method. The functionality is the exact same as <code>NSCopying</code> -- the difference comes from the fact that it was common in Objective-C to differentiate between immutable and mutable objects. For example, as strings in Objective-C could be defined both as the immutable <code>NSString</code> and the mutable <code>NSMutableString</code>, the <code>NSMutableCopying</code> allowed developers to explicitly create mutable copies of objects. Since <code>let</code> and <code>var</code> accessors made this pattern unnecessary in Swift, <code>NSMutableCopying</code> doesn't have good uses in Swift unless you explicitly create separate mutable versions of your types.</p>
 <h2>Conclusion</h2>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>Many features of iOS rely on legacy Objective-C components. As always, knowing the history of why things work the way they do can allow you to make better choices on the platform. In this case, <code>NSCopying</code> is an important aspect of Objective-C and can still be used not only for Swift-specific uses but also to unlock copy semantics in properties bridged to Objective-C.</p>
 <p>If you want to see more Swift and iOS information like this, follow me on my Twitter (<a href="https://twitter.com/rockbruno_">@rockbruno_</a>), and let me know of any feedback, suggestions and corrections you want to share.</p>
</div>]]></description>
</item>
<item>
    <title>Swift's Sequence Inside The Compiler: How for loops work internally</title>
    <link>https://swiftrocks.com/swift-sequence-inside-the-compiler-how-for-loops-work</link>
    <guid>https://swiftrocks.com/swift-sequence-inside-the-compiler-how-for-loops-work</guid>
    <pubDate>Fri, 25 Oct 2019 14:50:00 GMT-3</pubDate>
<description><![CDATA[
 
  
  <!--WRITEIT_POST_NAME=Swift's Sequence Inside The Compiler: How for loops work internally--> 
  <!--WRITEIT_POST_HTML_NAME=swift-sequence-inside-the-compiler-how-for-loops-work--> 
  <!--WRITEIT_POST_SITEMAP_DATE_LAST_MOD=2020-04-12T14:00:00+02:00--> 
  <!--WRITEIT_POST_SITEMAP_DATE=2019-10-25T17:50:00+00:00--> 
  <!--Add here the additional properties that you want each page to possess.--> 
  <!--These properties can be used to change content in the template page or in the page itself as shown here.--> 
  <!--Properties must start with 'WRITEIT_POST'.--> 
  <!--Writeit provides and injects WRITEIT_POST_NAME and WRITEIT_POST_HTML_NAME by default.--> 
  <!--WRITEIT_POST_SHORT_DESCRIPTION=In this article, I'll cover one of my favorite syntax sugars in the language: the protocols and the internal compiler behavior that allow you to write for loops. You might have heard already of the Sequence family of protocols, and here, we'll see how the compiler uses them as the building blocks for for loops.--> 
  <title>Swift's Sequence Inside The Compiler: How for loops work internally</title>  
 

<div class="blog-post"> 
 <div class="post-title-index">  
  <h1>Swift's Sequence Inside The Compiler: How <code>for</code> loops work internally</h1>
 </div> 
 <div class="post-info"> 
  <div class="category category-compiler">
   Compiler
  </div> 
  <div class="category category-swift">
   Swift
  </div> 
  <div class="post-info-text">
   Published on 26 Oct 2019 
  </div> 
 </div>   
 <p>One of my favorite things about Swift is that almost every compiler feature is built on top of actual classes and protocols of the language. This means that if you see a native type that has some special magical property (like SwiftUI's declarative syntax, which was covered in another post here in SwiftRocks), it's likely that you can reproduce that behavior in your custom types.</p>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>In this article, I'll cover one of my favorite syntax sugars in the language: the protocols and the internal compiler behavior that allow you to write <code>for</code> loops. You might have heard already of the <code>Sequence</code> family of protocols, and here, we'll see how the compiler uses them as the building blocks for <code>for</code> loops.</p>
 <pre>
<code>for i in 0..&lt;10 {</code>
<code>    print("Wait, this is not a hardcoded language thing?")</code>
<code>}</code>
</pre>
 <p>In most languages, the ability to iterate simple data types like integers in <code>for</code> statements is often hardcoded into the compiler. This was no different in the first few versions of Swift where the standard was to use old C-style loops:</p>
 <pre>
<code>// Swift 1.2</code>
<code>for var i = 0; i &lt; 10; i++ {</code>
<code>    print(i)</code>
<code>}</code>
</pre>
 <p><code>for in</code> style loops came along with the <code>Range</code> type, and the release of Swift 3 officially removed the old C-style loops from the language and forced everyone to use the <code>for in</code> loops that we are all used to. Now, <code>for</code> loops in Swift are based on <b>actual protocols</b> that you can inherit to add <code>for in</code> capabilities to <b>anything</b> you create that can be represented as such. As expected, this means that the ability to use ranges as the parameter of a loop isn't because ranges are treated differently in the compiler -- but because ranges conform to specific public protocols.</p>
 <h2>IteratorProtocol</h2>
 <p>The base of how iteration in general works in Swift is the <code>IteratorProtocol</code> type -- a very simple protocol that only takes two components: An <code>associatedtype</code> that represents what's being iterated, and a <code>next</code> property that returns the "next" element on the iteration (or nil if it's over).</p>
 <p>A basic example of something that can be implemented as an <code>IteratorProtocol</code> is a countdown timer that keeps reducing a value until it reaches zero:</p>
 <pre>
<code>struct CountdownIterator: IteratorProtocol {</code>
<code>    typealias Element = Int</code>
<code></code>
<code>    var count: Int</code>
<code></code>
<code>    mutating func next() -&gt; Int? {</code>
<code>        if count == 0 {</code>
<code>            return nil</code>
<code>        } else {</code>
<code>            self.count -= 1</code>
<code>            return count</code>
<code>        }</code>
<code>    }</code>
<code></code>
<code>    init(count: Int) {</code>
<code>        self.count = count</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>If we access this iterator continuously we'll get diminishing values until the iteration ends, represented by nil:</p>
 <pre>
<code>var iterator = CountdownIterator(count: 3)</code>
<code>iterator.next() // 2</code>
<code>iterator.next() // 1</code>
<code>iterator.next() // 0</code>
<code>iterator.next() // nil</code>
<code>iterator.next() // nil</code>
</pre>
 <p>Iterators are said to be <b>destructive</b> because you can't access a specific value more than once -- you need to go from the beginning to the end in a linear fashion and you can only do it. If you need to access a value again, you need to create another iterator and repeat the process.</p>
 <h2>Sequence</h2>
 <p>In terms of iteration, the <code>Sequence</code> protocol is what we interact with the most. In short, a <code>Sequence</code> is simply a more high level abstraction of a <code>IteratorProtocol</code> type that provides additional functionality on top of the regular iteration process. While Swift allows you to create <code>Sequences</code> that are also <code>IteratorProtocols</code>, the existence of this protocol allows you to separate the definition of the type itself from the logic that handles its iteration. To use it, all you have to do is create a <code>makeIterator()</code> type that returns an <code>IteratorProtocol</code>:</p>
 <pre>
<code>struct Countdown: Sequence {</code>
<code>    typealias Iterator = CountdownIterator</code>
<code></code>
<code>    let count: Int</code>
<code></code>
<code>    init(count: Int) {</code>
<code>        self.count = count</code>
<code>    }</code>
<code></code>
<code>    func makeIterator() -&gt; CountdownIterator {</code>
<code>        return CountdownIterator(count: count)</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>The implementation requirements of the <code>Sequence</code> protocol might make it look useless, but don't judge a book by its cover -- it actually contains tons of required methods, but they are all implemented for you in the standard library. <code>Sequence</code> contains pre-definitions for <b>lots</b> of the commonly used sequence-based algorithms, including <code>map</code>, <code>filter</code> and <code>reduce</code>!</p>
 <p>Even though <code>IteratorProtocol</code> is the type that defines how the iteration happens, <code>Sequence</code> is the type that provides the additional properties and methods that make these iterations useful in the first place:</p>
 <pre>
<code>let countdown = Countdown(count: 3)</code>
<code>countdown.map { $0 * $0 }</code>
<code>countdown.allSatisfy { $0.isMultiple(of: 2) }</code>
<code>countdown.max()</code>
<code>countdown.sorted()</code>
<code>countdown.forEach { print($0) }</code>
</pre>
 <p>Just like in <code>IteratorProtocol</code>, we can create an iterator and linearly retrieve values from it. This is how all these properties and methods work -- for example, this is how we could implement a clone of <code>map()</code>:</p>
 <pre>
<code>extension Sequence {</code>
<code>    func map&lt;T&gt;(_ transform: (Iterator.Element) throws -&gt; T) rethrows -&gt; [T] {</code>
<code>        var iterator = makeIterator()</code>
<code>        var result = [T]()</code>
<code>        while let next = iterator.next() {</code>
<code>            result.append(try transform(next))</code>
<code>        }</code>
<code>        return result</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>But this isn't all -- the greatest property of <code>Sequences</code> and the reason this article was conceived is that <code>Sequences</code> <b>are deeply tied to the Swift compiler in the form of for loops.</b> Like mentioned before, the reason you can use ranges in loops is not because ranges are special, but simply because ranges are <code>Sequences</code>. Because our example <code>Countdown</code> type is a <code>Sequence</code>, it can also be used inside a <code>for</code> loop!</p>
 <pre>
<code>for duration in Countdown(count: 3) {</code>
<code>    print(duration)</code>
<code>}</code>
</pre>
 <p>As one would expect, this will work with any type that conforms to <code>Sequence</code>.</p>
 <h2>How for loops work internally in Swift</h2>
 <p>Interestingly, this behavior isn't new to iOS -- old-timers may remember that you could unlock for-each style loops in Objective-C in a similar fashion by making objects inherit from <code>NSFastEnumerator</code>:</p>
 <pre>
<code>for (id object in objectThatConformsToFastEnumerator) {</code>
<code>    NSLog(@"%@", object);</code>
<code>}</code>
</pre>
 <p>But unlike back then, with Swift we can actually see what's happening under the hood. <code>for</code> exists inside the compiler for the purpose of getting your code to be parsed correctly, but the final code is actually different. To inspect this, what I like to do is to compile an example file and have Swift dump its final <b>Swift Intermediate Language</b> representation:</p>
 <pre class="command-line language-bash" data-host="SwiftRocks">
<code>swiftc -emit-sil forLoopTest.swift</code>
</pre>
 <p>If I run this command with an example <code>forLoopTest.swift</code> file that contains an <code>for</code> loop for an array such as the one below, we'll see things like this around the area where the loop was supposed to be defined:</p>
 <pre>
<code>let array = [1,2,3]</code>
<code>for num in array {</code>
<code>    print(num)</code>
<code>}</code>
</pre>
 <pre>
<code>// function_ref Collection&lt;&gt;.makeIterator()</code>
<code>%40 = function_ref ...</code>
<code>// function_ref IndexingIterator.next()</code>
<code>%40 = function_ref ...</code>
<code>switch_enum %43 : $Optional&lt;Int&gt;, case #some!enumelt.1: bb3, case #none!enumelt: bb2</code>
</pre>
 <p>This shows us that <code>for</code> loops don't really exist -- they are simply a form of syntax sugar to allows you to effortlessly iterate an <code>IteratorProtocol</code> without having to actually extract the iterator!</p>
 <p>We can get more details by seeing Swift's source code, more specifically the classes that handle the <b>semantic analysis</b> of the code. In this case, the magic happens after the compiler type-checks the loop: <a href="https://github.com/apple/swift/blob/3bd45c81357dc03dc54ee57c567230b147d3a8c8/lib/Sema/TypeCheckStmt.cpp#L716">If we analyze the code from the type-checker</a>, we can see that if the loop represents valid code that iterates a <code>Sequence</code>, it injects a new property called <code>${loopName}$generator</code> that fetches the sequence's iterator, then fetches the iterator's <code>Element</code> type and then finally moves our original closure into a new loop that loops the iterator's <code>next()</code> property.</p>
 <p>For example, if we compile the previous loop example, the final result will be something comparable (but not exactly) to this:</p>
 <pre>
<code>let array = [1,2,3]</code>
<code>var $num$generator = array.makeIterator()</code>
<code>while let num = $num$generator.next() { </code>
<code>    print(num)</code>
<code>}</code>
</pre>
 <p>The Swift compiler uses the <code>$</code> prefix for internal compiler synthesized properties. Because it needs to inject actual code, it uses a symbol that is impossible to be used in regular code to make sure we won't have namespacing issues. Interestingly, you can actually interact with some of these internal properties as part of the new <b>property wrappers</b> feature.</p>
 <h2>What about Collections?</h2>
 <p>When studying more about Swift's collection types, <code>IteratorProtocol</code>, <code>Sequence</code> and <code>Collection</code> are often mentioned together, and you might have noticed that the generated SIL for our example mentions <code>Collections</code> as it uses an array. If the syntax sugar is linked to <code>Sequences</code> only, how do collections work?</p>
 <p>We can say that a <code>Collection</code> is simply a more jacked-up version of a <code>Sequence</code>. In fact, all <code>Collections</code> are also <code>Sequences</code>:</p>
 <pre>
<code>public protocol Collection: Sequence { ... }</code>
</pre>
 <p>Unlike regular <code>Sequences</code>, <code>Collections</code> allow you to access elements multiple times, iterate them in reverse order (in the case of <code>BidirectionalCollections</code>) and even access specific elements directly through subscripts (in the case of <code>RandomAccessCollections</code> like <code>Array&lt;&gt;</code>)</p>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>Unlike <code>Sequences</code>, <code>Collections</code> do not need to provide an <code>IteratorProtocol</code>. By default, Swift provides the <code>IndexingIterator</code> struct: an <code>IteratorProtocol</code> that takes a collection and simply traverses the indexes that are defined as part of the <code>Collection</code> protocol. As all <code>Collections</code> are <code>Sequences</code>, they can also benefit from having syntax sugar loops.</p>
 <p>---</p>
 <h2>References and Good reads</h2>
 <a href="https://github.com/apple/swift">The Swift Source Code</a>
 <br>
</div>]]></description>
</item>
<item>
    <title>Building a Face Detecting Robot with URLSessionWebSocketTask, CoreML, SwiftUI and an Arduino</title>
    <link>https://swiftrocks.com/building-a-face-detecting-sentry-gun-with-urlsessionwebsockettask-coreml-swiftui-and-arduino</link>
    <guid>https://swiftrocks.com/building-a-face-detecting-sentry-gun-with-urlsessionwebsockettask-coreml-swiftui-and-arduino</guid>
    <pubDate>Tue, 15 Oct 2019 15:39:00 GMT-3</pubDate>
<description><![CDATA[
 
  
  <!--WRITEIT_POST_NAME=Building a Face Detecting Robot with URLSessionWebSocketTask, CoreML, SwiftUI and an Arduino--> 
  <!--WRITEIT_POST_HTML_NAME=building-a-face-detecting-sentry-gun-with-urlsessionwebsockettask-coreml-swiftui-and-arduino--> 
  <!--WRITEIT_POST_SITEMAP_DATE_LAST_MOD=2020-04-12T14:00:00+02:00--> 
  <!--WRITEIT_POST_SITEMAP_DATE=2019-10-15T18:39:00+00:00--> 
  <!--Add here the additional properties that you want each page to possess.--> 
  <!--These properties can be used to change content in the template page or in the page itself as shown here.--> 
  <!--Properties must start with 'WRITEIT_POST'.--> 
  <!--Writeit provides and injects WRITEIT_POST_NAME and WRITEIT_POST_HTML_NAME by default.--> 
  <!--WRITEIT_POST_SHORT_DESCRIPTION=Some time ago I created a little side project that involved an Arduino-powered servo motor that menacingly pointed at people's faces with the help of CoreML, mimicking the Team Fortress 2 Engineer's Sentry Gun. With iOS 13, I decided to re-write that using the new Socket APIs and SwiftUI.--> 
  <title>Building a Face Detecting Robot with URLSessionWebSocketTask, CoreML, SwiftUI and an Arduino</title>  
 

<div class="blog-post"> 
 <div class="post-title-index">  
  <h1>Building a Face Detecting Robot with URLSessionWebSocketTask, CoreML, SwiftUI and an Arduino</h1>
 </div> 
 <div class="post-info"> 
  <div class="post-info-text">
   Published on 16 Oct 2019 
  </div> 
 </div>   
 <div class="post-image margin-top-40 margin-bottom-40"> 
  <video style="width: 100%; height: auto;" controls> 
   <source src="https://i.imgur.com/g6lhAxR.mp4" type="video/mp4"> Your browser does not support the video tag. 
  </video> 
 </div> 
 <p>iOS 13 marks the release of long-waited features like Dark Mode, but it also brought some needed changes on less popular aspects. Prior to iOS 13, creating socket connections required coding very low-level network interactions which made libraries like Starscream and Socket.io the go-to solution for sockets in iOS. Now with iOS 13, a new native <code>URLSessionWebSocketTask</code> class is available to finally make creating and managing socket connections easier for developers.</p>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p><a href="https://twitter.com/rockbruno_/status/993152346841669632">Some time ago I created a little side project that involved an Arduino-powered servo motor that menacingly pointed at people's faces with the help of CoreML, mimicking the Team Fortress 2 Engineer's Sentry Gun.</a> With iOS 13, I decided to re-write that using the new Socket APIs and SwiftUI.</p>
 <div class="post-image margin-top-40 margin-bottom-40"> 
  <video style="width: 100%; height: auto;" controls> 
   <source src="https://i.imgur.com/g6lhAxR.mp4" type="video/mp4"> Your browser does not support the video tag. 
  </video> 
 </div>
 <p>Although the final project involves an Arduino and a Raspberry Pi, the focus will be the iOS part of it since Swift is the focus of this blog. If at the end you want more info about how the other components are connected, feel free to contact me with questions!</p>
 <h2>Organizing the ideas</h2>
 <p>Since this project has several components, lets detail what needs to be done. To build a face tracking murder robot, we'll need an iOS app that does the following:</p>
 <p> * The app opens the user's camera.</p>
 <p> * Each time the camera's frame is updated, we capture its output.</p>
 <p> * The output is routed to Vision's <code>VNDetectFaceRectanglesRequest</code>.</p>
 <p> * From the results, we draw rectangles on the screen to show where faces were detected.</p>
 <p> * Assuming that the first found face is our target, we calculate the X/Y angles that our robot should face based on the face's bounds on the screen.</p>
 <p> * Using sockets, we'll send these angles to a Raspberry Pi which will be running a server and handling the communication with the Arduino-connected servo motor.</p>
 <p> * While all that happens, we display a HUD with some basic information to the user.</p>
 <h2>Using URLSessionWebSocketTask</h2>
 <p>We can start this project by creating a worker class that handles a socket connection to a generic server. Similar to how regular <code>URLSession</code> tasks are created, we can retrieve an instance of a socket task by calling <code>URLSession.webSocketTask()</code> and passing the URL to the socket server:</p>
 <pre>
<code>lazy var session = URLSession(configuration: .default,</code>
<code>                              delegate: self,</code>
<code>                              delegateQueue: OperationQueue())</code>
<code></code>
<code>lazy var webSocketTask: URLSessionWebSocketTask = {</code>
<code>    // This is the IP of my Raspberry Pi.</code>
<code>    let url = URL(string: "ws://192.168.15.251:12354")!</code>
<code>    return session.webSocketTask(with: url)</code>
<code>}()</code>
</pre>
 <p>Although receiving messages from the socket isn't necessary for this project, covering it is important: <code>URLSessionWebSocketTask</code> supports receiving and sending messages in both <code>Data</code> and <code>String</code> formats, and calling <code>receive</code> will allow the client to receive a message from the server:</p>
 <pre>
<code>func receive() {</code>
<code>    webSocketTask.receive { result in</code>
<code>        switch result {</code>
<code>        case .success(let message):</code>
<code>            switch message {</code>
<code>            case .data(let data):</code>
<code>                print(data)</code>
<code>            case .string(let string):</code>
<code>                print(string)</code>
<code>            }</code>
<code>        case .failure(let error):</code>
<code>            print(error)</code>
<code>        }</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>An important aspect here is that unlike other Socket solutions for iOS, <code>receive</code> <b>isn't permanent -- once you receive a message, you'll need to call this method again to receive more messages.</b> This is a very weird design decision considering that the point of sockets is to continuously receive and send messages, but it's how it works in iOS 13.</p>
 <p>In a similar fashion, sending messages can be done by calling the <code>send</code> method:</p>
 <pre>
<code>webSocketTask.send(.string("I love sockets!")) { error in</code>
<code>    if let error = error {</code>
<code>        print(error)</code>
<code>    }</code>
<code>}</code>
</pre>
 <h2>Connecting to URLSessionWebSocketTask servers</h2>
 <p>Similar to how regular tasks are started, socket tasks can be initiated by calling the <code>resume()</code> method from the task. After the connection is made, the process of receiving and sending messages will start, and updates to the socket's connection will be posted via the <code>URLSessionWebSocketDelegate</code> type. That's a lot easier than pre-iOS 13 socket solutions!</p>
 <p><b>An important server-side aspect of </b><code>URLSessionWebSocketTask</code><b> that is not documented is that Apple expects socket servers to conform to the</b> <a href="https://tools.ietf.org/html/rfc6455">RFC 6455 - Web Socket Protocol</a>. While Starscream and Socket.io allow you to play with sockets in iOS with simple generic Python servers, using <code>URLSessionWebSocketTask</code> will require you to build a server that is capable of handling the protocol's handshakes and data patterns. If the server doesn't conform to RFC 6455, iOS will simply never connect to the server. <a href="https://gist.github.com/rich20bb/4190781">This is an example of a Python server that works with it, which you can use to test the new socket APIs.</a></p>
 <h2>SocketWorker</h2>
 <p>Now that we know how to use iOS 13's new socket class we can build a simple wrapper class to use it. Because we're going to build our UI with SwiftUI, my worker class will inherit from <code>ObservableObject</code> and define a publisher to allow me to route the socket's connection information back to the views. Here's the almost final version of the <code>SocketWorker</code> (sending messages will be added later):</p>
 <pre>
<code>final class SocketWorker: NSObject, ObservableObject {</code>
<code>    lazy var session = URLSession(configuration: .default,</code>
<code>                                  delegate: self,</code>
<code>                                  delegateQueue: OperationQueue())</code>
<code></code>
<code>    lazy var webSocketTask: URLSessionWebSocketTask = {</code>
<code>        let url = URL(string: "ws://169.254.141.251:12354")!</code>
<code>        return session.webSocketTask(with: url)</code>
<code>    }()</code>
<code></code>
<code>    var lastSentData = ""</code>
<code></code>
<code>    let objectWillChange = ObservableObjectPublisher()</code>
<code></code>
<code>    var isConnected: Bool? = nil {</code>
<code>        willSet {</code>
<code>            DispatchQueue.main.async { [weak self] in</code>
<code>                self?.objectWillChange.send()</code>
<code>            }</code>
<code>        }</code>
<code>    }</code>
<code></code>
<code>    var connectionStatus: String {</code>
<code>        guard let isConnected = isConnected else {</code>
<code>            return "Connecting..."</code>
<code>        }</code>
<code>        if isConnected {</code>
<code>            return "Connected"</code>
<code>        } else {</code>
<code>            return "Disconnected"</code>
<code>        }</code>
<code>    }</code>
<code></code>
<code>    func resume() {</code>
<code>        webSocketTask.resume()</code>
<code>    }</code>
<code></code>
<code>    func suspend() {</code>
<code>        webSocketTask.suspend()</code>
<code>    }</code>
<code>}</code>
<code></code>
<code>extension SocketWorker: URLSessionWebSocketDelegate {</code>
<code>    func urlSession(_ session: URLSession, webSocketTask: URLSessionWebSocketTask, didOpenWithProtocol protocol: String?) {</code>
<code>        isConnected = true</code>
<code>    }</code>
<code></code>
<code>    func urlSession(_ session: URLSession, webSocketTask: URLSessionWebSocketTask, didCloseWith closeCode: URLSessionWebSocketTask.CloseCode, reason: Data?) {</code>
<code>        isConnected = false</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>It would be nice to display the socket's connection status and camera's targeting information to the user, so we'll build a view to do so. Thankfully SwiftUI allows us to do this quicker than ever:</p>
 <div class="post-image margin-top-40 margin-bottom-40"> 
  <img src="https://i.imgur.com/QrHhYgS.png" alt="" style="max-width: 100%"> 
 </div>
 <pre>
<code>struct DataView: View {</code>
<code></code>
<code>    let descriptionText: String</code>
<code>    let degreesText: String</code>
<code>    let connectionText: String</code>
<code>    let isConnected: Bool?</code>
<code></code>
<code>    let padding: CGFloat = 32</code>
<code></code>
<code>    var body: some View {</code>
<code>        VStack(alignment: .center) {</code>
<code>            HStack {</code>
<code>                Text(connectionText)</code>
<code>                    .font(.system(.callout))</code>
<code>                    .foregroundColor(isConnected == true ? .green : .red)</code>
<code>                Spacer()</code>
<code>            }</code>
<code>            Spacer()</code>
<code>            VStack(alignment: .center, spacing: 8) {</code>
<code>                Text(descriptionText)</code>
<code>                    .font(.system(.largeTitle))</code>
<code>                Text(degreesText)</code>
<code>                    .font(.system(.title))</code>
<code>            }</code>
<code>        }.padding(padding)</code>
<code>    }</code>
<code>}</code>
</pre>
 <h2>TargetDataViewModel</h2>
 <p>To allow our <code>DataView</code> to receive the camera's targeting information, we'll create an observable <code>TargetDataViewModel</code> that will be responsible for storing and routing the user's UI strings as well as the actual data that will be sent to the socket.</p>
 <p>Processing the socket data will work by receiving a face's <code>CGRect</code>; based on the face's frame on the screen, we can calculate the X and Y angles that the Arduino's servo motor should be aiming at. In this case since I only have one servo, only the X angle will be sent to the socket. You can send anything to the socket, and for simplicity, I've decided to follow the <code>X{angle}.</code> format. This means that if the servo needs to aim at 90 degrees, the socket will receive a message containing <code>X90.</code>. The dot at the end serves as an "end of command" token, which makes things easier on the Arduino side. If there's no visible face on the screen, we'll send <code>L</code> to the socket (as in, target lost). We'll make this communication work through delegates so we can send this data back to <code>SocketWorker</code>:</p>
 <pre>
<code>protocol TargetDataViewModelDelegate: AnyObject {</code>
<code>    func targetDataDidChange(_ data: String)</code>
<code>}</code>
<code></code>
<code>class TargetDataViewModel: ObservableObject {</code>
<code></code>
<code>    weak var delegate: TargetDataViewModelDelegate?</code>
<code></code>
<code>    let objectWillChange = ObservableObjectPublisher()</code>
<code></code>
<code>    var targetTitle = "..." {</code>
<code>        willSet {</code>
<code>            self.objectWillChange.send()</code>
<code>        }</code>
<code>    }</code>
<code></code>
<code>    var targetDescription = "..." {</code>
<code>        willSet {</code>
<code>            self.objectWillChange.send()</code>
<code>        }</code>
<code>    }</code>
<code></code>
<code>    func process(target: CGRect?) {</code>
<code>        guard let target = target else {</code>
<code>            targetTitle = "Sentry mode"</code>
<code>            targetDescription = "No targets"</code>
<code>            delegate?.targetDataDidChange("L")</code>
<code>            return</code>
<code>        }</code>
<code>        let oldMin: CGFloat = 0</code>
<code>        let offset: CGFloat = 40</code>
<code>        let newMin: CGFloat = 0 + offset</code>
<code>        let newMax: CGFloat = 180 - offset</code>
<code>        let newRange = newMax - newMin</code>
<code>        func convertToDegrees(position: CGFloat, oldMax: CGFloat) -&gt; Int {</code>
<code>            let oldRange = oldMax - oldMin</code>
<code>            let scaledAngle = (((position - oldMin) * newRange) / oldRange) + newMin</code>
<code>            return Int(scaledAngle)</code>
<code>        }</code>
<code>        let bounds = UIScreen.main.bounds</code>
<code>        let oldMaxX = bounds.width</code>
<code>        let oldMaxY = bounds.height</code>
<code>        let xAngle = convertToDegrees(position: target.midX, oldMax: oldMaxX)</code>
<code>        let yAngle = convertToDegrees(position: target.midY, oldMax: oldMaxY)</code>
<code>        targetTitle = "Shooting"</code>
<code>        targetDescription = "X: \(xAngle) | Y: \(yAngle)"</code>
<code>        let data = "X\(xAngle)."</code>
<code>        delegate?.targetDataDidChange(data)</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>With the view model in place, we can finish <code>SocketWorker</code> by making it send the target's information to the socket:</p>
 <pre>
<code>extension SocketWorker: TargetDataViewModelDelegate {</code>
<code>    func targetDataDidChange(_ data: String) {</code>
<code>        // Avoid sending duplicate data to the socket.</code>
<code>        guard data != lastSentData else {</code>
<code>            return</code>
<code>        }</code>
<code>        lastSentData = data</code>
<code>        webSocketTask.send(.string(data)) { error in</code>
<code>            if let error = error {</code>
<code>                print(error)</code>
<code>            }</code>
<code>        }</code>
<code>    }</code>
<code>}</code>
</pre>
 <h2>Showing the user's camera on the screen</h2>
 <p>Getting access to a device's camera with SwiftUI has a small problem. Although we can easily do it in UIKit using <code>AVCaptureVideoPreviewLayer</code>, the concept of layers doesn't really exist in SwiftUI, so we can't use this layer in normal SwiftUI views. Fortunately, Apple allows you to create bridges between UIKit and SwiftUI so that no functionality is lost.</p>
 <p>In order to display a camera, we'll need to build an old-fashioned UIKit <code>CameraViewController</code> and bridge it to SwiftUI using the <code>UIViewControllerRepresentable</code> protocol. We'll also route our data view model to this view controller so it can update it based on the camera's output:</p>
 <pre>
<code>struct CameraViewWrapper: UIViewControllerRepresentable {</code>
<code></code>
<code>    typealias UIViewControllerType = CameraViewController</code>
<code>    typealias Context = UIViewControllerRepresentableContext</code>
<code></code>
<code>    let viewController: CameraViewController</code>
<code></code>
<code>    func makeUIViewController(context: Context&lt;CameraViewWrapper&gt;) -&gt; CameraViewController {</code>
<code>        return viewController</code>
<code>    }</code>
<code></code>
<code>    func updateUIViewController(_ uiViewController: CameraViewController, context: Context&lt;CameraViewWrapper&gt;) {}</code>
<code>}</code>
<code></code>
<code>final class CameraViewController: UIViewController, ObservableObject {</code>
<code></code>
<code>    @ObservedObject var targetViewModel: TargetDataViewModel</code>
<code></code>
<code>    init(targetViewModel: TargetDataViewModel) {</code>
<code>        self.targetViewModel = targetViewModel</code>
<code>        super.init(nibName: nil, bundle: nil)</code>
<code>    }</code>
<code></code>
<code>    required init?(coder: NSCoder) {</code>
<code>        fatalError()</code>
<code>    }</code>
<code></code>
<code>    override func loadView() {</code>
<code>        let view = CameraView(delegate: self)</code>
<code>        self.view = view</code>
<code>    }</code>
<code></code>
<code>    override func viewWillAppear(_ animated: Bool) {</code>
<code>        super.viewWillAppear(animated)</code>
<code>        (view as? CameraView)?.startCaptureSession()</code>
<code>    }</code>
<code></code>
<code>    override func viewWillDisappear(_ animated: Bool) {</code>
<code>        super.viewWillAppear(animated)</code>
<code>        (view as? CameraView)?.stopCaptureSession()</code>
<code>    }</code>
<code>}</code>
<code></code>
<code>extension CameraViewController: CameraViewDelegate {</code>
<code>    func cameraViewDidTarget(frame: CGRect) {</code>
<code>        targetViewModel.process(target: frame, view: view)</code>
<code>    }</code>
<code></code>
<code>    func cameraViewFoundNoTargets() {</code>
<code>        targetViewModel.process(target: nil, view: view)</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>I will skip the definition of <code>CameraView</code> because the code is massive and there's nothing special about it -- we just add a camera layer to the screen and start recording once the view controller appears. We also define a <code>CameraViewDelegate</code> so that our face detection events can be routed back to our view model. <a href="https://github.com/rockbruno/NSSentryGun">You can see the code for it in the NSSentryGun repo.</a></p>
 <p>Now with the actual face detection being all that's left, we can wrap everything up into our app's main <code>ContentView</code>!</p>
 <pre>
<code>struct ContentView: View {</code>
<code></code>
<code>    @ObservedObject var socketWorker: SocketWorker</code>
<code>    @ObservedObject var targetViewModel: TargetDataViewModel</code>
<code></code>
<code>    let cameraViewController: CameraViewController</code>
<code></code>
<code>    init() {</code>
<code>        self.socketWorker = SocketWorker()</code>
<code>        let targetViewModel = TargetDataViewModel()</code>
<code>        self.targetViewModel = targetViewModel</code>
<code>        self.cameraViewController = CameraViewController(</code>
<code>            targetViewModel: targetViewModel</code>
<code>        )</code>
<code>        targetViewModel.delegate = socketWorker</code>
<code>    }</code>
<code></code>
<code>    var body: some View {</code>
<code>        ZStack {</code>
<code>            CameraViewWrapper(</code>
<code>                viewController: cameraViewController</code>
<code>            )</code>
<code>            DataView(</code>
<code>                descriptionText: targetViewModel.targetTitle,</code>
<code>                degreesText: targetViewModel.targetDescription,</code>
<code>                connectionText: socketWorker.connectionStatus,</code>
<code>                isConnected: socketWorker.isConnected</code>
<code>            ).expand()</code>
<code>        }.onAppear {</code>
<code>            self.socketWorker.resume()</code>
<code>        }.onDisappear {</code>
<code>            self.socketWorker.suspend()</code>
<code>        }.expand()</code>
<code>    }</code>
<code>}</code>
<code></code>
<code>extension View {</code>
<code>    func expand() -&gt; some View {</code>
<code>        return frame(</code>
<code>            minWidth: 0,</code>
<code>            maxWidth: .infinity,</code>
<code>            minHeight: 0,</code>
<code>            maxHeight: .infinity,</code>
<code>            alignment: .topLeading</code>
<code>        )</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>After turning on our socket server, running this app will allow us to connect to it and see the user's camera. However, no information will be actually sent since we're doing nothing with the camera's output yet.</p>
 <div class="post-image margin-top-40 margin-bottom-40"> 
  <img src="https://i.imgur.com/lNh5OBu.jpg" alt="" style="max-width: 100%">&gt; 
 </div>
 <h2>Detecting faces in images with CoreML</h2>
 <p>After the release of CoreML, every iOS release adds new capabilities to the built-in <code>Vision</code> framework. In this case, the ability to detect faces in an image can be easily done by performing the <code>VNDetectFaceRectanglesRequest</code> request with the camera's output as a parameter.</p>
 <p>The result of this request is a <code>[VNFaceObservation]</code> array that contains the bounding box of every face detected in the image. We can use this result to draw rectangles around the detected faces and use these rectangles as the input for our previously made <code>TargetDataViewModel</code>. Before defining the request itself, lets first handle the response code inside <code>CameraView</code>:</p>
 <pre>
<code>func handleFaces(request: VNRequest, error: Error?) {</code>
<code>    DispatchQueue.main.async { [unowned self] in</code>
<code>        guard let results = request.results as? [VNFaceObservation] else {</code>
<code>            return</code>
<code>        }</code>
<code>        // We'll add all drawn rectangles in a `maskLayer` property</code>
<code>        // and remove them when we get new responses.</code>
<code>        for mask in self.maskLayer {</code>
<code>            mask.removeFromSuperlayer()</code>
<code>        }</code>
<code>        let frames: [CGRect] = results.map {</code>
<code>            let transform = CGAffineTransform(scaleX: 1, y: -1)</code>
<code>                                .translatedBy(x: 0, y: -self.frame.height)</code>
<code>            let translate = CGAffineTransform</code>
<code>                                .identity</code>
<code>                                .scaledBy(x: self.frame.width, y: self.frame.height)</code>
<code>            return $0.boundingBox</code>
<code>                        .applying(translate)</code>
<code>                        .applying(transform)</code>
<code>        }</code>
<code>        frames</code>
<code>            .sorted { ($0.width * $0.height) &gt; ($1.width * $1.height) }</code>
<code>            .enumerated()</code>
<code>            .forEach(self.drawFaceBox)</code>
<code>        guard let targetRect = results.first else {</code>
<code>            self.delegate.cameraViewFoundNoTargets()</code>
<code>            return</code>
<code>        }</code>
<code>        delegate.cameraViewDidTarget(frame: targetRect)</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>(The <code>boundingBox</code> property contains values from zero to one with the y-axis going up from the bottom, so this method also needs to handle scaling and reversing the y-axis for the box to match the camera's bounds.)</p>
 <p>After processing the face's rectangle, we sort them by total area and draw them on the screen. We'll consider the rectangle with the biggest area as our target.</p>
 <pre>
<code>func drawFaceBox(index: Int, frame: CGRect) {</code>
<code>    let color = index == 0 ? UIColor.red.cgColor : UIColor.yellow.cgColor</code>
<code>    createLayer(in: frame, color: UIColor.red.cgColor)</code>
<code>}</code>
<code></code>
<code>private func createLayer(in rect: CGRect, color: CGColor) {</code>
<code>    let mask = CAShapeLayer()</code>
<code>    mask.frame = rect</code>
<code>    mask.opacity = 1</code>
<code>    mask.borderColor = color</code>
<code>    mask.borderWidth = 2</code>
<code>    maskLayer.append(mask)</code>
<code>    layer.insertSublayer(mask, at: 1)</code>
<code>}</code>
</pre>
 <p>To perform the request, we need access to the camera's image buffer. This can be done by setting our <code>CameraView</code> as the layer's <code>AVCaptureVideoDataOutput</code> delegate, which has a method containing the camera's buffer. We can then convert the buffer into Vision's expected <code>CVImageBuffer</code> input and finally perform the request:</p>
 <pre>
<code>extension CameraView: AVCaptureVideoDataOutputSampleBufferDelegate {</code>
<code>    func captureOutput(_ output: AVCaptureOutput, didOutput sampleBuffer: CMSampleBuffer, from connection: AVCaptureConnection) {</code>
<code>        guard let pixelBuffer = CMSampleBufferGetImageBuffer(sampleBuffer),</code>
<code>              let exifOrientation = CGImagePropertyOrientation(rawValue: 0) else</code>
<code>        {</code>
<code>            return</code>
<code>        }</code>
<code>        var requestOptions: [VNImageOption : Any] = [:]</code>
<code>        let key = kCMSampleBufferAttachmentKey_CameraIntrinsicMatrix</code>
<code>        if let cameraIntrinsicData = CMGetAttachment(sampleBuffer, key: key, attachmentModeOut: nil) {</code>
<code>            requestOptions = [.cameraIntrinsics: cameraIntrinsicData]</code>
<code>        }</code>
<code>        let imageRequestHandler = VNImageRequestHandler(</code>
<code>            cvPixelBuffer: pixelBuffer,</code>
<code>            orientation: exifOrientation,</code>
<code>            options: requestOptions</code>
<code>       )</code>
<code>        do {</code>
<code>            let request = VNDetectFaceRectanglesRequest(completionHandler: handleFaces)</code>
<code>            try imageRequestHandler.perform([request])</code>
<code>        } catch {</code>
<code>            print(error)</code>
<code>        }</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>If we run the app now and point at something, we'll see rectangles being drawn around faces!</p>
 <div class="post-image margin-top-40 margin-bottom-40"> 
  <img src="https://i.imgur.com/kQtDmQ5.jpg" alt="" style="max-width: 100%"> 
 </div>
 <p>And because we're using <code>ObservableObjects</code>, the processing that happens inside <code>TargetDataViewModel</code> will be published back to the <code>SocketWorker</code>, which will finally send our target's information to the server.</p>
 <div class="post-image"> 
  <img src="https://i.imgur.com/AJZyMyE.png" alt="" style="max-width: 100%"> 
 </div>
 <h2>Beyond iOS: Making an Arduino receive this information</h2>
 <p>As stated at the beginning of the article I won't go too deep on the components that aren't iOS related, but if you're wondering how sending the information to a socket results in a servo motor being moved, we'll use this section to talk more about it.</p>
 <p>Arduinos can communicate with other devices through its serial port, which is connected as a USB device on the other end. With the Arduino connected to your server (I used a Raspberry Pi for the video in the introduction, but simply running the server script on your Mac works as well), you can use Python's <code>serial</code> library to open a connection with the Arduino:</p>
 <pre>
<code>import serial</code>
<code>ser = serial.Serial('/dev/cu.usbmodem1412401', 9600)</code>
</pre>
 <p>In this case, <code>/dev/cu.usbmodem1412401</code> is the name of the port where my Arduino is connected, and 9600 is the baud rate expected by the Arduino.</p>
 <p>When the server receives data from the iOS app, we can write it into the serial port:</p>
 <pre>
<code>while True:</code>
<code>    newData = client.recv(4096)</code>
<code>    msg = self.connections[fileno].recover(newData)</code>
<code>    if not msg: continue</code>
<code>    print msg</code>
<code>    ser.write(msg)</code>
</pre>
 <p>If the Arduino is listening to its serial port, it will be able to receive this data and parse it into something meaningful. With a servo motor connected to pin 9, here's the Arduino C code to parse the little rules we created when processing the data in the view model:</p>
 <pre>
<code>#include &lt;Servo.h&gt;</code>
<code></code>
<code>Servo myservo;</code>
<code></code>
<code>bool isScanning = false;</code>
<code></code>
<code>void setup() {</code>
<code>  Serial.begin(9600);</code>
<code>  myservo.attach(9);</code>
<code>  myservo.write(90);</code>
<code>  delay(1000);</code>
<code>}</code>
<code></code>
<code>void loop() {</code>
<code>  if (isScanning == true) {</code>
<code>    scan();</code>
<code>    return;</code>
<code>  }</code>
<code>  if (Serial.available() &gt; 0) {</code>
<code>    char incomingByte = Serial.read();</code>
<code>    if (incomingByte == 'L') {</code>
<code>      isScanning = true;</code>
<code>    } else if (incomingByte == 'X') { // else if</code>
<code>      setServoAngle();</code>
<code>    } else { //Unwanted data, get rid of it</code>
<code>      while(Serial.read() != -1) {</code>
<code>        incomingByte = Serial.read();</code>
<code>      }</code>
<code>    }</code>
<code>  }</code>
<code>}</code>
<code></code>
<code>void scan() {</code>
<code>  int angle = myservo.read();</code>
<code>  for (int i = angle; i&lt;= 160; i++) {</code>
<code>    if (Serial.peek() != -1) {</code>
<code>      isScanning = false;</code>
<code>      return;</code>
<code>    }</code>
<code>    myservo.write(i);</code>
<code>    delay(15);</code>
<code>  }</code>
<code>  for (int i = 160; i&gt;= 20; i--) {</code>
<code>    if (Serial.peek() != -1) {</code>
<code>      isScanning = false;</code>
<code>      return;</code>
<code>    }</code>
<code>    myservo.write(i);</code>
<code>    delay(15);</code>
<code>  }</code>
<code>}</code>
<code></code>
<code>void setServoAngle() {</code>
<code>  unsigned int integerValue = 0;</code>
<code>  while(1) {</code>
<code>    char incomingByte = Serial.read();</code>
<code>    if (incomingByte == -1) {</code>
<code>      continue;</code>
<code>    }</code>
<code>    if (isdigit(incomingByte) == false) {</code>
<code>      break;</code>
<code>    }</code>
<code>    integerValue *= 10;</code>
<code>    integerValue = ((incomingByte - 48) + integerValue);</code>
<code>  }</code>
<code>  if (integerValue &gt;= 0 &amp;&amp; integerValue &lt;= 180) {</code>
<code>      myservo.write(integerValue);</code>
<code>  }</code>
<code>}</code>
</pre>
 <p>To make it short, Arduino will enter a "scan mode" that makes the servo wiggle back and forth if an <code>L</code> is received from the server. This goes on until an <code>X</code> is received -- when this happens, the Arduino then parses the numeric component of the command and sets it as the servo's angle. All that's left now is to attach a Nerf gun to it and make it actually shoot intruders!</p>
 <h2>Conclusion</h2>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>The introduction of the new URLSessionWebSocketTask finally solves a major pain point in developing networking applications for iOS, and I hope this article sparks some ideas for new side projects for you. Creating side projects is a cool way to learn new technologies -- I first did this project to know more about Raspberry Pis, and this article was a chance for me to have my first interaction with SwiftUI and Combine after Xcode 11's release.</p>
 <p>Follow me on my Twitter (<a href="https://twitter.com/rockbruno_">@rockbruno_</a>), and let me know of any suggestions and corrections you want to share.</p>
 <h2>References and Good reads</h2>
 <a href="https://developer.apple.com/documentation/foundation/urlsessionwebsockettask">URLSessionWebSocketTask</a>
 <br>
 <a href="https://tools.ietf.org/html/rfc6455">RFC 6455 - The WebSocket Protocol</a>
 <br>
 <a href="https://gist.github.com/rich20bb/4190781">Python implementation of an RFC 6455 socket server</a>
 <br>
</div>]]></description>
</item>
<item>
    <title>Using SIMD Vector Types in Swift</title>
    <link>https://swiftrocks.com/using-simd-vector-types-in-swift</link>
    <guid>https://swiftrocks.com/using-simd-vector-types-in-swift</guid>
    <pubDate>Sun, 29 Sep 2019 15:00:00 GMT-3</pubDate>
<description><![CDATA[
 
  
  <!--WRITEIT_POST_NAME=Using SIMD Vector Types in Swift--> 
  <!--WRITEIT_POST_HTML_NAME=using-simd-vector-types-in-swift--> 
  <!--WRITEIT_POST_SITEMAP_DATE_LAST_MOD=2020-04-12T14:00:00+02:00--> 
  <!--WRITEIT_POST_SITEMAP_DATE=2019-09-29T18:00:00+00:00--> 
  <!--Add here the additional properties that you want each page to possess.--> 
  <!--These properties can be used to change content in the template page or in the page itself as shown here.--> 
  <!--Properties must start with 'WRITEIT_POST'.--> 
  <!--Writeit provides and injects WRITEIT_POST_NAME and WRITEIT_POST_HTML_NAME by default.--> 
  <!--WRITEIT_POST_SHORT_DESCRIPTION=SIMD Vector Types is a feature added in Swift 5 that allows you to calculate multiple results with a single instruction. Let's see how that works.--> 
  <title>Using SIMD Vector Types in Swift</title>  
 

<div class="blog-post"> 
 <div class="post-title-index">  
  <h1>Using SIMD Vector Types in Swift</h1>
 </div> 
 <div class="post-info"> 
  <div class="category category-swift">
   Swift
  </div> 
  <div class="post-info-text">
   Published on 30 Sep 2019 
  </div> 
 </div>  
 <p><b>SIMD Vector Types</b> is a feature added in Swift 5 that exposes Apple's <code>&lt;simd/simd.h&gt;</code> module to Swift, allowing you to calculate multiple results with a single instruction.</p>
 <h2>What's SIMD?</h2>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>SIMD stands for <b>Single Instruction, Multiple Data</b>, a hardware instruction that can be used once to perform multiple operations <b>at once.</b> There's nothing you can do with SIMD that you can't do without it, but in the world of graphical applications where handling multiple values in the shape of vectors and matrices is important, usage of SIMD types can provide big performance boosts over calculating values normally.</p>
 <p>Let's assume that we are handling the position of a character in a game that currently sits in the vector <code>x: 2 | y: 4</code>, and an explosion needs to apply some knockback to it.</p>
 <p>If we assume that the knockback multiplies the character's position by two, we'll need to do two operations to end up with <code>x: 4| y: 8</code>:</p>
 <pre>
<code>(64bit integers)</code>
<code>0000000000000000000000000000000000000000000000000000000000000010</code>
<code>times</code>
<code>0000000000000000000000000000000000000000000000000000000000000010</code>
<code>-- and</code>
<code>0000000000000000000000000000000000000000000000000000000000000100</code>
<code>times</code>
<code>0000000000000000000000000000000000000000000000000000000000000010</code>
</pre>
 <p>While there's nothing particular wrong about doing two operations to achieve this, we can do better: a SIMD vector allows us to store multiple pieces of data in a single register by splitting our 64 bits of memory into smaller sections. In the case of our character, we can use a <code>SIMD2</code> vector to store two different 32 bit values in a single 64 bit storage:</p>
 <pre>
<code>32 bits for (x: 2), and 32 bits for (4)</code>
<code>00000000000000000000000000000010 | 00000000000000000000000000000100</code>
</pre>
 <p>If we treat the knockback's power as another <code>SIMD2</code>, we can multiply the vectors together to get the character's new position in one go:</p>
 <pre>
<code>00000000000000000000000000000010 | 00000000000000000000000000000100</code>
<code>times</code>
<code>00000000000000000000000000000010 | 00000000000000000000000000000010</code>
</pre>
 <p>This allows us to perform a single hardware instruction that will end up containing the result of multiple operators -- in this case, a single instruction will allow us to get a <b>new</b> vector that contains the new values for both the x and y axes. Data-parallel problems like this have shown to gain between 2-10x better performance when using SIMD types, making them an invaluable tool when building high performance algorithms in the graphical applications world.</p>
 <p>For example, a more common problem that benefits from SIMD is changing the brightness of an image -- instead of individually bumping the R, G and B channels of each pixel for each of the millions of pixels in a modern screen, we can treat the pixels' channels as a SIMD3 vector to reduce the number of instructions by around 3x.</p>
 <h2>SIMD in Swift</h2>
 <p>Starting from Swift 5, SIMD Vector types that range from 2 to 64 lanes are available for use. This is how the previous character example can be written in Swift using <code>SIMD2&lt;Int32&gt;</code>:</p>
 <pre>
<code>let character = SIMD2&lt;Int32&gt;(arrayLiteral: 2, 4)</code>
<code>let knockback = SIMD2&lt;Int32&gt;(arrayLiteral: 2, 2)</code>
<code>let result: SIMD2&lt;Int32&gt; = character &amp;* knockback // 4,8</code>
</pre>
 <p>Vectors can be operated on through masked arithmetic operators, and individual values of the vectors can be accessed with the <code>x,y,z,w</code> properties, depending on how big the lanes are. If the SIMD has more than four lanes, you can use the <code>lowHalf</code> and <code>highHalf</code> to access smaller halves of the lanes until you can access individual values.</p>
 <pre>
<code>var character = SIMD2&lt;Int32&gt;()</code>
<code>character.x = 2</code>
<code>character.y = 4</code>
<code>var fourLanes = SIMD4&lt;Int16&gt;()</code>
<code>fourLanes.x = 2</code>
<code>fourLanes.y = 4</code>
<code>fourLanes.z = 8</code>
<code>fourLanes.w = 16</code>
<code>var eightLanes = SIMD8&lt;Int8&gt;()</code>
<code>eightLanes.lowHalf.x = 1</code>
<code>eightLanes.highHalf.w = 1</code>
<code></code>
<code>character &amp;+ character // 4, 8</code>
<code>character &amp;- character // 0, 0</code>
<code>character &amp;* character // 4, 16</code>
<code>character / character // 1, 1</code>
</pre>
 <p>(Note that because only masked operators are supported, Swift will not protect you from overflowing values when using SIMD vectors.)</p>
 <p>Besides arithmetic operators, SIMD types also supports comparison operators:</p>
 <pre>
<code>character == knockback // false</code>
</pre>
 <p>In addition to comparing the entire vector itself, SIMD types in Swift also support <b>pointwise operators</b> for comparisons. If instead of comparing everything we're looking to get the individual result for each comparison in the vector, we can prefix a dot <code>.</code> to the operator to get the pointwise version of it. For equality for example, we can use the <code>.==</code> pointwise operator to get a vector of booleans that indicates the result of each individual equality.</p>
 <pre>
<code>character .== knockback // SIMDMask&lt;SIMD2&lt;Int32&gt;&gt;(false, true)</code>
</pre>
 <h2>Conclusion</h2>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>Although the monstrous performance benefits can be only seen in the world of graphical applications, many problems can benefit from SIMD by being vectorized. Even when working with consumer applications, being careful about memory and CPU usage can bring big benefits to the user experience while teaching you more about software engineering.</p>
 <p>Follow me on my Twitter (<a href="https://twitter.com/rockbruno_">@rockbruno_</a>), and let me know of any suggestions and corrections you want to share.</p>
 <h2>References and Good reads</h2>
 <a href="https://github.com/apple/swift">The Swift Source Code</a>
 <br>
 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0229-simd.md">SIMD Proposal</a>
 <br>
 <a href="https://www.coursera.org/lecture/comparch/simd-MtZ5W">SIMD Lecture from Princeton</a>
 <br>
</div>]]></description>
</item>
<item>
    <title>Timsort and Introsort: Swift's Sorting Algorithms</title>
    <link>https://swiftrocks.com/introsort-timsort-swifts-sorting-algorithm</link>
    <guid>https://swiftrocks.com/introsort-timsort-swifts-sorting-algorithm</guid>
    <pubDate>Wed, 4 Sep 2019 15:00:00 GMT-3</pubDate>
<description><![CDATA[
 
  
  <!--WRITEIT_POST_NAME=Timsort and Introsort: Swift's Sorting Algorithms--> 
  <!--WRITEIT_POST_HTML_NAME=introsort-timsort-swifts-sorting-algorithm--> 
  <!--WRITEIT_POST_SITEMAP_DATE_LAST_MOD=2020-04-12T14:00:00+02:00--> 
  <!--WRITEIT_POST_SITEMAP_DATE=2019-09-04T18:00:00+00:00--> 
  <!--Add here the additional properties that you want each page to possess.--> 
  <!--These properties can be used to change content in the template page or in the page itself as shown here.--> 
  <!--Properties must start with 'WRITEIT_POST'.--> 
  <!--Writeit provides and injects WRITEIT_POST_NAME and WRITEIT_POST_HTML_NAME by default.--> 
  <!--WRITEIT_POST_SHORT_DESCRIPTION=Have you ever asked yourself which algorithm is used by Swift's sorting method? There are many sorting algorithms out there, and chances are that you'll rarely have to use something other than the language's builtin sort() method. However, knowing the properties of the sorting algorithm built into your language is important if you want to prevent unwanted behaviors and nasty edge cases.--> 
  <title>Timsort and Introsort: Swift's Sorting Algorithms</title>  
 

<div class="blog-post"> 
 <div class="post-title-index">  
  <h1>Timsort and Introsort: Swift's Sorting Algorithms</h1>
 </div> 
 <div class="post-info"> 
  <div class="category category-compiler">
   Compiler
  </div> 
  <div class="category category-swift">
   Swift
  </div> 
  <div class="post-info-text">
   Published on 04 Sep 2019 
  </div> 
 </div>  
 <p>Have you ever asked yourself which algorithm is used by Swift's sorting method? There are many sorting algorithms out there, and chances are that you'll rarely have to use something other than the language's builtin <code>sort()</code> method. However, knowing the properties of the sorting algorithm built into your language is important if you want to prevent unwanted behaviors and nasty edge cases.</p>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>When analyzing sorting algorithms, you'll want to search for two properties:</p>
 <h2>1 - Sorting Stability</h2>
 <p>The <b>stability</b> of a sorting algorithm represents the ability of the algorithm to <b>maintain the original order of equal elements after sorting</b>. An <b>unstable</b> sorting algorithm has no guarantees that the order of equal elements in the unsorted array will stay the same after sorting, while a <b>stable</b> one guarantees that they will stay the same.</p>
 <p>This might sound weird, after all, if the elements are the same, why should I care about their overall order? This can be true if you're sorting elements by value, but when sorting elements by some arbitrary <b>priority</b>, using unstable algorithms can give you undesired results.</p>
 <p>Let's assume that we're building a music player, and our current task is to sort songs based on their popularity:</p>
 <pre>
<code>struct Music: Comparable, Equatable, CustomStringConvertible {</code>
<code>    let name: String</code>
<code>    let popularityValue: Int</code>
<code></code>
<code>    static func &lt; (lhs: Music, rhs: Music) -&gt; Bool {</code>
<code>        return lhs.popularityValue &lt; rhs.popularityValue</code>
<code>    }</code>
<code></code>
<code>    var description: String {</code>
<code>        return name</code>
<code>    }</code>
<code>}</code>
<code></code>
<code>var songs: [Music] = [</code>
<code>    Music(name: "I'm that swifty", popularityValue: 3),</code>
<code>    Music(name: "Swift boi", popularityValue: 5),</code>
<code>    Music(name: "Swift That Walk", popularityValue: 1),</code>
<code>    Music(name: "Too Swift", popularityValue: 5),</code>
<code>]</code>
</pre>
 <p>If we sort <code>songs</code> using Quicksort, we'll get the following result:</p>
 <pre>
<code>extension Array where Element: Equatable &amp; Comparable {</code>
<code>    func quicksort(comparison: ((Element, Element) -&gt; Bool)) -&gt; [Element] {</code>
<code>        var copy = self</code>
<code>        copy.quick(0, count - 1, comparison: comparison)</code>
<code>        return copy</code>
<code>    }</code>
<code></code>
<code>    mutating private func quick(_ i: Int, _ j: Int, comparison: ((Element, Element) -&gt; Bool)) {</code>
<code>        guard i &lt; j else {</code>
<code>            return</code>
<code>        }</code>
<code>        let pivot = partition(i, j, comparison: comparison)</code>
<code>        quick(i, pivot - 1, comparison: comparison)</code>
<code>        quick(pivot + 1, j, comparison: comparison)</code>
<code>    }</code>
<code></code>
<code>    mutating private func partition(_ i: Int, _ j: Int, comparison: ((Element, Element) -&gt; Bool)) -&gt; Int {</code>
<code>        let pivotElement = self[j]</code>
<code>        var indexToAdd = i - 1</code>
<code>        for k in i..&lt;j {</code>
<code>            if comparison(self[k], pivotElement) {</code>
<code>                indexToAdd += 1</code>
<code>                swapAt(indexToAdd, k)</code>
<code>            }</code>
<code>        }</code>
<code>        swapAt(indexToAdd + 1, j)</code>
<code>        return indexToAdd + 1</code>
<code>    }</code>
<code>}</code>
<code></code>
<code>songs = songs.quicksort {</code>
<code>    $0.popularityValue &gt; $1.popularityValue</code>
<code>}</code>
<code>print(songs)</code>
</pre>
 <pre>
<code>// [Too Swift, Swift boi, I'm that swifty, Swift That Walk]</code>
</pre>
 <p>Although <code>"Swift boi"</code> was placed before <code>"Too Swift"</code> in the original array, Quicksort changed their positions!</p>
 <p>That's not too bad though as we never actually used the unsorted version of the array. However, consider what happens if we re-sort the array multiple times:</p>
 <pre>
<code>songs = songs.quicksort {</code>
<code>    $0.popularityValue &gt; $1.popularityValue</code>
<code>}</code>
<code>print(songs)</code>
<code>songs = songs.quicksort {</code>
<code>    $0.popularityValue &gt; $1.popularityValue</code>
<code>}</code>
<code>print(songs)</code>
<code>songs = songs.quicksort {</code>
<code>    $0.popularityValue &gt; $1.popularityValue</code>
<code>}</code>
<code>print(songs)</code>
<code>songs = songs.quicksort {</code>
<code>    $0.popularityValue &gt; $1.popularityValue</code>
<code>}</code>
<code>print(songs)</code>
<code>songs = songs.quicksort {</code>
<code>    $0.popularityValue &gt; $1.popularityValue</code>
<code>}</code>
<code>print(songs)</code>
</pre>
 <pre>
<code>// [Too Swift, Swift boi, I'm that swifty, Swift That Walk]</code>
<code>// [Swift boi, Too Swift, I'm that swifty, Swift That Walk]</code>
<code>// [Too Swift, Swift boi, I'm that swifty, Swift That Walk]</code>
<code>// [Swift boi, Too Swift, I'm that swifty, Swift That Walk]</code>
<code>// [Too Swift, Swift boi, I'm that swifty, Swift That Walk]</code>
</pre>
 <p>Their relative order keeps changing!</p>
 <p>The reason is because Quicksort is an <b>unstable</b> sorting algorithm. If for some reason we needed to continuously update this list in the UI, the user would see songs changing positions in the ranking even though they have the same priority. That's not very good.</p>
 <p>To keep their order, we need to use a <b>stable</b> algorithm like <b>Mergesort</b>.</p>
 <pre>
<code>extension Array where Element: Equatable &amp; Comparable {</code>
<code>    func mergesort(comparison: ((Element, Element) -&gt; Bool)) -&gt; [Element] {</code>
<code>        return merge(0, count - 1, comparison: comparison)</code>
<code>    }</code>
<code></code>
<code>    private func merge(_ i: Int, _ j: Int, comparison: ((Element, Element) -&gt; Bool)) -&gt; [Element] {</code>
<code>        guard i &lt;= j else {</code>
<code>            return []</code>
<code>        }</code>
<code>        guard i != j else {</code>
<code>            return [self[i]]</code>
<code>        }</code>
<code>        let half = i + (j - i) / 2</code>
<code>        let left = merge(i, half, comparison: comparison)</code>
<code>        let right = merge(half + 1, j, comparison: comparison)</code>
<code>        var i1 = 0</code>
<code>        var i2 = 0</code>
<code>        var new = [Element]()</code>
<code>        new.reserveCapacity(left.count + right.count)</code>
<code>        while i1 &lt; left.count &amp;&amp; i2 &lt; right.count {</code>
<code>            if comparison(right[i2], left[i1]) {</code>
<code>                new.append(right[i2])</code>
<code>                i2 += 1</code>
<code>            } else {</code>
<code>                new.append(left[i1])</code>
<code>                i1 += 1</code>
<code>            }</code>
<code>        }</code>
<code>        while i1 &lt; left.count {</code>
<code>            new.append(left[i1])</code>
<code>            i1 += 1</code>
<code>        }</code>
<code>        while i2 &lt; right.count {</code>
<code>            new.append(right[i2])</code>
<code>            i2 += 1</code>
<code>        }</code>
<code>        return new</code>
<code>    }</code>
<code>}</code>
</pre>
 <pre>
<code>// [Swift boi, Too Swift, I'm that swifty, Swift That Walk]</code>
<code>// [Swift boi, Too Swift, I'm that swifty, Swift That Walk]</code>
<code>// [Swift boi, Too Swift, I'm that swifty, Swift That Walk]</code>
<code>// [Swift boi, Too Swift, I'm that swifty, Swift That Walk]</code>
<code>// [Swift boi, Too Swift, I'm that swifty, Swift That Walk]</code>
</pre>
 <h2>2 - Time/Space Complexity</h2>
 <p>The second important thing to be aware of is how much additional memory the algorithm takes to run and what are best/worst cases for the algorithm.</p>
 <p>My favorite example of this is <b>Counting Sort</b>: where an array is sorted by simply counting the occurrences of each element number of elements and then laying them out in order. If the difference between each value is small, say <code>[3,1,4,2,5]</code>, this algorithm can sort arrays in runtimes very close to <b>O(n)</b> -- but if the difference is big, like <code>[1,1000000000]</code>, Counting Sort will take an enormous amount of time to run even if the array is small.</p>
 <p>Likewise, the famous Quick Sort is highly regarded for being a fast and in-place O(n log n) algorithm in average, but it has a terrible worst case of O(n2) if the pivot is always the highest/smallest element in the partition. If you're dealing with large amounts of data or a constrained environment, there will be a specific sorting algorithm that best fits your needs.</p>
 <h2>Pre-Swift 5 Algorithm: Introsort</h2>
 <p>Before Swift 5, Swift's sorting algorithm was a hybrid algorithm called <b>Introsort</b>, which mixes the strengths of <code>Quicksort</code>, <code>Heapsort</code> and <code>Insertion Sort</code> into a single algorithm to guarantee a worse case of O(n log n).</p>
 <p>The idea behind Introsort is straightforward: First, if you have <b>less than 20 elements</b> in the partition being sorted, Insertion Sort is used. Although this algorithm has a worst case of O(n2), it also has a best case of O(n). Compared to the general O(n log n) algorithms, Insertion Sort will always perform better in small inputs.</p>
 <p>If the array is not small, Quicksort will be used. This will bring our best case to O(n log n), but also maintain the worst case of O(n2). However, Introsort can avoid it -- if the recursion tree for Quicksort gets too deep, the partition switches to Heapsort. In this case, "too deep" is considered as <code>2 * floor(log2(array.count))</code>.</p>
 <pre>
<code>internal mutating func _introSortImpl(within range: Range&lt;Index&gt;,</code>
<code>                                      by areInIncreasingOrder: (Element, Element) throws -&gt; Bool,</code>
<code>                                      depthLimit: Int) rethrows {</code>
<code>    // Insertion sort is better at handling smaller regions.</code>
<code>    if distance(from: range.lowerBound, to: range.upperBound) &lt; 20 {</code>
<code>        try _insertionSort(within: range, by: areInIncreasingOrder)</code>
<code>    } else if depthLimit == 0 {</code>
<code>        try _heapSort(within: range, by: areInIncreasingOrder)</code>
<code>    } else {</code>
<code>        // Partition and sort.</code>
<code>        // We don't check the depthLimit variable for underflow because this</code>
<code>        // variable is always greater than zero (see check above).</code>
<code>        let partIdx = try _partition(within: range, by: areInIncreasingOrder)</code>
<code>        try _introSortImpl(</code>
<code>            within: range.lowerBound..&lt;partIdx,</code>
<code>            by: areInIncreasingOrder,</code>
<code>            depthLimit: depthLimit &amp;- 1)</code>
<code>        try _introSortImpl(</code>
<code>            within: partIdx..&lt;range.upperBound,</code>
<code>            by: areInIncreasingOrder,</code>
<code>            depthLimit: depthLimit &amp;- 1)</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>Introsort greedily attempts to pick the best algorithm for the given situation, backing up to a different option when the previous choice goes wrong. It has a best case of O(n) and worst case of O(n log n), making it a decent one-size-fits-all algorithm.</p>
 <p>In terms of memory usage, it will perform slightly worse than the usual sorting algorithm. Although the three algorithms can sort inplace, Introsort's implementation in Swift was recursive. Since Swift doesn't guarantee that tail recursion calls will be optimized, running the builtin <code>sort()</code> pre-Swift 5 was not the best option if keeping memory usage low was important.</p>
 <p>The biggest thing to note is that Introsort was <b>unstable</b>. Although Insertion Sort is stable, the default implementation of Quicksort and Heapsort are not. If the order of equal elements was important, using <code>sort()</code> pre-Swift 5 was also not a good idea.</p>
 <h2>After Swift 5 - Timsort</h2>
 <p>Multiple threads surfaced between 2015 and 2018 about adding a stable sorting algorithm to Swift that didn't rely on recursion, but promising discussions first showed up only in the beginning of 2018. In October 2018, <a href="https://github.com/apple/swift/pull/19717">a pull request was finally merged</a> to change Introsort to a modified version of <b>Timsort.</b></p>
 <p>Timsort is a hybrid algorithm like Introsort, but with different approaches. It works by dividing an array into smaller sections, sorting these smaller sections with Insertion Sort, and then merging these sections together with Merge Sort. Because both Insertion Sort and Mergesort are stable, Timsort is <b>stable</b>, and while it also has a worst case of O(n log n) and non-constant space complexity, it tends to be considerably quicker than the more naive algorithms in real world scenarios. The reason why Timsort can be so fast is that although the description sounds simple enough, in reality each of these steps are highly tuned for efficiency.</p>
 <h3>Finding the next "run" (Partitioning)</h3>
 <p>Instead of dividing everything first and merging as the last step like Mergesort, Timsort scans the array once and progressively merge these regions (called "runs") as they are found.</p>
 <p>The beauty is that unlike Mergesort, a run isn't simply the array divided by half. Timsort abuses the fact that every array that you want to sort is likely to have a few contiguous subsequences that are <b>almost or already sorted</b>, which happens to be Insertion Sort's best case. To find the next run, Timsort will advance a pointer until the current sequence stops being an ascending/descending pattern:</p>
 <pre>
<code>[1, 2, 3, 1, 9, 6]</code>
<code> i     j</code>
</pre>
 <p><i>Note: This example is just for visual purposes -- because the array here is small, Timsort would just Insertion Sort it right away.</i></p>
 <p>The range from i to j defines our first run <b>run</b>, but the optimizations don't stop here.</p>
 <p>First: If the sequence is descending, we can already sort it in linear time by reversing the elements.</p>
 <p>Second: To increase the speed of Insertion Sort and to balance the amount of merge operations that will be done later, Timsort defines that every run should have a <b>minimum size</b> of a power of two between 16 and 128, or at least something very close to it. If the run that we found has a size smaller than the minimum run size, then the current run's range is expanded and sorted with Insertion Sort.</p>
 <pre>
<code>// Find the next consecutive run, reversing it if necessary.</code>
<code>var (end, descending) = try _findNextRun(in: self, from: start, by: areInIncreasingOrder)</code>
<code>if descending {</code>
<code>    _reverse(within: start..&lt;end)</code>
<code>}</code>
<code></code>
<code>// If the current run is shorter than the minimum length, use the</code>
<code>// insertion sort to extend it.</code>
<code>if end &lt; endIndex &amp;&amp; end - start &lt; minimumRunLength {</code>
<code>    let newEnd = Swift.min(endIndex, start + minimumRunLength)</code>
<code>    try _insertionSort(within: start..&lt;newEnd, sortedEnd: end, by: areInIncreasingOrder)</code>
<code>    end = newEnd</code>
<code>}</code>
</pre>
 <p>For the actual size, Swift specifically will pick a value between 32 and 64 that varies according to the size of the array. Finally, after a run is found, it's added to a stack containing all the other previous runs that we've found.</p>
 <h3>Merging runs</h3>
 <p>Every time a run is found, Timsort will attempt to collapse the top three runs of the stack into a single one by merging them together until the following conditions are satisfied:</p>
 <pre>
<code>runs.count &lt; 3 || runs[runs.count - 2].size &gt; (runs[runs.count - 1].size + runs.last!.count)</code>
<code>&amp;&amp;</code>
<code>runs.count &lt; 2 || runs[runs.count - 1].size &gt; runs.last!.size</code>
</pre>
 <p>This is done to reduce the amount of runs we have to remember, but mainly to balance the overall size of the runs as having them close together is beneficial for Timsort's merging phase.</p>
 <p>At first glance Timsort's merging phase works just like Mergesort: we compare a pair of elements from each array, picking the smallest one and moving it to its proper position in the final array.</p>
 <p>However, Timsort beautifully empowers the fact that if one specific array keeps "winning" the comparison, then it's likely to keep doing so. If this happens, instead of continuing to compare elements, we can simply binary search for the correct position of the element from the "losing" array in the "winning" one, moving all elements before it to the final array. This is called <b>galloping</b> and it saves us a lot of time by letting us skip comparing an entire chunk of the winning array.</p>
 <p>The galloping process can be aborted if the binary search process "loses" to the regular comparison process. <a href="https://bugs.python.org/file4451/timsort.txt">You can see all the optimizations that are done in the Timsort description.</a> Finally, after all runs were found, the remaining runs in the stack are progressively merged together until the entire array is sorted.</p>
 <p>The major differences in Swift is that the compiler's implementation of Timsort doesn't use galloping, and it attempts to collapse runs based on the last four runs instead of the last three. Still, it outperforms Introsort in pretty much every scenario.</p>
 <h2>Conclusion</h2>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>Timsort is one of the fastest sorting algorithms for real world problems. Knowing what algorithm your language uses can help you optimize your code by making better decisions based on what data you're handling.</p>
 <p>Follow me on my Twitter (<a href="https://twitter.com/rockbruno_">@rockbruno_</a>), and let me know of any suggestions and corrections you want to share.</p>
 <h2>References and Good reads</h2>
 <a href="https://forums.swift.org/t/starter-proposal-add-stable-sort-to-stdlib/9309">Stable Sort Proposal</a>
 <br>
 <a href="https://github.com/apple/swift/pull/19717">Stable Sort PR</a>
 <br>
 <a href="https://en.wikipedia.org/wiki/Introsort">Introsort</a>
 <br>
 <a href="https://svn.python.org/projects/python/trunk/Objects/listsort.txt">Timsort</a>
 <br>
 <a href="https://en.wikipedia.org/wiki/Timsort">Timsort (Wiki)</a>
</div>]]></description>
</item>
<item>
    <title>Advanced lldb tricks for Swift - Injecting and changing code on the fly</title>
    <link>https://swiftrocks.com/using-lldb-manually-xcode-console-tricks</link>
    <guid>https://swiftrocks.com/using-lldb-manually-xcode-console-tricks</guid>
    <pubDate>Thu, 8 Aug 2019 15:00:00 GMT-3</pubDate>
<description><![CDATA[
 
  
  <!--WRITEIT_POST_NAME=Advanced lldb tricks for Swift - Injecting and changing code on the fly--> 
  <!--WRITEIT_POST_HTML_NAME=using-lldb-manually-xcode-console-tricks--> 
  <!--WRITEIT_POST_SITEMAP_DATE_LAST_MOD=2020-04-12T14:00:00+02:00--> 
  <!--WRITEIT_POST_SITEMAP_DATE=2019-08-08T18:00:00+00:00--> 
  <!--Add here the additional properties that you want each page to possess.--> 
  <!--These properties can be used to change content in the template page or in the page itself as shown here.--> 
  <!--Properties must start with 'WRITEIT_POST'.--> 
  <!--Writeit provides and injects WRITEIT_POST_NAME and WRITEIT_POST_HTML_NAME by default.--> 
  <!--WRITEIT_POST_SHORT_DESCRIPTION=Not all Swift things are developed in Xcode -- things like the Swift Compiler or Apple's SourceKit-LSP work better through other means, and these means usually end up having you use lldb manually. Without Xcode to assist you, some of these tricks can prevent you from having to compile the app again to test certain changes.--> 
  <title>Advanced lldb tricks for Swift - Injecting and changing code on the fly</title>  
 

<div class="blog-post"> 
 <div class="post-title-index">  
  <h1>Advanced lldb tricks for Swift - Injecting and changing code on the fly</h1>
 </div> 
 <div class="post-info"> 
  <div class="category category-ios">
   iOS
  </div> 
  <div class="post-info-text">
   Published on 08 Aug 2019 
  </div> 
 </div>  
 <p>While Xcode provides several visual abstractions for lldb commands like adding breakpoints by clicking the lines of code and running by clicking the play button, lldb provides several useful commands that are not present in Xcode's UI. This can range from creating methods on the fly to even changing the CPU's registers to force a specific flow on the app without having to recompile it, and knowing them can greatly improve your debugging experience.</p>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>Not all Swift things are developed in Xcode -- things like the Swift Compiler or Apple's SourceKit-LSP work better through other means, and these means usually end up having you use lldb <b>manually.</b> Without Xcode to assist you, some of these tricks can prevent you from having to compile the app again to test certain changes.</p>
 <h2>Injecting properties and methods</h2>
 <p>You might already know <code>po</code> (short for "print object") -- the friendly command that is commonly used to print the contents of a property:</p>
 <pre>
<code>func foo() {</code>
<code>    var myProperty = 0</code>
<code>} // a breakpoint</code>
</pre>
 <pre class="command-line language-bash" data-host="SwiftRocks" , data-prompt="(lldb)" data-output="2-2">
<code>po myProperty</code>
<code>0</code>
</pre>
 <p>However, <code>po</code> is much more powerful than that -- despite the name implying that it prints things, <code>po</code> is an alias for <code>expression --object-description --</code>, an argumented version of the more raw <code>expression</code> (or just <code>e</code>) command that makes the output more swifty:</p>
 <pre class="command-line language-bash" data-host="SwiftRocks" , data-prompt="(lldb)" data-output="2-2">
<code>e myProperty</code>
<code>(Int) $R4 = 0 // not very pretty!</code>
</pre>
 <p>Because it's an alias, <code>po</code> can do everything that <code>e</code> can. <code>e</code> is meant for <b>evaluating expressions</b>, which can range from printing properties to changing their values and even defining new classes. As a simple use, we can change the value of a property in the code to force a new flow without recompiling the code:</p>
 <pre class="command-line language-bash" data-host="SwiftRocks" , data-prompt="(lldb)" data-output="2-2">
<code>po myProperty</code>
<code>0</code>
<code>po myProperty = 1</code>
<code>po myProperty</code>
<code>1</code>
</pre>
 <p>Besides that, if you write <code>po</code> alone, you'll be able to write a multiline expression like this. We can use this to create completely new methods and classes inside our debugging session:</p>
 <pre class="command-line language-bash" data-host="SwiftRocks" , data-prompt="(lldb)" data-output="2-7">
<code>po</code>
<code>Enter expressions, then terminate with an empty line to evaluate:</code>
<code>1 class $BreakpointUtils {</code>
<code>2     static var $counter = 0</code>
<code>3 }</code>
<code>4 func $increaseCounter() {</code>
<code>5     $BreakpointUtils.$counter += 1</code>
<code>6     print("Times I've hit this breakpoint: \($BreakpointUtils.$counter)")</code>
<code>7 }</code>
<code>8</code>
</pre>
 <p>(Dollar signs are used here to indicate that these properties and methods belong to lldb, and not the actual code.)</p>
 <p>The previous example allows me to call <code>$increaseCounter()</code> directly from lldb, which will add 1 to my "I can't handle this bug anymore" counter.</p>
 <pre class="command-line language-bash" data-host="SwiftRocks" , data-prompt="(lldb)" data-output="2-2">
<code>po $increaseCounter()</code>
<code>Times I've hit this breakpoint: 1</code>
<code>po $increaseCounter()</code>
<code>Times I've hit this breakpoint: 2</code>
</pre>
 <p>The ability to do this can be combined with lldb's ability to import <b>plugins</b>, which can considerably enhance your debugging experience. A good example of this is <a href="https://github.com/facebook/chisel">Chisel</a>, a tool made by Facebook that contains lots of lldb plugins -- like the <code>border</code> command, which adds a bright border to an <code>UIView</code> so you can quickly locate it on the screen, and they all work through clever usages of <code>e</code>/<code>po</code>.</p>
 <p>You can then use lldb's breakpoint actions to automatically trigger these methods whenever the breakpoint is hit. Combined with <code>po</code>'s property changing abilities, you can create special breakpoints that will alter the app's flow for the test you're trying to do.</p>
 <p>In general, all advanced breakpoint commands are extremely painful to write manually in lldb (which is why I'll avoid them in this article), but thankfully you can easily set breakpoint actions inside of Xcode:</p>
 <div class="post-image margin-top-40 margin-bottom-40"> 
  <img src="https://i.imgur.com/L6sIsZf.png" alt=""> 
 </div>
 <h3><code>v</code> - Avoiding <code>po</code>'s dynamic behavior</h3>
 <p>If you've used <code>po</code> for some time, you might've seen a cryptic error message like this in the past:</p>
 <pre>
<code>error: Couldn't lookup symbols:</code>
<code>$myProperty #1 : Swift.Int in __lldb_expr_26.$__lldb_expr(Swift.UnsafeMutablePointer&lt;Any&gt;) -&gt; ()</code>
</pre>
 <p>This is because <code>po</code> evaluates your code by compiling it, and unfortunately there are still cases where this can go wrong even though the code you're trying to access is correct.</p>
 <p>If you're dealing with something that doesn't need to be evaluated (like a static property instead of a method or closure), you can use the <code>v</code> command (short for <code>frame variable</code>) as an alternative to printing with <code>po</code> to instantly get the contents of an object.</p>
 <pre class="command-line language-bash" data-host="SwiftRocks" , data-prompt="(lldb)" data-output="2-2">
<code>v myProperty</code>
<code>(Int) myProperty = 1</code>
</pre>
 <h2><code>disassemble</code> - Breakpointing into memory addresses to change their contents</h2>
 <p><b>Note: The following commands are useful only in extreme cases. You won't learn a new Swift trick here, but you might learn something interesting about software engineering!</b></p>
 <p>I got into reverse engineering <a href="https://swiftrocks.com/reverse-engineering-ios-facebook-messenger-chat.html">by spelunking popular apps with a jailbroken iPad</a>, and when you do that, you don't have the option to recompile code -- you need to change it on the fly. For example, if I can't recompile the code, how can I force the following method to go inside the <code>isSubscribed</code> condition even though I'm not subscribed?</p>
 <pre>
<code>var isSubscribed = false</code>
<code></code>
<code>func run() {</code>
<code>    if isSubscribed {</code>
<code>        print("Subscribed!")</code>
<code>    } else {</code>
<code>        print("Not subscribed.")</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>We can this solve by playing with the app's memory -- inside any stack frame, you can call the <code>disassemble</code> command to see the full set of instructions for that stack:</p>
 <pre>
<code>myapp`run():</code>
<code>-&gt;  0x100000d60 &lt;+0&gt;:   push   rbp</code>
<code>    0x100000d61 &lt;+1&gt;:   mov    rbp, rsp</code>
<code>    0x100000d64 &lt;+4&gt;:   sub    rsp, 0x70</code>
<code>    0x100000d68 &lt;+8&gt;:   lea    rax, [rip + 0x319]</code>
<code>    0x100000d6f &lt;+15&gt;:  mov    ecx, 0x20</code>
<code>    ...</code>
<code>    0x100000d9c &lt;+60&gt;:  test   r8, 0x1</code>
<code>    0x100000da0 &lt;+64&gt;:  jne    0x100000da7</code>
<code>    0x100000da2 &lt;+66&gt;:  jmp    0x100000e3c</code>
<code>    0x100000da7 &lt;+71&gt;:  mov    eax, 0x1</code>
<code>    0x100000dac &lt;+76&gt;:  mov    edi, eax</code>
<code>    ...</code>
<code>    0x100000ec7 &lt;+359&gt;: call   0x100000f36</code>
<code>    0x100000ecc &lt;+364&gt;: add    rsp, 0x70</code>
<code>    0x100000ed0 &lt;+368&gt;: pop    rbp</code>
<code>    0x100000ed1 &lt;+369&gt;: ret</code>
</pre>
 <p>The neat thing here is not the command itself, but what you can do with this information. We're used to setting breakpoints to lines of code and specific selectors in Xcode, but inside lldb's console you can also breakpoint <b>specific memory addresses.</b></p>
 <p>We need to know a bit of assembly to solve this problem: If my code contains an <code>if</code>, then the resulting assembly of that code is certain to have a jump instruction. in this case, the jump instruction is <code>0x100000da0 &lt;+64&gt;: jne 0x100000da7</code>, which will jump to the memory address <code>0x100000da7</code> if the <code>r8</code> register (that is set in the previous <code>0x100000d9c &lt;+60&gt;: test r8, 0x1</code> instruction) is different than zero (so, true). As I'm not subscribed, <code>r8</code> will certainly be zero, which will prevent that instruction from being triggered.</p>
 <p>To see this happening and to fix it, let's first breakpoint and position the app at the <code>jne</code> instruction:</p>
 <pre class="command-line language-bash" data-host="SwiftRocks" , data-prompt="(lldb)" data-output="2-2">
<code>b 0x100000da0</code>
<code>continue</code>
<code>//Breakpoint hits the specific memory address</code>
</pre>
 <p>If I run <code>disassemble</code> again, the little arrow will show that we're at the correct memory address to begin the action.</p>
 <pre>
<code>-&gt; 0x100000da0 &lt;+64&gt;:  jne    0x100000da7</code>
</pre>
 <p>There are two ways to solve this problem:</p>
 <h3>Approach 1: Changing the content of CPU registers</h3>
 <p>The <code>register read</code> and <code>register write</code> commands are provided by lldb to allow you to inspect and change the contents of CPU registers, and the first way to solve this problem is to simply change the contents of <code>r8</code>.</p>
 <p>By being positioned at the <code>jne</code> instruction, <code>register read</code> will return the following:</p>
 <pre>
<code>General Purpose Registers:</code>
<code>       rax = 0x000000010295ddb0</code>
<code>       rbx = 0x0000000000000000</code>
<code>       rcx = 0x00007ffeefbff508</code>
<code>       rdx = 0x0000000000000000</code>
<code>       rdi = 0x00007ffeefbff508</code>
<code>       rsi = 0x0000000010000000</code>
<code>       rbp = 0x00007ffeefbff520</code>
<code>       rsp = 0x00007ffeefbff4b0</code>
<code>        r8 = 0x0000000000000000</code>
</pre>
 <p>Because <code>r8</code> is zero the <code>jne</code> instruction will not trigger, making the code output <code>"Not subscribed."</code>. However, this is an easy fix -- we can set <code>r8</code>to something that's not zero by running <code>register write</code> and resume the app:</p>
 <pre class="command-line language-bash" data-host="SwiftRocks" , data-prompt="(lldb)" data-output="2-2">
<code>register write r8 0x1</code>
<code>continue</code>
<code>"Subscribed!"</code>
</pre>
 <p>In regular day to day iOS development, <code>register write</code> can be used to replace entire objects in the code. If a method is going to return something you don't want, you can create a new object in lldb, get its memory address with <code>e</code> and inject it into the desired register.</p>
 <h3>Approach 2: Changing the instructions themselves</h3>
 <p>The second and possibly most insane way of solving this is by actually <b>rewriting the app itself on the fly</b>.</p>
 <p>Just like with registers, lldb provides <code>memory read</code> and <code>memory write</code> to allow you to change the contents of any memory addresses being used by your app. This can be used as an alternative way to change the contents of an property on the fly, but in this case, we can use it to change the <b>instructions themselves.</b></p>
 <p>Two things can be done here: If we want to reverse the logic of that if instruction, we can either change <code>test r8, 0x1</code> to <code>test r8, 0x0</code> (so it checks for a <code>false</code> condition instead), or <code>jne 0x100000da7</code> (jump not empty) to <code>je 0x100000da7</code> (jump empty, or <code>if !condition</code>). I find the latter easier, so that's what I'm going to follow. If we read the contents of that instruction, we'll see something like this:</p>
 <pre class="command-line language-bash" data-host="SwiftRocks" , data-prompt="(lldb)" data-output="2-2">
<code>memory read 0x100000da0</code>
<code>0x100000da0: 75 05 e9 95 00 00 00 b8 01 00 00 00 89 c7 e8 71</code>
</pre>
 <p>This looks crazy, but we don't need to understand all of it -- we just need to know that the OPCODE of the instruction corresponds to the two bits in the beginning (75). <a href="http://faydoc.tripod.com/cpu/je.htm">By following this chart</a>, we can see that the OPCODE for <code>je</code> is 74, so if we want to make <code>jne</code> become <code>je</code>, we need to swap the first two bits with 74.</p>
 <p>To do this, we can use <code>memory write</code> to write the exact same contents to that address, but with the first two bits changed to 74.</p>
 <pre class="command-line language-bash" data-host="SwiftRocks" , data-prompt="(lldb)">
<code>memory write 0x100000da0 74 05 e9 95 00 00 00 b8 01 00 00 00 89 c7 e8 71</code>
<code>dis</code>
</pre>
 <pre>
<code>...</code>
<code>0x100000da0 &lt;+64&gt;:  je     0x100000da7</code>
<code>...</code>
</pre>
 <p>Now, running the app will result in <code>"Subscribed!"</code> being printed.</p>
 <h2>Conclusion</h2>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>While disassembling and writing to memory might be too extreme for daily development, you can use some of the more advanced lldb tricks to increase your productivity. Changing properties, defining helper methods and mixing them with breakpoint actions will allow you to navigate and test your code faster without having you recompile it.</p>
 <p>Follow me on my Twitter (<a href="https://twitter.com/rockbruno_">@rockbruno_</a>), and let me know of any suggestions and corrections you want to share.</p>
 <h2>References and Good reads</h2>
 <a href="https://developer.apple.com/videos/play/wwdc2019/429/">Beyond po (WWDC 19)</a>
 <br>
 <a href="http://damnvulnerableiosapp.com/">Damn Vulnerable iOS App</a>
 <br>
</div>]]></description>
</item>
<item>
    <title>Swift ExpressibleBy protocols: What they are and how they work internally in the compiler</title>
    <link>https://swiftrocks.com/swift-expressibleby-protocols-how-they-work-internally-in-the-compiler</link>
    <guid>https://swiftrocks.com/swift-expressibleby-protocols-how-they-work-internally-in-the-compiler</guid>
    <pubDate>Wed, 17 Jul 2019 15:00:00 GMT-3</pubDate>
<description><![CDATA[
 
  
  <!--WRITEIT_POST_NAME=Swift ExpressibleBy protocols: What they are and how they work internally in the compiler--> 
  <!--WRITEIT_POST_HTML_NAME=swift-expressibleby-protocols-how-they-work-internally-in-the-compiler--> 
  <!--WRITEIT_POST_SITEMAP_DATE_LAST_MOD=2020-04-12T14:00:00+02:00--> 
  <!--WRITEIT_POST_SITEMAP_DATE=2019-07-17T18:00:00+00:00--> 
  <!--Add here the additional properties that you want each page to possess.--> 
  <!--These properties can be used to change content in the template page or in the page itself as shown here.--> 
  <!--Properties must start with 'WRITEIT_POST'.--> 
  <!--Writeit provides and injects WRITEIT_POST_NAME and WRITEIT_POST_HTML_NAME by default.--> 
  <!--WRITEIT_POST_SHORT_DESCRIPTION=ExpressibleBy represents a series of protocols in the Swift Standard library that allows you to instantiate objects directly from token literals. Let's see how it works.--> 
  <title>Swift ExpressibleBy protocols: What they are and how they work internally in the compiler</title>  
 

<div class="blog-post"> 
 <div class="post-title-index">  
  <h1>Swift ExpressibleBy protocols: What they are and how they work internally in the compiler</h1>
 </div> 
 <div class="post-info"> 
  <div class="category category-compiler">
   Compiler
  </div> 
  <div class="category category-swift">
   Swift
  </div> 
  <div class="post-info-text">
   Published on 17 Jul 2019 
  </div> 
 </div>  
 <p><code>ExpressibleBy</code> represents a series of protocols in the Swift Standard library that allows you to instantiate objects directly from token literals, like a string, a number, a floating-point and so on, if the object can be "expressed" like that. For example, here's the regular way of creating an URL in Swift:</p>
 <pre>
<code>func getURL() -&gt; URL</code>
<code>    return URL(string: "https://swiftrocks.com")!</code>
<code>}</code>
</pre>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>However, to prevent having to use this initializer everytime, you could say that it's possible to represent an URL directly from its URL string using <code>ExpressibleByStringLiteral</code>:</p>
 <pre>
<code>extension URL: ExpressibleByStringLiteral {</code>
<code>    public init(extendedGraphemeClusterLiteral value: String) {</code>
<code>        self = URL(string: value)!</code>
<code>    }</code>
<code></code>
<code>    public init(stringLiteral value: String) {</code>
<code>        self = URL(string: value)!</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>This allows us to refactor <code>getURL()</code> to create an URL using nothing else but a string token:</p>
 <pre>
<code>func getURL() -&gt; URL</code>
<code>    return "https://swiftrocks.com"</code>
<code>}</code>
</pre>
 <p>The standard library contains the following <code>ExpressibleBy</code> protocols:</p>
 <p>* <code>ExpressibleByNilLiteral</code>: Expressible by <code>nil</code>.<br> * <code>ExpressibleByIntegerLiteral</code>: Expressible by a number token like <code>10</code>.<br> * <code>ExpressibleByFloatLiteral</code>: Expressible by a floating-point token like <code>2.5</code>.<br> * <code>ExpressibleByBooleanLiteral</code>: Expressible by <code>true/false</code>.<br> * <code>ExpressibleByUnicodeScalarLiteral</code>: Expressible from a single unicode scalar. Usage examples of this are <code>Character</code> and <code>String</code>.<br> * <code>ExpressibleByExtendedGraphemeClusterLiteral</code>: Similar to UnicodeScalar, but consists of a chain of scalars (a grapheme cluster) instead of a single one.<br> * <code>ExpressibleByStringLiteral</code>: Expressible by a string token like <code>"SwiftRocks"</code>.<br> * <code>ExpressibleByArrayLiteral</code>: Expressible by an array token like <code>[1,2,3]</code>.<br> * <code>ExpressibleByDictionaryLiteral</code>: Expressible by a dictionary token like <code>["name": "SwiftRocks"]</code>.<br></p>
 <p>To make it short, you can use these protocols to hide unnecessary implementation details and possibly ugly initializers of your more complex types. An example use case is how Apple's SourceKit-LSP uses them to represent arbitrary arguments -- because the <code>Any</code> type does not conform to <code>Codable</code>, a <code>CommandArgumentType</code> enum is used to represent unknown arguments:</p>
 <pre>
<code>public enum CommandArgumentType: Hashable, ResponseType {</code>
<code>  case null</code>
<code>  case int(Int)</code>
<code>  case bool(Bool)</code>
<code>  case double(Double)</code>
<code>  case string(String)</code>
<code>  case array([CommandArgumentType])</code>
<code>  case dictionary([String: CommandArgumentType])</code>
<code>}</code>
</pre>
 <p>However, because we're dealing with an enum, representing an argument will result in not-so-pretty lines of code:</p>
 <pre>
<code>func getCommandArguments() -&gt; CommandArgumentType {</code>
<code>    return .dictionary(["line": .int(2),</code>
<code>                        "column": .int(1),</code>
<code>                        "name": .string("refactor"),</code>
<code>                        "args": .array([.string("file://a.swift"), .string("open")])])</code>
<code>}</code>
</pre>
 <p>Fortunately, we can use <code>ExpressibleBy</code> to provide better looking alternatives to the enum:</p>
 <pre>
<code>extension CommandArgumentType: ExpressibleByNilLiteral {</code>
<code>  public init(nilLiteral _: ()) {</code>
<code>    self = .null</code>
<code>  }</code>
<code>}</code>
<code></code>
<code>extension CommandArgumentType: ExpressibleByIntegerLiteral {</code>
<code>  public init(integerLiteral value: Int) {</code>
<code>    self = .int(value)</code>
<code>  }</code>
<code>}</code>
<code></code>
<code>extension CommandArgumentType: ExpressibleByBooleanLiteral {</code>
<code>  public init(booleanLiteral value: Bool) {</code>
<code>    self = .bool(value)</code>
<code>  }</code>
<code>}</code>
<code></code>
<code>extension CommandArgumentType: ExpressibleByFloatLiteral {</code>
<code>  public init(floatLiteral value: Double) {</code>
<code>    self = .double(value)</code>
<code>  }</code>
<code>}</code>
<code></code>
<code>extension CommandArgumentType: ExpressibleByStringLiteral {</code>
<code>  public init(extendedGraphemeClusterLiteral value: String) {</code>
<code>    self = .string(value)</code>
<code>  }</code>
<code></code>
<code>  public init(stringLiteral value: String) {</code>
<code>    self = .string(value)</code>
<code>  }</code>
<code>}</code>
<code></code>
<code>extension CommandArgumentType: ExpressibleByArrayLiteral {</code>
<code>  public init(arrayLiteral elements: CommandArgumentType...) {</code>
<code>    self = .array(elements)</code>
<code>  }</code>
<code>}</code>
<code></code>
<code>extension CommandArgumentType: ExpressibleByDictionaryLiteral {</code>
<code>  public init(dictionaryLiteral elements: (String, CommandArgumentType)...) {</code>
<code>    let dict  = [String: CommandArgumentType](elements, uniquingKeysWith: { first, _ in first })</code>
<code>    self = .dictionary(dict)</code>
<code>  }</code>
<code>}</code>
</pre>
 <p>Which allows us to rewrite <code>getCommandArguments()</code> with easier to read tokens.</p>
 <pre>
<code>func getCommandArguments() -&gt; CommandArgumentType {</code>
<code>    return ["line": 2,</code>
<code>            "column": 1,</code>
<code>            "name": "refactor",</code>
<code>            "args": ["file://a.swift", "open"]]</code>
<code>}</code>
</pre>
 <h2>How it works internally</h2>
 <p>But how can a token become a full type? As with all compiler magic, we can uncover what's going on by intercepting Swift's compilation steps.</p>
 <p>Using the first <code>getURL()</code> method as an example, let's first see how Swift treats ExpressibleBy objects. If we compile the code manually using <code>-emit-sil</code> argument, we can extract the Swift Intermediate Language (SIL) version of the code -- the final compilation step in Swift before LLVM takes the wheel.</p>
 <pre class="command-line language-bash" data-host="SwiftRocks">
<code>swiftc -emit-sil geturl.swift</code>
</pre>
 <p>The output, which I edited to make it easier to read, looks like this:</p>
 <pre>
<code>sil hidden @$s3bla6getURL10Foundation0C0VyF : $@convention(thin) () -&gt; @out URL {
bb0(%0 : $*URL):</code>
<code>  %1 = string_literal utf8 "https://swiftrocks.com"</code>
<code>  // removed: creating a String type from the string_literal</code>
<code>  // function_ref URL.init(stringLiteral:)</code>
<code>  %8 = function_ref @$s10Foundation3URLV3blaE13stringLiteralACSS_tcfC : $@convention(method) (@owned String, @thin URL.Type) -&gt; @out URL</code>
<code>  %9 = apply %8(%0, %6, %7) : $@convention(method) (@owned String, @thin URL.Type) -&gt; @out URL</code>
<code>  %10 = tuple ()</code>
<code>  return %10 : $()</code>
<code>} // end sil function '$s3bla6getURL10Foundation0C0VyF'</code>
</pre>
 <p>Here's what the method is doing:</p>
 <p>1: Create a <code>string_literal</code> token<br> 2: Create a <code>String</code> type from the literal<br> 3: Call <code>URL.init(stringLiteral:)</code> with the <code>String</code><br> 4: Return the URL</p>
 <p>As one would expect, the compiler achieves this magic by replacing the <code>String</code> line of code with the relevant <code>ExpressibleBy</code> initializer. Hooray for compiler magic!</p>
 <p>Now, to locate where this happens in the compiler, we can <code>grep</code> the Swift source for mentions of "ExpressibleBy", which will point us to several places inside <a href="https://github.com/apple/swift/blob/master/lib/Sema/CSApply.cpp#L1866">CSApply.cpp</a>. In short, all usages of literals get converted to their ExpressibleBy equivalent, including the "expressibles that are literals themselves" (for example, an <code>Int</code> is itself an <code>ExpressibleByIntegerLiteral</code>). When Swift's type-checker reaches a literal, it gets a hold of an instance of the relevant protocol type and the name of the initializer, which can be determined from the literal we're looking at:</p>
 <pre>
<code>Expr *visitNilLiteralExpr(NilLiteralExpr *expr) {</code>
<code>  auto type = simplifyType(cs.getType(expr));</code>
<code>  auto &amp;tc = cs.getTypeChecker();</code>
<code>  auto *protocol = tc.getProtocol(expr-&gt;getLoc(),</code>
<code>                                  KnownProtocolKind::ExpressibleByNilLiteral);</code>
<code>   DeclName initName(tc.Context, DeclBaseName::createConstructor(),</code>
<code>                     { tc.Context.Id_nilLiteral });</code>
<code> //...</code>
<code>}</code>
</pre>
 <p>With that info in hand, the type-checker calls <code>convertLiteralInPlace</code> to <a href="https://github.com/apple/swift/blob/master/lib/Sema/CSApply.cpp#L6679">replace the full expression with the equivalent ExpressibleBy initializer.</a> The method itself does a lot of stuff, but there's something interesting to note here: If we take a look at <a href="https://github.com/apple/swift/blob/1f9b86666f51bcdf0af0c8fff70bffb01126c7f6/include/swift/AST/KnownProtocols.def#L85">KnownProtocols.def</a>, we can see that all literals have default types:</p>
 <pre>
<code>EXPRESSIBLE_BY_LITERAL_PROTOCOL(ExpressibleByArrayLiteral, "Array", false)</code>
<code>EXPRESSIBLE_BY_LITERAL_PROTOCOL(ExpressibleByBooleanLiteral, "BooleanLiteralType", true)</code>
<code>EXPRESSIBLE_BY_LITERAL_PROTOCOL(ExpressibleByDictionaryLiteral, "Dictionary", false)</code>
<code>EXPRESSIBLE_BY_LITERAL_PROTOCOL(ExpressibleByExtendedGraphemeClusterLiteral, "ExtendedGraphemeClusterType", true)</code>
<code>EXPRESSIBLE_BY_LITERAL_PROTOCOL(ExpressibleByFloatLiteral, "FloatLiteralType", true)</code>
<code>EXPRESSIBLE_BY_LITERAL_PROTOCOL(ExpressibleByIntegerLiteral, "IntegerLiteralType", true)</code>
<code>EXPRESSIBLE_BY_LITERAL_PROTOCOL(ExpressibleByStringInterpolation, "StringLiteralType", true)</code>
<code>EXPRESSIBLE_BY_LITERAL_PROTOCOL(ExpressibleByStringLiteral, "StringLiteralType", true)</code>
<code>EXPRESSIBLE_BY_LITERAL_PROTOCOL(ExpressibleByNilLiteral, nullptr, false)</code>
<code>EXPRESSIBLE_BY_LITERAL_PROTOCOL(ExpressibleByUnicodeScalarLiteral, "UnicodeScalarType", true)</code>
</pre>
 <p>This means that if the expression has no type or has a type that doesn't conform to the protocol, the literal's true type will be assigned to the default's type conformance instead. For example, if I removed the conformance for <code>getURL()</code>, the SIL code will reveal that the internal <code>String</code> initializer is used instead:</p>
 <pre>
<code>func getURL() -&gt; URL {</code>
<code>    return String.init(_builtinStringLiteral: "https://swiftrocks.com")</code>
<code>}</code>
</pre>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>This not only allows you to write untyped expressions like <code>let foo = "bar"</code>, but it also serves for UI reasons - thanks to that, in a later pass the previous <code>getURL()</code> example will result in our user-friendly <code>Cannot convert value of type 'String' to specified type 'URL'</code> compilation error.</p>
 <p>Follow me on my Twitter (<a href="https://twitter.com/rockbruno_">@rockbruno_</a>), and let me know of any suggestions and corrections you want to share.</p>
 <h2>References and Good reads</h2>
 <a href="https://github.com/apple/swift">The Swift Source Code</a>
 <br>
</div>]]></description>
</item>
<item>
    <title>Useful (and obscure!) Foundation types in Swift</title>
    <link>https://swiftrocks.com/useful-obscure-foundation-types-in-swift</link>
    <guid>https://swiftrocks.com/useful-obscure-foundation-types-in-swift</guid>
    <pubDate>Wed, 26 Jun 2019 15:00:00 GMT-3</pubDate>
<description><![CDATA[
 
  
  <!--WRITEIT_POST_NAME=Useful (and obscure!) Foundation types in Swift--> 
  <!--WRITEIT_POST_HTML_NAME=useful-obscure-foundation-types-in-swift--> 
  <!--WRITEIT_POST_SITEMAP_DATE_LAST_MOD=2020-10-18T18:00:00+02:00--> 
  <!--WRITEIT_POST_SITEMAP_DATE=2019-06-26T18:00:00+00:00--> 
  <!--Add here the additional properties that you want each page to possess.--> 
  <!--These properties can be used to change content in the template page or in the page itself as shown here.--> 
  <!--Properties must start with 'WRITEIT_POST'.--> 
  <!--Writeit provides and injects WRITEIT_POST_NAME and WRITEIT_POST_HTML_NAME by default.--> 
  <!--WRITEIT_POST_SHORT_DESCRIPTION=The <code>Foundation</code> provides you a lot of the bread-and-butter needed for your daily iOS development, ranging from structures like <code>Data</code> all the way to complete APIs like <code>URLSession</code>. But as it turns out, we only use a fraction of what <code>Foundation</code> offers.--> 
  <title>Useful (and obscure!) Foundation types in Swift</title>  
 

<div class="blog-post"> 
 <div class="post-title-index">  
  <h1>Useful (and obscure!) Foundation types in Swift</h1>
 </div> 
 <div class="post-info"> 
  <div class="category category-ios">
   iOS
  </div> 
  <div class="post-info-text">
   Published on 26 Jun 2019 
  </div> 
 </div>   
 <p>The <code>Foundation</code> provides you a lot of the bread-and-butter needed for your daily iOS development, ranging from structures like <code>Data</code> all the way to complete APIs like <code>URLSession</code>. But as it turns out, we only use a fraction of what <code>Foundation</code> offers.</p>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>There's a bunch of Foundation types that are <b>so situational</b> that people doubt they even existed in the first place! In fact, they are so rarely mentioned as solutions to daily problems that developers may end up coding things that may <i>already</i> exist in these SDKs. But they do exist -- and although some of them are really old, most of these types are still very useful. Let's take a look at some of them!</p>
 <h2>NSScanner</h2>
 <p><code>NSScanner</code> can progressively extract numbers and strings from a base string, similarly to how <code>scanf</code> works in C:</p>
 <pre>
<code>public func extractIntsFrom(string: String) -&gt; [Int] {</code>
<code>    var result: [Int] = []</code>
<code>    let scanner = Scanner(string: string)</code>
<code>    // Jump over everything that isn't a number</code>
<code>    scanner.charactersToBeSkipped = CharacterSet.decimalDigits.inverted</code>
<code>    var pointer: Int = 0</code>
<code>    while scanner.isAtEnd == false {</code>
<code>        if scanner.scanInt(&amp;pointer) {</code>
<code>            result.append(pointer)</code>
<code>        }</code>
<code>    }</code>
<code>    return result</code>
<code>}</code>
<code></code>
<code>let string = "1M very L337 700"</code>
<code>let ints = extractIntsFrom(string: string)</code>
<code>// [1, 337, 700]</code>
</pre>
 <p>The scanner API has many variations like <code>scanString</code>, <code>scanDouble</code> and <code>scanHexInt</code>, and can be configured to scan at specific locations in a string or to take case sensitivity in consideration. This is a more direct and performant solution for searching occurrences of a string when you're looking for specific patterns such as something that resembles a number instead of a concrete match.</p>
 <p>You might notice that this API requires pointers which is an unfortunate side-effect of this being an old Obj-C API, but you can always abstract these types under extensions to make it look better for you and your colleagues.</p>
 <h2>NSCountedSet</h2>
 <p>There are many problems in programming that requires you to keep track of the quantity of a certain element, like the classic anagram interview problem:</p>
 <pre>
<code>func isAnagram(_ first: String, _ second: String) -&gt; Bool {</code>
<code>    guard first.count == second.count else {</code>
<code>        return false</code>
<code>    }</code>
<code>    var dict = [Character: Int]()</code>
<code>    for character in first {</code>
<code>        firstDict[character, default: 0] += 1</code>
<code>    }</code>
<code>    for character in second {</code>
<code>        dict[character, default: 0] -= 1</code>
<code>        if dict[character] == 0 {</code>
<code>            dict[character] = nil</code>
<code>        }</code>
<code>    }</code>
<code>    return dict.isEmpty</code>
<code>}</code>
</pre>
 <p>This is easy to solve with dictionaries with <code>Int</code> values, but we don't need to, because that's exactly what <code>NSCountedSet</code> does.</p>
 <pre>
<code>func isAnagram(_ first: String, _ second: String) -&gt; Bool {</code>
<code>    guard first.count == second.count else {</code>
<code>        return false</code>
<code>    }</code>
<code>    let countedSet = NSCountedSet(array: Array(first))</code>
<code>    for character in second {</code>
<code>        countedSet.remove(c)</code>
<code>    }</code>
<code>    return countedSet.count == 0</code>
<code>}</code>
</pre>
 <p>Elements can be repeatedly added to the set with <code>countedSet.add(element)</code> and have their counts inspected with <code>countedSet.count(element)</code>. If the count reaches zero, the element is removed from the set. However, just like a regular <code>Set</code> in Swift, you can only add one of each element to the set, which is great to avoid duplication.</p>
 <h2>NSCache</h2>
 <p><code>NSCache</code> is a collection type that works similarly to a dictionary, but it has two important key differences. First, it <b>does not</b> copy the key objects that are put into it, and second, it <b>automatically removes entries</b> from itself it the system is running out of memory.</p>
 <p>The actual policies for removing entries are cryptic, but if you have objects that expensive to create, usage of <code>NSCache</code> can be a very system friendly alternative to regular dictionary caches. Here's how it can be used for caching <code>UIImages</code>:</p>
 <pre>
<code>final class ImageDownloader {</code>
<code>    let client: HTTPClient</code>
<code>    let cache = NSCache&lt;NSString, NSData&gt;()</code>
<code></code>
<code>    init(client: HTTPClient) {</code>
<code>        self.client = client</code>
<code>    }</code>
<code></code>
<code>    func load(imageUrl: URL, intoImageView imageView: UIImageView) {</code>
<code>       let key = imageUrl.absoluteString as NSString</code>
<code>        func apply(data: NSData) {</code>
<code>            let image = UIImage(data: data as Data)</code>
<code>            imageView.image = image</code>
<code>        }</code>
<code>        if let cachedData = cache.object(forKey: key) {</code>
<code>            apply(data: cachedData)</code>
<code>            return</code>
<code>        } else {</code>
<code>            client.data(from: imageUrl) { data in</code>
<code>                cache.setObject(data as NSData, forKey: key)</code>
<code>                apply(data: data as NSData)</code>
<code>            }</code>
<code>        }</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>In this case, we can use <code>NSCache</code> as a very simple way of not having to download the same images over and over.</p>
 <h2>NSOrderedSet</h2>
 <p>Sets are great for keeping track of elements when duplication doesn't matter, but because set access is O(1), there's no guarantee that they will be ordered when you do so. As the name implies, <code>NSOrderedSet</code> works like a regular <code>Set</code> with the exception that the elements are <b>ordered</b>.</p>
 <pre>
<code>let set = NSMutableOrderedSet()</code>
<code>set.add(1)</code>
<code>set.add(4)</code>
<code>set.add(1)</code>
<code>set.add(1)</code>
<code>set.add(1)</code>
<code>set.add(6)</code>
<code>set.add(4)</code>
<code>set.add(6)</code>
<code>for a in set {</code>
<code>    print(a)</code>
<code>    // 1, 4, 6</code>
<code>}</code>
</pre>
 <p>Because this is an old type you'll notice that there's no generics in it -- all operations are based on the <code>Any</code> type. This isn't very Swifty, so you'll probably want to wrap it in a Swift type:</p>
 <pre>
<code>class OrderedSet&lt;T: Hashable&gt;: Sequence {</code>
<code>    private let _set = NSMutableOrderedSet()</code>
<code>    init() {}</code>
<code></code>
<code>    func makeIterator() -&gt; NSFastEnumerationIterator {</code>
<code>        return _set.makeIterator()</code>
<code>    }</code>
<code></code>
<code>    func add(_ element: T) {</code>
<code>        _set.add(element)</code>
<code>    }</code>
<code></code>
<code>    func remove(_ element: T) {</code>
<code>        _set.remove(element)</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>Like <code>NSCountedSet</code>, <code>NSOrderedSet</code> is a great tool when you want to have array-like functionality without allowing duplicate elements in it.</p>
 <h2>NSByteCountFormatter</h2>
 <p>There are tons of obscure formatters in Foundation, but <code>ByteCountFormatter</code> is one I specifically like. It formats byte counts into human readable file size formats, which is useful if your app downloads content as you don't need to calculate these values manually.</p>
 <pre>
<code>let bytes = 1024 * 1024</code>
<code>let formatter = ByteCountFormatter()</code>
<code>formatter.allowsNonnumericFormatting = false // Uses '0' instead of 'Zero'</code>
<code>formatter.countStyle = .file</code>
<code>let string = formatter.string(fromByteCount: Int64(bytes))</code>
<code>// 1 MB</code>
</pre>
 <h2>NSDataDetector</h2>
 <p><code>NSDataDetector</code> is similar to <code>NSScanner</code>, with the difference that it extracts <b>contextual</b> data from strings like phone numbers, addresses and links.</p>
 <pre>
<code>let string = "I write for https://swiftrocks.com and my phone is 555-111-111."</code>
<code>let range = NSRange(0..&lt;string.count)</code>
<code></code>
<code>let types: NSTextCheckingResult.CheckingType = [.link, .phoneNumber]</code>
<code>let dataDetector = try NSDataDetector(types: types.rawValue)</code>
<code>dataDetector.enumerateMatches(in: string, options: [], range: range) { (match, _, _) in</code>
<code>    guard let match = match else { return }</code>
<code>    switch match.resultType {</code>
<code>    case .link:</code>
<code>        print(match.url!)</code>
<code>        // https://swiftrocks.com</code>
<code>    case .phoneNumber:</code>
<code>        print(match.phoneNumber!)</code>
<code>        // "555-111-111"</code>
<code>    default:</code>
<code>        return</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>The downside is that it relies on Foundation's regex API, once again, because it's old. This is again not very Swifty, but <code>NSDataDetector</code> is still a very solid type if you need to extract such information.</p>
 <h2>CFBinaryHeap</h2>
 <p>The Swift Standard Library has a notorious lack of data structures (which the new Swift Algorithms package is trying to improve!), but you can find Tree and Heap implementations in Foundation in the shape of <code>CFTree</code> and <code>CFBinaryHeap</code>. Heaps are a very efficient way to implement priority queue structures, and since they're very extensive to code, <code>CFBinaryHeap</code> can save you some time.</p>
 <p>I'm adding it to the list because it's obscure and cool, but I have to say that it's unfortunately very hard to use. <code>CFBinaryHeap</code> is a C CoreFoundation class that isn't bridged to Foundation, so you won't be able to use without managing tons of pointers. Your best bet would be to write or use a wrapper like <a href="https://github.com/matthewcheok/MCBinaryHeap">MCBinaryHeap</a>.</p>
 <pre>
<code>let array = [8,3,5,4,1]</code>
<code>let heap = MCBinaryHeap(array: array)</code>
<code>heap?.popMinimumObject() // 1</code>
<code>heap?.popMinimumObject() // 3</code>
<code>heap?.popMinimumObject() // 4</code>
<code>heap?.popMinimumObject() // 5</code>
<code>heap?.popMinimumObject() // 8</code>
</pre>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>Priority queues are popular in graph searching problems and can be used to bring efficiency to anything where you need to keep track of the smallest or largest elements in an unordered array. It might take a while for you to find a use-case for priority queues or graph algorithms in general, but once you do, you'll realize that anything else would have been a giant performance issue. One example where I have personally applied graph algorithms in Swift is to resolve the dependencies of our app's dependency injection system for features.</p>
 <p>There are tons of useful types in Foundation and UIKit that we don't hear much of, but knowing them can help you prevent writing unnecessary code. Have fun with these types!</p>
 <h2>References and Good reads</h2>
 <a href="https://developer.apple.com/documentation/foundation/nsscanner">NSScanner</a>
 <br>
 <a href="https://developer.apple.com/documentation/foundation/nscountedset">NSCountedSet</a>
 <br>
 <a href="https://developer.apple.com/documentation/foundation/nsorderedset">NSOrderedSet</a>
 <br>
 <a href="https://developer.apple.com/documentation/foundation/nsbytecountformatter">NSByteCountFormatter</a>
 <br>
 <a href="https://developer.apple.com/documentation/foundation/nsorderedset">NSDataDetector</a>
 <br>
 <a href="https://developer.apple.com/documentation/foundation/nscache">NSCache</a>
 <br>
 <a href="https://developer.apple.com/documentation/corefoundation/cfbinaryheap">CFBinaryHeap</a>
 <br>
</div>]]></description>
</item>
<item>
    <title>Understanding Opaque Return Types in Swift</title>
    <link>https://swiftrocks.com/understanding-opaque-return-types-in-swift</link>
    <guid>https://swiftrocks.com/understanding-opaque-return-types-in-swift</guid>
    <pubDate>Mon, 10 Jun 2019 15:00:00 GMT-3</pubDate>
<description><![CDATA[
 
  
  <!--WRITEIT_POST_NAME=Understanding Opaque Return Types in Swift--> 
  <!--WRITEIT_POST_HTML_NAME=understanding-opaque-return-types-in-swift--> 
  <!--WRITEIT_POST_SITEMAP_DATE_LAST_MOD=2020-04-12T14:00:00+02:00--> 
  <!--WRITEIT_POST_SITEMAP_DATE=2019-06-10T18:00:00+00:00--> 
  <!--Add here the additional properties that you want each page to possess.--> 
  <!--These properties can be used to change content in the template page or in the page itself as shown here.--> 
  <!--Properties must start with 'WRITEIT_POST'.--> 
  <!--Writeit provides and injects WRITEIT_POST_NAME and WRITEIT_POST_HTML_NAME by default.--> 
  <!--WRITEIT_POST_SHORT_DESCRIPTION=Wondering why SwiftUI's return types are `some View`? Let's see what Opaque Return Types are and why they were added in Swift 5.1.--> 
  <title>Understanding Opaque Return Types in Swift</title>  
 

<div class="blog-post"> 
 <div class="post-title-index">  
  <h1>Understanding Opaque Return Types in Swift</h1>
 </div> 
 <div class="post-info"> 
  <div class="category category-compiler">
   Compiler
  </div> 
  <div class="category category-swift">
   Swift
  </div> 
  <div class="post-info-text">
   Published on 10 June 2019 
  </div> 
 </div>  
 <p><i>Why are SwiftUI's return types <code>some View</code>?</i><br> <i>Why can't it just return a regular protocol?</i><br> <i>What are Opaque Types?</i></p>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p><b>Opaque Return Types</b> is a feature added in Swift 5.1 that is a big part of the new SwiftUI framework's functionality. It comes to finally fix a fundamental problem of the usage of protocols and the design of Swift APIs, opening new possibilities for the creation and usage of public APIs.</p>
 <h2>Building APIs before Swift 5.1</h2>
 <p>To understand what Opaque Types are, let's see what possibilities we have today when building public APIs.</p>
 <p>Let's assume that we have a payments framework that has a method that returns the user's favorite credit card, which is a <code>CreditCard</code> <code>struct</code>:</p>
 <pre>
<code>public func favoriteCreditCard() -&gt; CreditCard {</code>
<code>    return getLastUsedCreditCard()</code>
<code>}</code>
</pre>
 <p>This can be fine for internal APIs, but for public frameworks this could be not ideal. The user might not need to have access to the <code>CreditCard</code> type itself -- it could contain information that we don't want the user to be playing with, like how hashing is performed.</p>
 <p>You can solve these by carefully choosing which methods are public and which ones are private, but what if you want to <b>completely</b> hide the existence of these types?</p>
 <p>Today, you can achieve this with the use of <b>protocols</b>, abstracting the implementation and type details into an unified name:</p>
 <pre>
<code>protocol PaymentType { /* ... */ }</code>
<code>struct CreditCard: PaymentType { /* ... */ }</code>
<code></code>
<code>public func favoriteCreditCard() -&gt; PaymentType {</code>
<code>    return getLastUsedCreditCard() // () -&gt; CreditCard</code>
<code>}</code>
</pre>
 <p>With this, we can even rewrite <code>favoriteCreditCard()</code> into a generic method that can return payment types that are not credit cards:</p>
 <pre>
<code>struct ApplePay: PaymentType { /* ... */ }</code>
<code></code>
<code>func favoritePaymentType() -&gt; PaymentType {</code>
<code>    if likesApplePay {</code>
<code>        return ApplePay()</code>
<code>    } else {</code>
<code>        return getLastUsedCreditCard()</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>Unfortunately, this usage of protocols has a major issue. Because Swift protocols discard the underlying identity of the type, if your protocol happens to have associated type/Self requirements like ones that inherit from <code>Equatable</code>, you won't be able to do this at all:</p>
 <pre>
<code>protocol PaymentType: Equatable { /* ... */ }</code>
<code></code>
<code>public func favoriteCreditCard() -&gt; PaymentType {</code>
<code>    return getLastUsedCreditCard() // () -&gt; CreditCard</code>
<code>}</code>
<code>// Error: Protocol 'PaymentType' can only be used as a generic constraint because it has Self or associated type requirements</code>
</pre>
 <p>This means that in the very least the API's user will never be able to directly compare two payment types, even if they are the same type underneath:</p>
 <pre>
<code>let creditCard = favoriteCreditCard()</code>
<code>let anotherCreditCard = mostRecentCreditCard()</code>
<code></code>
<code>creditCard == anotherCreditCard // `PaymentType` does not conform to Equatable.</code>
</pre>
 <p>Before Swift 5.1, the solution for this would be to hack your way around generics, turn everything into classes or use type erasure techniques, all of which would make the usage of the API more difficult and bring different types of problems into the app. For example, consider this method:</p>
 <pre>
<code>func getHashedCard() -&gt; HashedObject&lt;CreditCard&gt;</code>
</pre>
 <p>Usage of generics can solve this problem, but they can easily make the API harder to deal with. Perhaps the usage of <code>HashedObject</code> is important internally, but the user likely doesn't need to know about it -- it would be much better if this was returned as a simple <code>PaymentType</code> object instead, but the protocol limitations prevent it.</p>
 <h2>Opaque Return Types</h2>
 <p>The definite solution for this arrived in Swift 5.1 in the shape of <b>Opaque Return Types</b>. If you have a method that returns a concrete type masked as a protocol ‚Äî much like our <code>favoriteCreditCard()</code> example that returns a concrete <code>CreditCard</code> type masked as a not-too-useful <code>PaymentType</code> protocol, you can make use of <b>Opaque Return Types</b> by changing the return type to <code>some {type name}</code>:</p>
 <pre>
<code>public func favoriteCreditCard() -&gt; some PaymentType {</code>
<code>    return getLastUsedCreditCard() // () -&gt; CreditCard</code>
<code>}</code>
</pre>
 <p>When this is done, the return type of the method is going to be the actual <code>CreditCard</code> concrete type, but the compiler is going to <b>pretend</b> that it's the protocol instead. This means that while the API's user will see this as a regular protocol, it will have all the capabilities of the concrete type:</p>
 <pre>
<code>let creditCard = favoriteCreditCard() // 'some PaymentType' returning 'CreditCard'</code>
<code>let anotherCreditCard = mostRecentCreditCard() // 'some PaymentType' returning a 'CreditCard'</code>
<code></code>
<code>creditCard == anotherCreditCard // Now works, because two concrete CreditCards can be compared.</code>
</pre>
 <p>The reason this works is because you're looking at some fancy compiler magic ‚Äî <b>the return type was <code>CreditCard</code> all along, it's just being hidden from you for coding purposes.</b> This is what <code>favoriteCreditCard()</code> looks like after compiling:</p>
 <pre>
<code>let favoriteCreditCardMangledName = "$s3MyApp9favoriteCreditCardQryF"</code>
<code>public func favoriteCreditCard() -&gt; @_opaqueReturnTypeOf(favoriteCreditCardMangledName, 0) {</code>
<code>    return getLastUsedCreditCard() // () -&gt; CreditCard</code>
<code>}</code>
</pre>
 <p>All references to the <code>some PaymentType</code> return of <code>favoriteCreditCard()</code> are replaced with an internal attribute -- which during execution, will take an identifier and use it to provide <b>the actual return type</b>, <code>CreditCard</code>, stored in the metadata of the method's AST:</p>
 <pre>
<code>// The definition of favoriteCreditCard() contains:</code>
<code>(opaque_result_decl</code>
<code>  (opaque_type interface type='(some PaymentType).Type' naming_decl="favoritePaymentType()" underlying:</code>
<code>    substitution œÑ_0_0 -&gt; CreditCard)))</code>
</pre>
 <p>Thus, while in the IDE you'll be prevented from accessing specific <code>CreditCard</code> properties, in <b>runtime</b>, this:</p>
 <pre>
<code>public func favoriteCreditCard() -&gt; some PaymentType {</code>
<code>    return getLastUsedCreditCard() // () -&gt; CreditCard</code>
<code>}</code>
</pre>
 <p>Is the same as returning <code>CreditCard</code> directly.</p>
 <pre>
<code>public func favoriteCreditCard() -&gt; CreditCard {</code>
<code>    return getLastUsedCreditCard() // () -&gt; CreditCard</code>
<code>}</code>
</pre>
 <h2>Why is it useful?</h2>
 <p>The purpose of <b>Opaque Return Types</b> is to give API users' the capabilities of a concrete type without having to unnecessarily expose it. Sometimes, knowing the underlying type of a protocol isn't needed, but you need its capabilities to proceed. The PaymentType example might be too simple for it, so let's see how this could be applied to types with several internal helper types like <code>lazy</code> functions:</p>
 <pre>
<code>let lazyMap = [1,2,3].map { $0 * 2 }</code>
<code>let lazyFilter = lazyMap.filter { $0.isMultiple(of: 2) }</code>
<code>let lazyDrop = lazyFilter.drop { $0 != 2 }</code>
</pre>
 <p>The type of <code>lazyMap</code> is <code>LazyMapSequence&lt;[Int], Int&gt;</code>, the type of <code>lazyFilter</code> is <code>LazyFilterSequence&lt;LazyMapSequence&lt;[Int], Int&gt;&gt;</code>, and the type of <code>lazyDrop</code> is <code>LazyDropWhileSequence&lt;LazyFilterSequence&lt;LazyMapSequence&lt;[Int], Int&gt;&gt;&gt;</code>!</p>
 <p>Creating a method that returns the base <code>Sequence</code> protocol will prevent that method's user from using the full type's capabilities, but it would also be crazy to create a method that returns this ultra specific generic type -- the user likely doesn't care which inner helper types are composing this object. With opaque return types, you can safely return it as a normal <code>Sequence</code> type while still keeping the original type's capabilities.</p>
 <pre>
<code>func getLazyDrop() -&gt; some Sequence {</code>
<code>    let lazyMap = [1,2,3].lazy.map { $0 * 2 }</code>
<code>    let lazyFilter = lazyMap.filter { $0.isMultiple(of: 2) }</code>
<code>    let lazyDrop = lazyFilter.drop { $0 != 2 }</code>
<code>    return lazyDrop</code>
<code>}</code>
</pre>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>This is why SwiftUI screens return <code>some View</code> ‚Äî you need a concrete object for you to be able to compare, process and position them on the screen, but in most cases, it doesn't matter <b>what</b> the View really is, we just need to know that it is one. In the end, this is a tool meant to make your coding life easier.</p>
 <p>Follow me on my Twitter (<a href="https://twitter.com/rockbruno_">@rockbruno_</a>), and let me know of any suggestions and corrections you want to share.</p>
 <h2>References and Good reads</h2>
 <a href="https://developer.apple.com/videos/play/wwdc2019/402/">WWDC 2019: What's new in Swift</a>
 <br>
 <a href="https://github.com/apple/swift/pull/22072">Opaque Return Types Pull Request</a>
 <br>
</div>]]></description>
</item>
<item>
    <title>Inside SwiftUI's Declarative Syntax's Compiler Magic</title>
    <link>https://swiftrocks.com/inside-swiftui-compiler-magic</link>
    <guid>https://swiftrocks.com/inside-swiftui-compiler-magic</guid>
    <pubDate>Tue, 4 Jun 2019 15:00:00 GMT-3</pubDate>
<description><![CDATA[
 
  
  <!--WRITEIT_POST_NAME=Inside SwiftUI's Declarative Syntax's Compiler Magic--> 
  <!--WRITEIT_POST_HTML_NAME=inside-swiftui-compiler-magic--> 
  <!--WRITEIT_POST_SITEMAP_DATE_LAST_MOD=2020-04-12T14:00:00+02:00--> 
  <!--WRITEIT_POST_SITEMAP_DATE=2019-06-04T18:00:00+00:00--> 
  <!--Add here the additional properties that you want each page to possess.--> 
  <!--These properties can be used to change content in the template page or in the page itself as shown here.--> 
  <!--Properties must start with 'WRITEIT_POST'.--> 
  <!--Writeit provides and injects WRITEIT_POST_NAME and WRITEIT_POST_HTML_NAME by default.--> 
  <!--WRITEIT_POST_SHORT_DESCRIPTION=SwiftUI is a revolutionary framework announced by Apple in WWDC 2019 and you might've noticed that it looks pretty different from regular Swift. Let's see why.--> 
  <title>Inside SwiftUI's Declarative Syntax's Compiler Magic</title>  
 

<div class="blog-post"> 
 <div class="post-title-index">  
  <h1>Inside SwiftUI's Declarative Syntax's Compiler Magic</h1>
 </div> 
 <div class="post-info"> 
  <div class="category category-compiler">
   Compiler
  </div> 
  <div class="category category-swiftui">
   SwiftUI
  </div> 
  <div class="post-info-text">
   Published on 04 Jun 2019 
  </div> 
 </div>   
 <p>Announced in WWDC 2019, SwiftUI is an incredible UI building framework that might forever change how iOS apps are made. For years we've engaged in the war of writing views via Storyboard or View Code, and SwiftUI seems to finally end this. With its release, not only Storyboards are now pretty much irrelevant, but the old fashioned View Code is also very threatened as SwiftUI mixes the best of both worlds.</p>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>With this new framework, you can use Xcode to define your screens visually just like in Storyboards -- but instead of generating unreadable XML files, it generates code:</p>
 <div class="post-image margin-top-40 margin-bottom-40"> 
  <img src="https://i.imgur.com/NfE8605.png" alt=""> 
 </div>
 <p>If that wasn't crazy enough, changes to the code will update a live preview in real time, bringing to Xcode a long requested feature.</p>
 <p>But the part that interests me most is that if you take a look at the SwiftUI examples, you'll see that almost appear to make no sense at all in current Swift -- how the hell can a bunch of seemingly disconnected <code>View</code> properties result in a complete screen?</p>
 <pre>
<code>struct LandmarkList: View {</code>
<code>    @State var showFavoritesOnly = true</code>
<code></code>
<code>    var body: some View {</code>
<code>        NavigationView {</code>
<code>            List {</code>
<code>                Toggle(isOn: $showFavoritesOnly) {</code>
<code>                    Text("Favorites only")</code>
<code>                }</code>
<code></code>
<code>                ForEach(landmarkData) { landmark in</code>
<code>                    if !self.showFavoritesOnly || landmark.isFavorite {</code>
<code>                        NavigationButton(destination: LandmarkDetail(landmark: landmark)) {</code>
<code>                            LandmarkRow(landmark: landmark)</code>
<code>                        }</code>
<code>                    }</code>
<code>                }</code>
<code>            }</code>
<code>            .navigationBarTitle(Text("Landmarks"))</code>
<code>        )</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>Having strong support for declarative programming paradigms (where you describe what you want instead of explicitly coding it) was always a goal of Swift, and the release of SwiftUI is finally applying this concept. However, Swift doesn't have these features <i>yet</i>; The reason the previous example works is that SwiftUI is powered by tons of compiler features -- some of them coming in Swift 5.1, and others that still aren't officially part of Swift. As always, I investigated that out.</p>
 <h2>Return-less single expressions</h2>
 <p>You might have noticed that although <code>body</code> returns a <code>View</code>, there's no <code>return</code> statement! Swift 5.1 introduces return-less single expressions, where closures consisting of only one expression are allowed to omit the <code>return</code> statement for visual purposes. The way it works is what you'd expect: when the compiler is parsing a function body and notices it only has a single statement, it injects a <code>return</code> token in the tree. <a href="https://github.com/apple/swift/blob/0dc0b035218ca4412cbebd2a4d61a019b6b71ea0/lib/Parse/ParseDecl.cpp#L5683">Check it out here.</a></p>
 <pre>
<code>auto RS = new (Context) ReturnStmt(SourceLoc(), E);</code>
<code>BS-&gt;setElement(0, RS);</code>
<code>AFD-&gt;setHasSingleExpressionBody();</code>
<code>AFD-&gt;setSingleExpressionBody(E);</code>
</pre>
 <p>Although I personally think that this can be a little confusing (but I haven't used it much, so I might change my mind), this is really great to bring the declarative feeling into the language.</p>
 <h2>Property Delegates</h2>
 <p>One of the most interesting features of SwiftUI is how changing the state of your view can trigger a full UI reload of it. This is enabled by the fact that Xcode 11 adds the <a href="https://developer.apple.com/documentation/combine">Combine</a> framework, officially bringing tons of Reactive concepts to iOS in the shape of declarative Swift APIs. However, what's cooler isn't these concepts themselves, but how they are applied. The previous example contains this line:</p>
 <pre>
<code>@State var showFavoritesOnly = false</code>
</pre>
 <p>Because this property is marked with the <code>@State</code> attribute, changing it triggers <code>body</code>, resulting in a new <code>View</code> being drawn in the screen.</p>
 <p>This attribute isn't available in Swift itself, but it relates to a compiler feature that is currently under discussion to be added officially into the language: <b>property delegates.</b></p>
 <p>Sometimes, we want to add more complex pieces of logic to a property that doesn't really justify the use of a new type, at least not that in that scope. This can with the <code>get/set/willSet/didSet</code> property observers, like in the classic <code>UserDefaults</code> example:</p>
 <pre>
<code>var isFirstBoot: Bool {</code>
<code>    get {</code>
<code>        return UserDefaults.standard.object(forKey: key) as? Bool ?? false</code>
<code>    } set {</code>
<code>      UserDefaults.standard.set(newValue, forKey: "isFirstBoot")</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>This example is simple enough to work, but it's not difficult to see how bloated this gets if you do something more complex, like manually implementing the <code>lazy</code> logic:</p>
 <pre>
<code>private var _foo: Int?</code>
<code>var lazyFoo: Int {</code>
<code>    get {</code>
<code>        if let value = _foo { return value }</code>
<code>        let initialValue = 1738</code>
<code>        _foo = initialValue</code>
<code>        return initialValue</code>
<code>    } set {</code>
<code>        _foo = newValue</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>In current Swift your only choice would be to wrap this inside a <code>Lazy&lt;T&gt;</code> generic type, which visually doesn't fit SwiftUI's declarative programming style. In response, the <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0258-property-delegates.md">Property Delegates</a> proposal was created in April 2019. This compiler feature isn't officially added to the language yet, but it's already being used as part of SwiftUI. Its purpose is to do exactly what we have to do in current Swift, but visually <b>abstracting it from the user</b>.</p>
 <p>When creating generic types, you can now add the <code>@propertyDelegate</code> attribute to its declaration to make it <b>usable as an attribute:</b></p>
 <pre>
<code>@propertyDelegate class UserDefault&lt;T&gt; {</code>
<code>    let key: String</code>
<code>    let defaultValue: T</code>
<code></code>
<code>    var value: T {</code>
<code>        get {</code>
<code>            return UserDefaults.standard.object(forKey: key) as? T ?? defaultValue</code>
<code>        } set {</code>
<code>            UserDefaults.standard.set(newValue, forKey: key)</code>
<code>        }</code>
<code>    }</code>
<code>}</code>
</pre>
 <p><b>Update: It appears that the official Swift 5.1 name for this attribute is going to be <code>@propertyWrapper</code>, but the SwiftUI beta is using <code>@propertyDelegate</code> so I'm using this one.</b></p>
 <p>I can now use <code>isFirstBoot</code> as follows:</p>
 <pre>
<code>@UserDefault(key: "isFirstBoot", defaultValue: false) var isFirstBoot: Bool</code>
</pre>
 <p>This allows you to interface with the complex generic type, but visually see nothing but a regular <code>Bool</code> property, As stated, the attribute empowers compiler magic to abstract the creation of the original generic type. Because the full implementation of it deserves an <code>How 'x' Works Internally in Swift</code> article of its own, we'll jump to the interesting parts -- with property delegates, the compiler translates the previous declaration to this:</p>
 <pre>
<code>var $isFirstBoot: UserDefaults&lt;Bool&gt; = UserDefaults&lt;Bool&gt;(key: "isFirstBoot", defaultValue: false)</code>
<code>var isFirstBoot: Bool {</code>
<code>  get { return $isFirstBoot.value }</code>
<code>  set { $isFirstBoot.value = newValue }</code>
<code>}</code>
</pre>
 <p>The use of <code>$</code> as a prefix is on purpose; Even though <code>isFirstBoot</code> is a <code>Bool</code>, I might still want to access properties and methods from the more complex generic type. Although the original property is hidden, you can still access it for this purpose. For example, here's an example where <code>UserDefault</code> has a method for returning it to the default value:</p>
 <pre>
<code>extension UserDefault {</code>
<code>    func reset() {</code>
<code>        value = defaultValue</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>Although <code>Bool</code> won't have this property, I can use it from <code>$isFirstBoot</code>:</p>
 <pre>
<code>$isFirstBoot.reset()</code>
</pre>
 <p>This is why <code>Toggle(isOn: $showFavoritesOnly)</code> in SwiftUI's example use <code>$</code>: it doesn't want the actual <code>Bool</code>, but the <code>Binding</code> property provided by the <code>State</code> property delegate struct which will be able to trigger a view reload when it changes.</p>
 <pre>
<code>/// A linked View property that instantiates a persistent state</code>
<code>/// value of type `Value`, allowing the view to read and update its</code>
<code>/// value.</code>
<code>@available(iOS 13.0, OSX 10.15, tvOS 13.0, watchOS 6.0, *)</code>
<code>@propertyDelegate public struct State&lt;Value&gt; : DynamicViewProperty, BindingConvertible {</code>
<code></code>
<code>    /// Initialize with the provided initial value.</code>
<code>    public init(initialValue value: Value)</code>
<code></code>
<code>    /// The current state value.</code>
<code>    public var value: Value { get nonmutating set }</code>
<code></code>
<code>    /// Returns a binding referencing the state value.</code>
<code>    public var binding: Binding&lt;Value&gt; { get }</code>
<code></code>
<code>    /// Produces the binding referencing this state value</code>
<code>    public var delegateValue: Binding&lt;Value&gt; { get }</code>
<code></code>
<code>    /// Produces the binding referencing this state value</code>
<code>    /// TODO: old name for storageValue, to be removed</code>
<code>    public var storageValue: Binding&lt;Value&gt; { get }</code>
<code>}</code>
</pre>
 <h2>Function Builders</h2>
 <p>We've seen how single expression don't need to add <code>return</code> statements, but what the hell is going on here?</p>
 <pre>
<code>HStack {</code>
<code>   Text("Hi")</code>
<code>   Text("Swift")</code>
<code>   Text("Rocks")</code>
<code>}</code>
</pre>
 <p>This will result in a nice horizontal stack with three labels, but all we did was instantiate them! How could they be added to the view?</p>
 <p>The answer to this is perhaps the most groundbreaking change in SwiftUI -- <b>function builders.</b></p>
 <p>The function builders feature pitch was introduced to the Swift community right after SwiftUI was released, allowing Swift to abstract factory patterns into a clean visual declarative expression. All indicates that it'll be part of Swift itself very soon, but for now you can try it as part of SwiftUI.</p>
 <p>Function builders relate to types that, given a closure, can retrieve a sequence of statements and abstract the creation of something more concrete based on them.</p>
 <p><code>HStack</code> can do this because it has the <code>ViewBuilder</code> function builder in its signature:</p>
 <pre>
<code>public init(..., content: @ViewBuilder () -&gt; Content)</code>
<code>//Note: The official docs won't show the attribute, and I'm not sure why,</code>
<code>//but you can confirm it has it by adding a normal expression `let a = 1` expression inside of the closure.</code>
<code>//It will give you a compilation error.</code>
</pre>
 <p><code>@ViewBuilder</code> translates to the <code>ViewBuilder</code> struct: a <b>function builder</b> that can transform view expressions into actual views. Function builders are determined by the <code>@_functionBuilder</code> attribute (with an underline because we're not supposed to use it manually yet) and a series of methods that determine how expressions should be parsed:</p>
 <pre>
<code>@_functionBuilder public struct ViewBuilder {</code>
<code></code>
<code>    /// Builds an empty view from an block containing no statements, `{ }`.</code>
<code>    public static func buildBlock() -&gt; EmptyView</code>
<code></code>
<code>    /// Passes a single view written as a child view (e..g, `{ Text("Hello") }`) through</code>
<code>    /// unmodified.</code>
<code>    public static func buildBlock
   <content>
    (_ content: Content) -&gt; Content where Content : View
   </content></code>
<code>    // Not here: Another 9 buildBlock methods with increasing amount of generic parameters</code>
<code>}</code>
</pre>
 <p>We don't really know what's going on inside these methods as they are internal to SwiftUI, but we know the compiler magic behind it. That example will result in the following:</p>
 <pre>
<code>HStack {</code>
<code>   return ViewBuilder.buildBlock(Text("Hi"), Text("Swift"), Text("Rocks"))</code>
<code>}</code>
</pre>
 <p>The more complex the block, the more complex the magic'd expression is. The important thing here is that function builders block can <b>only contain content that is understandable by the builder.</b> For example, you can only add an <code>if</code> statement to <code>HStack</code> because it contains the related <code>buildIf()</code> method from the attribute. If you want an example of something that doesn't work, try the following:</p>
 <pre>
<code>HStack {</code>
<code>    let a = 1 //Closure containing a declaration cannot be used with function builder 'ViewBuilder'</code>
<code>    Text("a")</code>
<code>}</code>
</pre>
 <p>The purpose of this feature is to enable the creation of embedded DSLs in Swift -- allowing you to define content that gets translated to something else down the line, but it plays a big role in giving the declarative programming feeling to Swift. Here's how building a HTML page can look with this function builders:</p>
 <pre>
<code>div {</code>
<code>    p {</code>
<code>        "Call me Ishmael. Some years ago"</code>
<code>    }</code>
<code>    p {</code>
<code>        "There is now your insular city"</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>The version of the feature inside Xcode 11 is internal and has less features than the proposed Swift version, and thus shouldn't be used manually until it's officially added into the language.</p>
 <h2>Conclusion</h2>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>SwiftUI has just been announced and it's already causing a huge impact. The new Swift features that are spawning out it are also game changing, and I for one am ready for the addition of new compiler black magics into Swift.</p>
 <p>Follow me on my Twitter (<a href="https://twitter.com/rockbruno_">@rockbruno_</a>), and let me know of any suggestions and corrections you want to share.</p>
 <h2>References and Good reads</h2>
 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0258-property-delegates.md">SE-0258: Property Delegates</a>
 <br>
 <a href="https://github.com/apple/swift/pull/23251">Original Returnless Expressions PR</a>
 <br>
 <a href="https://forums.swift.org/t/pitch-function-builders/25167">Function Builders Pitch</a>
 <br>
</div>]]></description>
</item>
<item>
    <title>autoreleasepool uses in Swift</title>
    <link>https://swiftrocks.com/autoreleasepool-in-swift</link>
    <guid>https://swiftrocks.com/autoreleasepool-in-swift</guid>
    <pubDate>Wed, 22 May 2019 15:00:00 GMT-3</pubDate>
<description><![CDATA[
 
  
  <!--WRITEIT_POST_NAME=autoreleasepool uses in Swift--> 
  <!--WRITEIT_POST_HTML_NAME=autoreleasepool-in-swift--> 
  <!--WRITEIT_POST_SITEMAP_DATE_LAST_MOD=2020-04-12T14:00:00+02:00--> 
  <!--WRITEIT_POST_SITEMAP_DATE=2019-05-22T18:00:00+00:00--> 
  <!--Add here the additional properties that you want each page to possess.--> 
  <!--These properties can be used to change content in the template page or in the page itself as shown here.--> 
  <!--Properties must start with 'WRITEIT_POST'.--> 
  <!--Writeit provides and injects WRITEIT_POST_NAME and WRITEIT_POST_HTML_NAME by default.--> 
  <!--WRITEIT_POST_SHORT_DESCRIPTION=NSAutoreleasePool was very important during the Obj-C era. Let's see cases where it's still useful in Swift.--> 
  <title>autoreleasepool uses in Swift</title>  
 

<div class="blog-post"> 
 <div class="post-title-index">  
  <h1>autoreleasepool uses in Swift</h1>
 </div> 
 <div class="post-info"> 
  <div class="category category-swift">
   Swift
  </div> 
  <div class="post-info-text">
   Published on 22 May 2019 
  </div> 
 </div>   
 <p>Foundation's <code>NSAutoreleasePool</code> type, later abstracted to the <code>@autoreleasepool</code> block, is a very old concept in iOS development. During the Obj-C era of iOS, usage of this type was important to prevent your app's memory from blowing up in specific cases. As ARC and Swift came around and evolved, very few people still have to manually play around with memory, making seeing it become a rare occurrence.</p>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>Having developed tools that need to allocate enourmous amounts of memory, I asked myself if there's still a case where <code>@autoreleasepool</code> is useful in Swift. Here are the answers.</p>
 <h2>What is <code>@autoreleasepool</code>? (Objective-C)</h2>
 <p>In the pre-ARC Obj-C days of manual memory management, <code>retain()</code> and <code>release()</code> had to be used to control the memory flow of an iOS app. As iOS's memory management works based on the retain count of an object, users could use these methods to signal how many times an object is being referenced so it can be safely dealloced if this value ever reaches zero.</p>
 <p>However, consider the following situation where we have a <code>getCoolLabel</code> method that someone can use to get a really cool label:</p>
 <pre>
<code>-(NSString *)getCoolLabel {</code>
<code>    NSString *label = [[NSString alloc] initWithString:@"SwiftRocks"];</code>
<code>    return label;</code>
<code>}</code>
</pre>
 <p><code>NSString alloc</code> automatically calls <code>retain()</code> to make sure <code>label</code> is able to exist (retain count of 1), and the label is then returned to someone else that wants to reference it, retaining it again (retain count 2) until nobody uses it anymore.</p>
 <p>But there's a huge problem here. After the stack that called <code>getCoolLabel</code> calls <code>release()</code> to signal that it doesn't need it anymore, the retain count won't be 0, but 1. The internal <code>NSString *label</code> that was created to hold is <b>also</b> retaining it, and it needs to be released as well if we want the NSString itself to dealloc. The thing is, as <code>label</code> is unreachable outside of this method, there's no way we can release it:</p>
 <pre>
<code>-(NSString *)getCoolLabel {</code>
<code>    NSString *label = [[NSString alloc] initWithString:@"SwiftRocks"];</code>
<code>    [label release]; // Oopsie, nope!</code>
<code>    return label;</code>
<code>    [label release]; // Oopsie, nope!</code>
<code>}</code>
</pre>
 <p>If <code>release()</code> is called before <code>return</code>, the NSString will dealloc before it can be used which will crash the app, and calling after <code>return</code> means it will never be executed, causing a memory leak.</p>
 <p>The solution for this edge case is to use a neat method called <code>autorelease()</code>:</p>
 <pre>
<code>-(NSString *)getCoolLabel {</code>
<code>    NSString *label = [[NSString alloc] initWithString:@"SwiftRocks"];</code>
<code>    return [label autorelease];</code>
<code>}</code>
</pre>
 <p>Instead of instantly reducing the retain count of an object, <code>autorelease()</code> adds the object to a pool of objects that need to be released <b>sometime in the future, but not now.</b> By default, the pool will release these objects at the end of the run loop of the thread being executed, which is more than enough time to cover all usages of <code>getCoolLabel()</code> without causing memory leaks. Great, right?</p>
 <p>Well, kinda. This will indeed solve your problem in 99% of the times, but consider this:</p>
 <pre>
<code>-(void)emojifyAllFiles {</code>
<code>    int numberOfFiles = 1000000;</code>
<code>    for(i=0;i&lt;numberOfFiles;i++) {</code>
<code>        NSString *contents = [self getFileContents:files[i]];</code>
<code>        NSString *emojified = [contents emojified];</code>
<code>        [self writeContents:contents toFile:files[i]];</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>Assuming that <code>getFileContents</code> and <code>emojified</code> return autoreleased instances, the app will be holding <b>two million</b> instances of NSStrings <b>at once</b> even though the individual properties could be safely released after their respective loops!</p>
 <div class="post-image margin-top-40 margin-bottom-40"> 
  <img src="https://i.imgur.com/ztWib4b.png" alt=""> 
 </div>
 <p>Because <code>autorelease</code> defers the release of these objects, they will only be released after the run loop ends -- which is way after the execution of <code>emojifyAllFiles</code>. If the contents of these files are large, this would cause serious issues if not crash the app entirely.</p>
 <p>The solution to prevent this is the <code>@autoreleasepool</code> block; when used, every autoreleased property defined inside of it will be released <b>exactly at the end of block</b>:</p>
 <pre>
<code>-(void)emojifyAllFiles {</code>
<code>    int numberOfFiles = 1000000;</code>
<code>    for(i=0;i&lt;numberOfFiles;i++) {</code>
<code>        @autoreleasepool {</code>
<code>            NSString *contents = [self getFileContents:files[i]];</code>
<code>            NSString *emojified = [contents emojified];</code>
<code>            [self writeContents:contents toFile:files[i]];</code>
<code>        }</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>Instead of waiting until the end of the thread's run loop, the two NSStrings now receive a <code>release</code> message <b>right after</b> <code>writeContents</code> is called, keeping the memory usage stable.</p>
 <div class="post-image margin-top-40 margin-bottom-40"> 
  <img src="https://i.imgur.com/RoLTwYW.png" alt=""> 
 </div>
 <p>In fact, "releasing after the thread's run loop" isn't compiler magic, this is simply because the threads themselves are surrounded by <code>@autoreleasepools</code>! You can see this partially in the main.m of any Obj-C project.</p>
 <pre>
<code>int main(int argc, char * argv[]) {</code>
<code>    @autoreleasepool {</code>
<code>        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>What about Swift though?</p>
 <h2>Is @autoreleasepool needed in ARC-era Swift?</h2>
 <p>The answer is <b>it depends.</b></p>
 <p>In theory, yes, as the problem shown still exists since <code>autorelease</code> is still a thing, but these problems are harder to come by. The ARC optimizations for Swift evolved a lot in the past few years, and as far as I tested it seems that ARC for Swift is now smart enough to simply never call <code>autorelease</code>, editing your code so that objects call <code>release</code> multiple times instead. The language itself doesn't even appear to have a definition for <code>autorelease</code> outside of the Obj-C bridging -- the one we can use in Swift is in fact the one from Obj-C. This means that for <b>pure Swift objects</b>, <code>@autoreleasepool</code> appears to be useless as nothing is never going to be <code>autoreleased</code>. The following code stays at a stable memory level even though it's looping millions of times.</p>
 <pre>
<code>for _ in 0...9999999 {</code>
<code>    let obj = getGiantSwiftClass()</code>
<code>}</code>
</pre>
 <h3>Swift code calling Foundation / Legacy Objective-C code</h3>
 <p>However, it's a different story if your code is dealing with legacy Obj-C code, specially old Foundation classes in iOS. Consider the following code that loads a big image tons of times:</p>
 <pre>
<code>func run() {</code>
<code>    guard let file = Bundle.main.path(forResource: "bigImage", ofType: "png") else {</code>
<code>        return</code>
<code>    }</code>
<code>    for i in 0..&lt;1000000 {</code>
<code>        let url = URL(fileURLWithPath: file)</code>
<code>        let imageData = try! Data(contentsOf: url)</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>Even though we're in Swift, this will result in the same absurd memory spike shown in the Obj-C example! This is because the <code>Data</code> init is a bridge to the original Obj-C <code>[NSData dataWithContentsOfURL]</code> -- which unfortunately still calls <code>autorelease</code> somewhere inside of it. Just like in Obj-C, you can solve this with the Swift version of <code>@autoreleasepool</code>; <code>autoreleasepool</code> without the @:</p>
 <pre>
<code>autoreleasepool {</code>
<code>    let url = URL(fileURLWithPath: file)</code>
<code>    let imageData = try! Data(contentsOf: url)</code>
<code>}</code>
</pre>
 <p>The memory usage will now again be at a low, stable level.</p>
 <h2>How to know if a legacy UIKit/Foundation init/method returned an autoreleased instance?</h2>
 <p>Because these frameworks are closed source at Apple, there's no way to look their source code to see where <code>autorelease</code> is used.</p>
 <p>I tried many ways to automate this inside Swift with no success. My attempts included expanding <code>NSData</code> to contain an associated object to a dummy Swift class, but ARC was still smart enough to deinit these objects right after their loops even though the Data object is technically still alive.</p>
 <p>I also tried to create a <code>weak</code> reference to the <code>Data</code> instance hoping that it would be still alive after its loop, but it was too set to <code>nil</code>. This makes me think that it's possible that the <code>Data</code> object is indeed deiniting after the loop and what's autoreleasing in that init is something else entirely, but there's way to confirm this without looking the source code; which we unfortunately can't. I believe that there must be an internal property in <code>NSAutoreleasePool</code> or <code>NSThread</code> that you can inspect autoreleased properties, but for now the only way I found really is to manually look the Allocations instrument.</p>
 <h2>Conclusion</h2>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>To put it short, <code>autoreleasepool</code> is still useful in iOS/Swift development as there are still legacy Obj-C classes in UIKit and Foundation that call <code>autorelease</code>, but you likely don't need to worry about it when dealing with Swift classes due to ARC's optimizations.</p>
 <p>Follow me on my Twitter (<a href="https://twitter.com/rockbruno_">@rockbruno_</a>), and let me know of any suggestions and corrections you want to share.</p>
</div>]]></description>
</item>
<item>
    <title>Avoiding Release Anxiety 2: On the importance of creating a code Style Guide</title>
    <link>https://swiftrocks.com/code-style-guides-in-swift</link>
    <guid>https://swiftrocks.com/code-style-guides-in-swift</guid>
    <pubDate>Tue, 7 May 2019 15:00:00 GMT-3</pubDate>
<description><![CDATA[
 
  
  <!--WRITEIT_POST_NAME=Avoiding Release Anxiety 2: On the importance of creating a code Style Guide--> 
  <!--WRITEIT_POST_HTML_NAME=code-style-guides-in-swift--> 
  <!--WRITEIT_POST_SITEMAP_DATE_LAST_MOD=2020-04-12T14:00:00+02:00--> 
  <!--WRITEIT_POST_SITEMAP_DATE=2019-05-07T18:00:00+00:00--> 
  <!--Add here the additional properties that you want each page to possess.--> 
  <!--These properties can be used to change content in the template page or in the page itself as shown here.--> 
  <!--Properties must start with 'WRITEIT_POST'.--> 
  <!--Writeit provides and injects WRITEIT_POST_NAME and WRITEIT_POST_HTML_NAME by default.--> 
  <!--WRITEIT_POST_SHORT_DESCRIPTION=When teams start to grow, it becomes to difficult to track what everyone is doing. If the team has different ideas on what a specific piece of code should look like, you can very quickly end up with a project where nobody wanders outside the things they coded themselves.--> 
  <title>Avoiding Release Anxiety 2: On the importance of creating a code Style Guide</title>  
 

<div class="blog-post"> 
 <div class="post-title-index">  
  <h1>Avoiding Release Anxiety 2: On the importance of creating a code Style Guide</h1>
 </div> 
 <div class="post-info"> 
  <div class="category category-theory">
   Theory
  </div> 
  <div class="post-info-text">
   Published on 07 May 2019 
  </div> 
 </div>  
 <blockquote class="margin-top-40 margin-bottom-40"> 
  <p><i>This is part 2 of the Avoiding Release Anxiety series. <a href="https://swiftrocks.com/blockbased-ui-testing-in-swift">Check out part 1 here!</a></i></p> 
 </blockquote>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p><i>"I'm not sure how to implement this feature, Johnny is the one who created this screen."</i><br> <i>"Better to leave that code as it is, the guy who did it left the company a few months ago."</i><br> <i>"We should postpone this because Ana is the best person to handle this and she's on vacation."</i></p>
 <p>When teams start to grow, it becomes to difficult to track what everyone is doing. If the team has different ideas on what a specific piece of code should look like, you can very quickly end up with a project where nobody wanders outside the things they coded themselves. I've heard things like this and witnessed the consequences of the lack of a consistent style guides many times in many projects.</p>
 <p>Style guides can be seen as an anti-pattern when the subject is speed and there is often resistence from developers that haven't been part of large projects, and indeed having a traditional bureaucratic process in this modern tech world seems very odd, but a strict style guide is critical to have a project scale to the point where you can have hundreds of developers like Uber.</p>
 <p>Humans have an easier time understanding things that are familiar to them, which is why most people immediately label code bases from other teams as bad. When someone says <i>"What a terrible architecture!"</i> or <i>"I can't understand this, it's so badly written"</i> it's not that the code is bad, but that <b>you</b> are so used to what you wrote that everything else will feel off. The code could be bad indeed, but the opinions would remain even if it wasn't as you naturally search for the things that are familiar to you.</p>
 <p>Now, imagine an app with a team of 30+ developers. At this point the company is likely divided in squads, so there's no conceivable way you could review everyone's pull requests. Even if you could, it's 20 different opinions competing with yours, so you're bound to lose a few arguments. The more people the more opinions will differ, and without a style guide every squad's codebase will feel like a <b>completely</b> different project in your eyes in this scenario.</p>
 <p>After hearing phrases like the ones in the beginning of the article, you'll find that moving people from/to different squads becomes problematic. Because there's a big difference in code patterns from squads, a learning curve needs to be taken into account as your brain needs to be re-trained every time you wander into someone else's code.</p>
 <p>Finally, the worst outcome of this becomes visible: code review becomes inefficient. A PR that has changes in the code of multiple squads is too complex to understand due to the mix of many people's mental style guide. This leaves you unable to properly process the contents of the PR, making bugs and crashes slip into production. Hotfixes are pushed, but the PRs are just as bad to understand and the problem repeats over and over. Tons of "legacy" code is created -- an alias for "code that's too scary to change". Features that longer to develop, and refactors are nonexistent. Enter release anxiety!</p>
 <p>Now, not only this story isn't made-up, I actually made it <b>much less severe</b> than it really was. The lack of style guides can greatly harm the progress of a company, and the notion that it hurts speed is nonsense. The few minutes someone gained by ignoring lesser issues in a pull request once spiraled into hours of bug fixing and shipping hotfixes. Strict style guides actually <b>give</b> you speed in the long term!</p>
 <p>When an entire code base is written in a style that is familiar to you, all code feels like it was written by you. <a href="https://github.com/Rapiddo/rapiddo-ios-style-guide/blob/mpay/RAPIDDO.md">Rapiddo was the first app where we created our own style guide</a>, and it was also the first app where I felt like making changes in someone else's code was just as straightforward as making changes in my own. The presence of a style guide meant that I knew exactly where to look just like I was the one who wrote it as we strived to code in the exact same way. In the two years that this app lived only <b>one</b> critical bug was found in production, and it was in the very beginning -- way before we had a style guide. This played a huge part in making the releases stress-free.</p>
 <h2>Bootstrapping a Style Guide</h2>
 <p>For tips on creating your team's own style guide, I recommend taking a look at other team's guides. Here are some links to get you started:</p>
 <p><a href="https://github.com/raywenderlich/swift-style-guide">- Ray Wenderlich's Style Guide</a><br> <a href="https://github.com/linkedin/swift-style-guide">- Linkedin's Style Guide</a><br> <a href="https://google.github.io/swift/">- Google's Style Guide</a><br> <a href="https://github.com/Rapiddo/rapiddo-ios-style-guide/blob/master/README.md">- MovilePay/Rapiddo's Style Guide (mine)</a> </p>
 <p>In general, here are the things I personally find important to cover:</p>
 <p> - How to build something in the app's architecture, detailing the desired pattern as much as possible<br> - Details on how to write clean code (I personally recommend <a href="https://www.amazon.com.br/dp/B001GSTOAM/ref=dp-kindle-redirect?_encoding=UTF8&amp;btkr=1">this book</a>) - How to name properties/methods (This is important for CMD+F reasons! Things need to be easy to find for everyone.)<br> - When to use delegation/notifications/closures, and how to use them<br> - Desired usage of specific syntax sugars, like the way you can write methods where the last parameter is a closure<br> - The <b>order/position</b> of properties and methods in the file, to allow quick lookups<br> - Usage of special components/abstractions<br> - Usage of comments/documentation<br> - Be strict! In the long term, the project becomes easier to handle to everyone. </p>
 <p>An important thing to mention is that style guides <b>are incremental</b>. Don't worry about covering everything at once, new topics will naturally come up during code review. Here's an example where a comment resulted in a new addition to the style guide:</p>
 <div class="post-image margin-top-24 margin-bottom-24"> 
  <img src="https://i.imgur.com/IWMSaIV.png" alt=""> 
 </div>
 <p>With time, the topics that matter most to you and your team will be covered and you'll have a complete guide.</p>
 <h2>Conclusion</h2>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>In the end, it's all about how far you see your project going. Style guides are strict, have a learning curve and are hard to get used to initially, but if neglected, the lack of one ends up being one of the main reasons why a repository fell apart. In the long term, being able to seamlessly access and understand someone else's code in a team of 200 engineers is a large scale project's biggest strength.</p>
 <p>Follow me on my Twitter - <a href="https://twitter.com/rockbruno_">@rockbruno_</a>, and let me know of any suggestions and corrections you want to share.</p>
</div>]]></description>
</item>
<item>
    <title>Avoiding Release Anxiety 1: Block-based UI Testing in Swift</title>
    <link>https://swiftrocks.com/blockbased-ui-testing-in-swift</link>
    <guid>https://swiftrocks.com/blockbased-ui-testing-in-swift</guid>
    <pubDate>Sat, 20 Apr 2019 15:00:00 GMT-3</pubDate>
<description><![CDATA[
 
  
  <!--WRITEIT_POST_NAME=Avoiding Release Anxiety 1: Block-based UI Testing in Swift--> 
  <!--WRITEIT_POST_HTML_NAME=blockbased-ui-testing-in-swift--> 
  <!--WRITEIT_POST_SITEMAP_DATE_LAST_MOD=2020-04-12T14:00:00+02:00--> 
  <!--WRITEIT_POST_SITEMAP_DATE=2019-04-20T18:00:00+00:00--> 
  <!--Add here the additional properties that you want each page to possess.--> 
  <!--These properties can be used to change content in the template page or in the page itself as shown here.--> 
  <!--Properties must start with 'WRITE_IT_POST'.--> 
  <!--Writeit provides and injects WRITEIT_POST_NAME and WRITEIT_POST_HTML_NAME by default.--> 
  <!--WRITEIT_POST_SHORT_DESCRIPTION=When deadlines are tight and the product faces considerable changes, it's common for developers to make concessions in the project's quality to make sure it gets shipped in time. This leads to release anxiety - that stressful feeling where you're unsure if you're shipping something that actually works.--> 
  <title>Avoiding Release Anxiety 1: Block-based UI Testing in Swift</title>  
 

<div class="blog-post"> 
 <div class="post-title-index">  
  <h1>Avoiding Release Anxiety 1: Block-based UI Testing in Swift</h1>
 </div> 
 <div class="post-info"> 
  <div class="category category-theory">
   Theory
  </div> 
  <div class="category category-ios">
   iOS
  </div> 
  <div class="post-info-text">
   Published on 20 Apr 2019 
  </div> 
 </div>   
 <p>When deadlines are tight and the product faces considerable changes, it's common for developers to make concessions in the project's quality to make sure it gets shipped in time. This leads to release anxiety - that stressful feeling where you're unsure if you're shipping something that actually works. As a result, teams resort to heavy amounts of manual testing, staying overtime to make sure nothing fell apart and an unhappy environment in general. <i>Avoiding Release Anxiety</i> is a series of posts where I show the things I do to develop durable Swift apps that allow me and my team to sleep worry-free at night.</p>
 <h2>Resilient UI Tests</h2>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>I feel that UI Tests are very underrated by the community when compared to other forms of testing, but they're my favorite. When the subject is making sure that a feature works, my opinion is that users don't care if a button isn't the right color or if a font is slightly off -- they only care if it does what it should do. UI Testing is the closest you can get to the actual user experience, so if the UI Tests are working, it's likely that the user's experience in these flows will work as well. As a complement to the usual unit tests, I make sure to always write UI tests that navigate through all variations of the important flows of the app to reduce stress in release days.</p>
 <p>With that said, how can you effectively write and maintain these tests if your app has several screens and variations of them?</p>
 <p>I deal with this by implementing something that I call block-based testing. Instead of putting all the test logic directly in the test method, I instead divide each step of the navigation into its own "exploration" method. Here's an example:</p>
 <pre>
<code>private func exploreBalanceDetailsScreen() {</code>
<code>    let balanceView = app.tables.buttons["WALLET_HEADER"]</code>
<code>    expect(balanceView.isHittable) == true</code>
<code>    balanceView.tap()</code>
<code>    let detailsView = app.otherElements["BALANCE_DETAILS_VC_ROOT_VIEW"]</code>
<code>    detailsView.waitForExistence("Expected to be in the Balance Details Screen!")</code>
<code>    //Conditions that test if "Balance Details" is behaving correctly</code>
<code>    app.tapNavigationBackButton()</code>
<code>}</code>
</pre>
 <p>Exploration methods start by moving to the relevant screen of the method (assuming that the app is already in a position to do so). After it's confirmed that the relevant screen is working, the app is moved back to where it was before the exploration started.</p>
 <p>To confirm that a screen change happened, I like to use this <code>waitForExistence()</code> helper in a view controller's root <code>view</code> property:</p>
 <pre>
<code>extension XCUIElement {</code>
<code>    func waitForExistence(_ description: String? = nil, timeout: TimeInterval = 0.2) {</code>
<code>        let predicate = NSPredicate(format: "exists == true")</code>
<code>        let hasAppeared = XCTNSPredicateExpectation(predicate: predicate,</code>
<code>                                                    object: self)</code>
<code>        _ = XCTWaiter.wait(for: [hasAppeared], timeout: timeout)</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>When all relevant flows are created in this structure, building test cases is just a matter of connecting your LEGO bricks:</p>
 <pre>
<code>class BaseUITestCase: XCTestCase {</code>
<code></code>
<code>    private(set) var app: XCUIApplication! = nil</code>
<code></code>
<code>    override func setUp() {</code>
<code>        super.setUp()</code>
<code>        continueAfterFailure = false</code>
<code>        if app == nil {</code>
<code>            app = XCUIApplication()</code>
<code>            app.add(MockFlags.Environment.isUITest)</code>
<code>        }</code>
<code>    }</code>
<code>}</code>
<code></code>
<code>class WalletViewUITests: BaseUITestCase {</code>
<code>    func testLoggedOnHomeToQRScannerFlow() {</code>
<code>        app.launch()</code>
<code>        expectToBeInHome()</code>
<code>        exploreAvailableCardsWidget()</code>
<code>        exploreBalanceDetailsScreen()</code>
<code>        explorePaymentDetailsScreen()</code>
<code>        exploreTransactionsListScreen()</code>
<code>        goToQRScanner()</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>By reorganizing these blocks, you can test several variations of a flow with little effort. Here's an example of how I test the logged out version of the previous test:</p>
 <pre>
<code>func testLoggedOffHomeToQRScannerFlow() {</code>
<code>    app.add(MockFlags.User.isNotLogged)</code>
<code>    app.launch()</code>
<code>    expectToBeInHome(canInteract: false) //There should be a "logged off" empty state covering the screen.</code>
<code>    exploreLoggedOffScreen(shouldLogin: true)</code>
<code>    testLoggedOnHomeToQRScannerFlow() //Being logged out initially should not affect the rest of the app.</code>
<code>}</code>
</pre>
 <p>One of the things that bothers me the most in programming is when the tests are so complicated that they end up becoming a burden. Developing tests with a defined structure like this makes them a lot easier to maintain and expand from.</p>
 <h2>Extra: Typesafe Mocks</h2>
 <p>Although the block structure helps with the development of the tests themselves, we still need to make sure the app can properly navigate the screens and understand when an alternate flow is required.</p>
 <p>As spoiled by the previous example, the way we chose to handle the latter is by using <code>MockFlags</code>, which is a simple enum created to represent launch arguments:</p>
 <pre>
<code>public protocol MockFlag {</code>
<code>    var value: String { get }</code>
<code>}</code>
<code></code>
<code>extension MockFlag {</code>
<code>    public var value: String {</code>
<code>        return "\(String(describing: type(of: self)))-\(String(describing: self))"</code>
<code>    }</code>
<code>}</code>
<code></code>
<code>public enum MockFlags {</code>
<code>    public enum Environment: MockFlag {</code>
<code>        case isUITest</code>
<code>        case isUnitTest</code>
<code>    }</code>
<code></code>
<code>    public enum User: MockFlag {</code>
<code>        case isNotLogged</code>
<code>    }</code>
<code>}</code>
<code></code>
<code>extension XCUIApplication {</code>
<code>    func add(_ mockFlag: MockFlag) {</code>
<code>        launchArguments.append(mockFlag.value)</code>
<code>    }</code>
<code>}</code>
<code></code>
<code>public func has(_ mockFlag: MockFlag) -&gt; Bool {</code>
<code>    return CommandLine.arguments.contains(mockFlag.value)</code>
<code>}</code>
</pre>
 <p>By running <code>app.add(theFlagIWantToTest)</code> before launching the UI test, the desired flag becomes available for inspection during runtime as a launch argument. The tough part is how you efficiently react to these flags, but developing a system that can do this well is very beneficial to the evolution of your project.</p>
 <p>The way I like to do this is by using <b>protocols</b> in all important components of the app. Every one of these components, such as clients and persistence modules, are initialized once in the app's launch and propagated through the app -- but when the app is in the Unit/UI test environment, different, mocked versions of them are created instead. This is the usual stuff, but the catch here is that since everything is done with protocols, the app itself is completely isolated from the environment peculiarities. This prevents the tests from making the project's maintenance harder.</p>
 <p>Here's a basic example of how a client is mocked in this structure:</p>
 <pre>
<code>protocol HTTPRequest {</code>
<code>    associatedtype Response //Omitting paths, parameters, headers and etc for simplicity</code>
<code>}</code>
<code></code>
<code>protocol HTTPClient: AnyObject {</code>
<code>    func send&lt;R&gt;(_ request: R) -&gt; Promise&lt;R.Response&gt; where R: HTTPRequest</code>
<code>}</code>
<code></code>
<code>final class MockClient: HTTPClient {</code>
<code>    func send&lt;R&gt;(_ request: R) -&gt; Promise&lt;R.Response&gt; where R: HTTPRequest {</code>
<code>        guard let value = (request as? Mockable)?.mockedValue else {</code>
<code>            Logger.log("Request \(request) has no mocked version!")</code>
<code>            return Promise(error: HTTPError.generic)</code>
<code>        }</code>
<code>        return Promise(value: value)</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>To make the mocks typesafe, we created a <code>Mockable</code> protocol that allows anything to expose a mocked version of itself based on the available <code>MockFlags</code>. This way, we don't have to deal with HTTP stub libraries and raw json strings that need to be replaced every now and then, and changes in the app's models will make so the mocks have to be updated in compile time as well. The mocked client ends up being simply a class that retrieves these <code>Mockable</code> <code>HTTPRequest's</code> properties.</p>
 <pre>
<code>protocol Mockable {</code>
<code>    associatedtype MockValue</code>
<code>    var mockedValue: MockValue { get }</code>
<code>}</code>
<code></code>
<code>extension HTTPRequest where Self: Mockable {</code>
<code>    typealias MockValue = Response</code>
<code>}</code>
</pre>
 <pre>
<code>extension UserBalanceRequest: Mockable {</code>
<code>    var mockedValue: UserBalanceResponse {</code>
<code>        return UserBalanceResponse(balance: has(MockFlag.User.noBalance) ? 0 : 1_000_000)</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>To start the logic that propagates the mocked components forward, I like to use the <b>factory</b> pattern to hide the decision that results in their creation. In the case of the client, we allow the <code>AppDelegate</code> to create and retain these components before injecting them to the app's first screen.</p>
 <pre>
<code>func isTestEnvironment() -&gt; Bool {</code>
<code>    return has(MockFlags.Environment.isUITest) || has(MockFlags.Environment.isUnitTest)</code>
<code>}</code>
</pre>
 <pre>
<code>enum HTTPClientFactory {</code>
<code>   static func create() -&gt; HTTPClient {</code>
<code>        if isTestEnvironment() {</code>
<code>            return MockClient()</code>
<code>        }</code>
<code>        return URLSessionHTTPClient() //The regular HTTPClient</code>
<code>    }</code>
<code>}</code>
</pre>
 <pre>
<code>class AppDelegate: UIResponder, UIApplicationDelegate {</code>
<code>    let client = HTTPClientFactory.create()</code>
<code>    ...</code>
</pre>
 <p>Although creating the components is easy enough, how you efficiently push them forward to the rest of the app depends on your architecture. We use MVVM-C, so in our case we chose to never use singletons to instead have each Coordinator/ViewModel directly receive and retain the components that are important to them.</p>
 <pre>
<code>final class WalletCoordinator: Coordinator {</code>
<code></code>
<code>    let client: HTTPClient</code>
<code>    let persistence: Persistence</code>
<code></code>
<code>    init(client: HTTPClient, persistence: Persistence) {</code>
<code>        self.client = client</code>
<code>        self.persistence = persistence</code>
<code>        let viewModel = WalletViewModel(client: client, persistence: persistence)</code>
<code>        let viewController = WalletViewController(viewModel: viewModel)</code>
<code>        super.init(rootViewController: viewController, delegate: delegate)</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>This is beneficial to the development of Unit/UI tests as testing certain interactions can be done by simply passing custom versions of the components to each class.</p>
 <pre>
<code>func testViewStates() {</code>
<code>    let mockedClient = MockClient()</code>
<code>    mockedClient.alwaysFail = true</code>
<code>    let viewModel = WalletViewModel(client: mockedClient, persistence: MockPersistence())</code>
<code>    expect(viewModel.state) == .none</code>
<code>    viewModel.load()</code>
<code>    expect(viewModel.state) == .failed</code>
<code>}</code>
</pre>
 <pre>
<code>func testLockId() {</code>
<code>    class FailableClient: MockClient {</code>
<code>        var shouldFail = false</code>
<code>        func send&lt;R&gt;(_ resource: R) -&gt; Promise&lt;R.Value&gt; where R : HTTPRequest {</code>
<code>            guard shouldFail else {</code>
<code>                return super.send(resource)</code>
<code>            }</code>
<code>            return Promise(error: HTTPError.generic)</code>
<code>        }</code>
<code>    }</code>
<code>    let client = FailableClient()</code>
<code>    let viewModel = CheckoutViewModel(client: client)</code>
<code>    // some tests</code>
<code>    client.shouldFail = true</code>
<code>    // more tests</code>
<code>}</code>
</pre>
 <p>The downside of this approach is that the initializers tend to get really big when a screen has tons of responsibilities, which can be a bit jarring. There are several alternatives to dependency injection out there that don't hurt the testability of the classes, but that's a topic for another blog post.</p>
 <h2>Conclusion</h2>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>With everything setup, we're able to create not just UI but also Unit Tests while still being able to scale our project stress-free. By separating the test necessities from the project itself, we can develop conditions for tests without hurting the project's quality. After creating exploration methods and developing UI Tests for important flows that snap these methods together, we can rely on a resilient test suite that allows us to safely release new versions of our apps.</p>
 <p>Follow me on my Twitter - <a href="https://twitter.com/rockbruno_">@rockbruno_</a>, and let me know of any suggestions and corrections you want to share.</p>
</div>]]></description>
</item>
<item>
    <title>Adding iOS Home Shortcuts to Specific Parts of An App in Swift</title>
    <link>https://swiftrocks.com/adding-deeplink-shortcuts-to-the-ios-home-screen</link>
    <guid>https://swiftrocks.com/adding-deeplink-shortcuts-to-the-ios-home-screen</guid>
    <pubDate>Wed, 20 Feb 2019 15:00:00 GMT-3</pubDate>
<description><![CDATA[
 
  
  <!--WRITEIT_POST_NAME=Adding iOS Home Shortcuts to Specific Parts of An App in Swift--> 
  <!--WRITEIT_POST_HTML_NAME=adding-deeplink-shortcuts-to-the-ios-home-screen--> 
  <!--WRITEIT_POST_SITEMAP_DATE_LAST_MOD=2020-04-12T14:00:00+02:00--> 
  <!--WRITEIT_POST_SITEMAP_DATE=2019-02-20T18:00:00+00:00--> 
  <!--Add here the additional properties that you want each page to possess.--> 
  <!--These properties can be used to change content in the template page or in the page itself as shown here.--> 
  <!--Properties must start with 'WRITE_IT_POST'.--> 
  <!--Writeit provides and injects WRITEIT_POST_NAME and WRITEIT_POST_HTML_NAME by default.--> 
  <!--WRITEIT_POST_SHORT_DESCRIPTION=Deeplinking is widely used to provide easy access to certain portions of an iOS app. While most of the uses for a deeplink are marketing purposes such as providing shortcuts inside an e-mail or push notification, they can also be used for communicating between different apps and pretty much anything that involves routing to different screens.--> 
  <title>Adding iOS Home Shortcuts to Specific Parts of An App in Swift</title>  
 

<div class="blog-post"> 
 <div class="post-title-index">  
  <h1>Adding iOS Home Shortcuts to Specific Parts of An App in Swift</h1>
 </div> 
 <div class="post-info"> 
  <div class="category category-ios">
   iOS
  </div> 
  <div class="post-info-text">
   Published on 20 Feb 2019 
  </div> 
 </div>   
 <p>Deeplinking is widely used to provide easy access to certain portions of an iOS app. While most of the uses for a deeplink are marketing purposes such as providing shortcuts inside an e-mail or push notification, they can also be used for communicating between different apps and pretty much anything that involves routing to different screens.</p>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>iOS already allows you to add "shortcuts" to an app in the shape of 3D Touch Quick Actions, but they are very limited, hidden from the user, and let's be honest - it's one of these features that nobody remembers. You can also use Siri Extensions, but then you have to deal with Siri, and the regular Siri Shortcuts relies on the Shortcuts app, so it's not something that you can provide to your users. Wouldn't it be great if you could give your users the ability to add shortcuts to things like ordering their favorite coffee in the shape of a home icon - just like the app itself?</p>
 <div class="post-image margin-top-40 margin-bottom-40"> 
  <img src="https://i.imgur.com/XD134oO.jpg" alt="iOS home screen"> 
 </div>
 <p>Well, after reverse engineering Apple's Shortcuts app, it turns out that you can! That's exactly what it does when you add a system shortcut to the home screen, and we're going to <b>replicate it</b> in order to <b>give users the ability to add home icons that directly open a specific part of an app.</b></p>
 <p><a href="https://github.com/SwiftRocks/adding-deeplink-shortcuts-to-the-iOS-home-screen">Full project available here.</a></p>
 <div class="post-image margin-top-40 margin-bottom-40"> 
  <img src="https://cdn-images-1.medium.com/max/1600/1*1FKWtw4MtEdALUh7rJ0gvw.gif" alt="Opening shortcut"> 
 </div>
 <h2>Safari, Raw Data Rendering and PWAs</h2>
 <p>If you've never added an Apple shortcut to your home screen, here's the Shortcuts app equivalent that we're going to replicate:</p>
 <div class="post-image margin-top-40 margin-bottom-40"> 
  <img src="https://i.imgur.com/OknDMDb.jpg" alt="Saving Shortcuts from Shortcuts app"> 
 </div>
 <p>One might think that this is the result of an internal API since Apple has never shared anything in that aspect, but this is actually just a clever use of Safari's PWA features.</p>
 <p>To make it short, before the Safari screen is shown, the Shortcuts app locally generates a HTML page that pretends to be a PWA. If the page was opened inside Safari, the instructions are shown - but when the page is opened in PWA mode (a.k.a when you open it from the home screen), it instantly redirects to the relevant <code>shortcuts://</code> deeplink. That's very sneaky, and you can see by yourself exactly how it achieves that by 3D Touching the generated home icon and decoding the base64 string in the URL. <a href="https://gist.github.com/rockbruno/5412417f30c4ac506a7faa6a74a3f322">Here's an example.</a></p>
 <p>Replicating this requires a bit of tinkering since that's not an official iOS feature, but the end result is exactly the same and easier than it sounds. With this, you can make your app create home shortcuts to virtually anything that's bootable via deeplinks.</p>
 <p>The reason this is possible comes from the fact that Safari doesn't need an URL to display a page - it can render raw encoded data of many kinds, including HTML and images.</p>
 <p>Have your Safari open this, for example. You should see a <code>SwiftRocks!</code> page:</p>
 <pre>
<code>data:text/html;base64,PGJvZHk+PHA+U3dpZnRSb2NrcyE8L3A+PC9ib2R5Pg==</code>
</pre>
 <p>There's no page hosting this content, it's simply Safari directly rendering the base 64 encoding of <code>&lt;body&gt;&lt;p&gt;SwiftRocks!&lt;/p&gt;&lt;/body&gt;</code>. As expected, you can render entires pages using this format, including their scripts.</p>
 <p>Routing to a deeplink can be achieved with a simple JavaScript snippet - if you've been around during the iOS days before Apple added Universal Links, you probably had to deal with making an arbitrary page redirect to its deeplink equivalent if the user happened to have the app installed. We can use a similar approach here to achieve this effect:</p>
 <pre>
<code>&lt;html&gt;</code>
<code>  &lt;body&gt;</code>
<code>    &lt;p&gt;SwiftRocks!&lt;/p&gt;</code>
<code>    &lt;a id="redirect" href="https://apple.com/"&gt;&lt;/a&gt;</code>
<code>  &lt;/body&gt;</code>
<code>&lt;/html&gt;</code>
<code>&lt;script type="text/javascript"&gt;</code>
<code>  var element = document.getElementById('redirect');</code>
<code>  var event = document.createEvent('MouseEvents');</code>
<code>  event.initEvent('click', true, true, document.defaultView, 1, 0, 0, 0, 0, false, false, false, false, 0, null);</code>
<code>  setTimeout(function() { element.dispatchEvent(event); }, 25);</code>
<code>&lt;/script&gt;</code>
</pre>
 <p>This adds an invisible button link to the Apple website and immediatly runs a script that touches it after a small amount of time. You can try it out here:</p>
 <pre>
<code>data:text/html;base64,PGh0bWw+CiAgPGJvZHk+CiAgICA8cD5Td2lmdFJvY2tzITwvcD4KICAgIDxhIGlkPSJyZWRpcmVjdCIgaHJlZj0iaHR0cHM6Ly9hcHBsZS5jb20vIj48L2E+CiAgPC9ib2R5Pgo8L2h0bWw+CjxzY3JpcHQgdHlwZT0idGV4dC9qYXZhc2NyaXB0Ij4KICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyZWRpcmVjdCcpOwogIHZhciBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdNb3VzZUV2ZW50cycpOwogIGV2ZW50LmluaXRFdmVudCgnY2xpY2snLCB0cnVlLCB0cnVlLCBkb2N1bWVudC5kZWZhdWx0VmlldywgMSwgMCwgMCwgMCwgMCwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIDAsIG51bGwpOwogIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IGVsZW1lbnQuZGlzcGF0Y2hFdmVudChldmVudCk7IH0sIDI1KTsKPC9zY3JpcHQ+</code>
</pre>
 <p>That looks great! But if you take a look at the Shortcuts's app behavior, you'll see that the redirecting starts only <i>after</i> the icon is generated. How does that work?</p>
 <p>When Apple first added PWA support for Safari, a "standalone" or "app mode" function was added in order to make the web app experience better for users by hiding normal Safari functions such as the URL bar and navigation arrows. This mode is initiated when a PWA is opened from the home screen, and its usage can be detected by the page. That's exactly what the Shortcuts app uses to make sure the redirecting only happens when the page is opened from the home screen!</p>
 <p>In the following example, the <code>SwiftRocks!</code> text is only added if the page was opened inside Safari. If the page was opened in PWA mode, the user will be redirected instead. Metadata was also added to indicate Safari that this page can be opened in PWA mode, as well as a simple <code>title</code> tag so a default name is provided inside the share sheet.</p>
 <pre>
<code>&lt;html&gt;</code>
<code>&lt;head&gt;</code>
<code>  &lt;title&gt;Apple Page&lt;/title&gt;</code>
<code>  &lt;meta name="apple-mobile-web-app-capable" content="yes"&gt;</code>
<code>  &lt;meta name="apple-mobile-web-app-status-bar-style" content="#ffffff"&gt;</code>
<code>  &lt;meta name="apple-mobile-web-app-title" content="Apple Page"&gt;</code>
<code>&lt;/head&gt;</code>
<code>  &lt;body&gt;</code>
<code>    &lt;a id="redirect" href="https://apple.com/"&gt;&lt;/a&gt;</code>
<code>  &lt;/body&gt;</code>
<code>&lt;/html&gt;</code>
<code>&lt;script type="text/javascript"&gt;</code>
<code>  if (window.navigator.standalone) {</code>
<code>    var element = document.getElementById('redirect');</code>
<code>    var event = document.createEvent('MouseEvents');</code>
<code>    event.initEvent('click', true, true, document.defaultView, 1, 0, 0, 0, 0, false, false, false, false, 0, null);</code>
<code>    setTimeout(function() { element.dispatchEvent(event); }, 25);</code>
<code>  } else {</code>
<code>    var p = document.createElement('p');</code>
<code>    var node = document.createTextNode('SwiftRocks!');</code>
<code>    p.appendChild(node);</code>
<code>    document.body.appendChild(p);</code>
<code>  }</code>
<code>&lt;/script&gt;</code>
</pre>
 <p>Try it out! Open this in Safari, press the Share button, add it to your home screen and touch it to see how it works. For a real example, change the link to a deeplink to your app and encode it to base64 to see it in action. The page still looks terrible, but we'll see how to add icons and splash screens later on.</p>
 <pre>
<code>data:text/html;base64,PGh0bWw+CjxoZWFkPgogIDx0aXRsZT5BcHBsZSBQYWdlPC90aXRsZT4KICA8bWV0YSBuYW1lPSJhcHBsZS1tb2JpbGUtd2ViLWFwcC1jYXBhYmxlIiBjb250ZW50PSJ5ZXMiPgogIDxtZXRhIG5hbWU9ImFwcGxlLW1vYmlsZS13ZWItYXBwLXN0YXR1cy1iYXItc3R5bGUiIGNvbnRlbnQ9IiNmZmZmZmYiPgogIDxtZXRhIG5hbWU9ImFwcGxlLW1vYmlsZS13ZWItYXBwLXRpdGxlIiBjb250ZW50PSJBcHBsZSBQYWdlIj4KPC9oZWFkPgogIDxib2R5PgogICAgPGEgaWQ9InJlZGlyZWN0IiBocmVmPSJodHRwczovL2FwcGxlLmNvbS8iPjwvYT4KICA8L2JvZHk+CjwvaHRtbD4KPHNjcmlwdCB0eXBlPSJ0ZXh0L2phdmFzY3JpcHQiPgogIGlmICh3aW5kb3cubmF2aWdhdG9yLnN0YW5kYWxvbmUpIHsKICAgIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3JlZGlyZWN0Jyk7CiAgICB2YXIgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnTW91c2VFdmVudHMnKTsKICAgIGV2ZW50LmluaXRFdmVudCgnY2xpY2snLCB0cnVlLCB0cnVlLCBkb2N1bWVudC5kZWZhdWx0VmlldywgMSwgMCwgMCwgMCwgMCwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIDAsIG51bGwpOwogICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgZWxlbWVudC5kaXNwYXRjaEV2ZW50KGV2ZW50KTsgfSwgMjUpOwogIH0gZWxzZSB7CiAgICB2YXIgcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3AnKTsKICAgIHZhciBub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ1N3aWZ0Um9ja3MhJyk7CiAgICBwLmFwcGVuZENoaWxkKG5vZGUpOwogICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChwKTsKICB9Cjwvc2NyaXB0Pg==</code>
</pre>
 <h2>iOS: Opening the raw page from Swift</h2>
 <p>Now that we've seen how to make a shortcut PWA, we can make an app generate and trigger it.</p>
 <p>I'm assuming you already know how to create and process deeplinks in iOS, so I'll go straight to the point. In this example, I'm going to make a simple <code>UIViewController</code> that represents a "profile" screen trigger a shortcut page that opens an <code>shortcutTestApp://profile</code> deeplink that my app listens to in order to route the user to this same view controller:</p>
 <pre>
<code>final class ProfileViewController: UIViewController {</code>
<code>    @IBAction func shortcutButtonTouched(_ sender: Any) {</code>
<code>    	showShortcutScreen(forDeepLink: "shortcutTestApp://profile")</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>Inside <code>showShortcutScreen</code>, I'm going to generate the HTML for that shortcut, encode it and attempt to open it:</p>
 <pre>
<code>func showShortcutScreen(forDeepLink deepLink: String) {</code>
<code>    guard let deepLinkUrl = URL(string: deepLink) else {</code>
<code>        return</code>
<code>    }</code>
<code>    let html = getHtml(title: "Profile", urlToRedirect: deepLinkUrl)</code>
<code>    guard let data = html.data(using: .utf8) else {</code>
<code>        return</code>
<code>    }</code>
<code>    let base64 = data.base64EncodedString()</code>
<code>    guard let shortcutPage = URL(string: "data:text/html;base64,\(base64)") else {</code>
<code>        return</code>
<code>    }</code>
<code>    UIApplication.shared.open(shortcutPage)</code>
<code>}</code>
<code></code>
<code>func getHtml(title: String, urlToRedirect: URL) -&gt; String {</code>
<code>	return</code>
<code>	"""</code>
<code>	    &lt;head&gt;</code>
<code>	      &lt;body&gt;</code>
<code>	        .. //Rest of the HTML, replacing the relevant data with the properties.</code>
<code>	"""</code>
<code>}</code>
</pre>
 <p>This looks straightforward, but there's a big problem: If you try to run this, you'll see that it will simply not work.</p>
 <p>If you try to open a <code>data:</code> page from Swift using <code>open(url)</code>, nothing will happen, and if you try to use <code>SFSafariViewController</code>, it will crash stating that it doesn't understand the URL. There's no clear reason why this happens since Safari itself can open these links - it honestly just sounds like a bug in Apple's side. However, it does mean that we need to do a small workaround to make it work, but the good news is that even the Shortcuts app needs to do this, so you're not going to be alone.</p>
 <p>A solution for this is that instead of trying to directly open the raw content, you can create a localhost server that redirects to it. To make things easy, I'm going to use the <a href="https://github.com/httpswift/swifter">Swifter library</a> to create this server:</p>
 <pre>
<code>var localServer: HttpServer?</code>
<code></code>
<code>func showShortcutScreen(forDeepLink deepLink: String) {</code>
<code>    localServer = HttpServer()</code>
<code>    guard let deepLinkUrl = URL(string: deepLink) else {</code>
<code>        return</code>
<code>    }</code>
<code>    let html = getHtml(title: "Profile", urlToRedirect: deepLinkUrl)</code>
<code>    guard let data = html.data(using: .utf8) else {</code>
<code>        return</code>
<code>    }</code>
<code>    let base64 = data.base64EncodedString()</code>
<code>    guard let shortcutPage = URL(string: "http://localhost:8245/shortcut") else {</code>
<code>        return</code>
<code>    }</code>
<code>    localServer?["/shortcut"] = { request in</code>
<code>        return .movedPermanently("data:text/html;base64,\(base64)")</code>
<code>    }</code>
<code>    try? localServer?.start(8245)</code>
<code>    UIApplication.shared.open(shortcutPage)</code>
<code>}</code>
<code></code>
<code>deinit {</code>
<code>    localServer?.stop()</code>
<code>    localServer = nil</code>
<code>}</code>
</pre>
 <p>Compared to the previous example, this will boot a localhost server that listens to <code>/shortcut</code> and redirects to the original data URL. The result of this is the gif at the beginning of the article, and you can add this to different screens of your app in order to add shortcuts to pre-defined deeplinks that your or other's apps supports.</p>
 <p><a href="https://github.com/SwiftRocks/adding-deeplink-shortcuts-to-the-iOS-home-screen">Full project available here.</a></p>
 <h2>Pimp my PWA: Icons, Splash Screens and Conclusion</h2>
 <p>Now, while this works, it certainly doesn't look anything like the Shortcuts example! I didn't go too far in the looks department since I'm not a designer, but because this is essentially a PWA page you can infuse it with PWA properties in order to add things like home icons and splash screens.</p>
 <p>You can find this info in the Apple docs, but you can use <code>apple-touch-icon</code> and <code>apple-touch-startup-image</code> tags to link to images in order to add this sort of content, as well as using some html tricks to make your pages look neater. You can see the example project or the decoded Shortcut to see how to achieve this, but the Shortcuts app uses the localhost server to provide images while the example project encodes an asset and provides the raw data.</p>
 <p>To display the pretty instructions, the Shortcuts app generates an image on the fly. When it boots in PWA mode, it fetches the image from the local server and adds it to the body just like the previous <code>SwiftRocks!</code> example. It also has a fake version of the splash screen encoded into the html to make the transition between the page and the app smoother. In the end you're dealing with a HTML page, so anything goes!</p>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>In conclusion, if you have an app that contains important features, you can use this trick as an alternative to allow your users to create icons that go straight to them directly from their home screen.</p>
 <p>Follow me on my Twitter - <a href="https://twitter.com/rockbruno_">@rockbruno_</a>, and let me know of any suggestions and corrections you want to share.</p>
 <h2>References and Good reads</h2>
 <a href="https://developer.apple.com/library/archive/documentation/AppleApplications/Reference/SafariWebContent/ConfiguringWebApplications/ConfiguringWebApplications.html">Apple's PWA docs</a>
 <br>
</div>]]></description>
</item>
<item>
    <title>Avoiding Callback Hell in Swift</title>
    <link>https://swiftrocks.com/avoiding-callback-hell-in-swift</link>
    <guid>https://swiftrocks.com/avoiding-callback-hell-in-swift</guid>
    <pubDate>Mon, 17 Dec 2018 11:42:07 GMT-2</pubDate>
<description><![CDATA[
 
  
  <!--WRITEIT_POST_NAME=Avoiding Callback Hell in Swift--> 
  <!--WRITEIT_POST_HTML_NAME=avoiding-callback-hell-in-swift--> 
  <!--WRITEIT_POST_SITEMAP_DATE_LAST_MOD=2020-04-12T14:00:00+02:00--> 
  <!--WRITEIT_POST_SITEMAP_DATE=2018-12-17T13:42:07+00:00--> 
  <!--Add here the additional properties that you want each page to possess.--> 
  <!--These properties can be used to change content in the template page or in the page itself as shown here.--> 
  <!--Properties must start with 'WRITE_IT_POST'.--> 
  <!--Writeit provides and injects WRITEIT_POST_NAME and WRITEIT_POST_HTML_NAME by default.--> 
  <!--WRITEIT_POST_SHORT_DESCRIPTION=Being able to work in projects of the most diverse varieties gave me the chance to be in contact with several types of developers and code bases. Besides their core differences, what stood out to me during this process is that projects with a lower level of maturity will always face similar problems.--> 
  <title>Avoiding Callback Hell in Swift</title>  
 

<div class="blog-post"> 
 <div class="post-title-index">  
  <h1>Avoiding Callback Hell in Swift</h1>
 </div> 
 <div class="post-info"> 
  <div class="category category-swift">
   Swift
  </div> 
  <div class="post-info-text">
   Published on 17 Dec 2018 
  </div> 
 </div>   
 <p>Being able to work in projects of the most diverse varieties gave me the chance to be in contact with several types of developers and code bases. Besides their core differences, what stood out to me during this process is that projects with a lower level of maturity will always face similar problems.</p>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>Perhaps they choose the wrong architecture, or the lack of unit tests caused a nasty bug to sneak into production, but there's a specific problem that always draws my attention - callback hell. If not treated from the very beginning, these awful pyramids of braces you get when chaining callbacks inside other callbacks or conditions plague code bases with an eternity of impossible code-reviews and distant screams of "what the hell is this method supposed to be doing?".</p>
 <pre>
<code>private func requestNetwork&lt;T: Request&gt;(request: T, completion: (Result&lt;T&gt; -&gt; Void)?) {</code>
<code>  if isUserLogged {</code>
<code>    do {</code>
<code>      let urlRequest = try request.toRequest()</code>
<code>      session.dataTask(with: urlRequest) { (data, response, error) in</code>
<code>        if let httpResponse = response as? HTTPURLResponse {</code>
<code>          if acceptedStatuses?.contains(httpResponse.statusCode) != true {</code>
<code>            if let apiError = errorParser?.possibleError(from: data) {</code>
<code>              completion(.failure(error))</code>
<code>              return</code>
<code>            }</code>
<code>          }</code>
<code>        }</code>
<code>        preprocess(data) { (processedData, error) in</code>
<code>          if let error = error {</code>
<code>            completion(.failure(error))</code>
<code>          }</code>
<code>          if let processedData = processedData {</code>
<code>            do {</code>
<code>              let result = try request.serialize(processedData)</code>
<code>              completion(.success(result))</code>
<code>            } catch {</code>
<code>              completion(.failure(error))</code>
<code>            }</code>
<code>          } else {</code>
<code>              completion(.failure(HTTPError.unknown))</code>
<code>          }</code>
<code>        }</code>
<code>      }</code>
<code>    } catch {</code>
<code>      completion(.failure(error))</code>
<code>    }</code>
<code>  } else {</code>
<code>    completion(.failure(HTTPError.loggedOut))</code>
<code>  }</code>
<code>}</code>
</pre>
 <p>They are difficult to read, nearly impossible to review but unfortunately super easy to write, cementing their place as the bane of junior developers.</p>
 <p>Fortunately for us, Swift offers several options to avoid this behavior. With a bit of patience and a proper style guide, you can prevent this sort of mistake from affecting your productivity. I'll use this article to share how I personally avoid them, and hopefully this will help you come up with your own solutions.</p>
 <h2>Condition hells: Favor using guard instead of if</h2>
 <p>Pyramids of conditions are very common, and fortunately the easier to deal with. <code>guard</code> is on my top 10 features in Swift for a good reason - although it works basically as an inverted <code>if</code> statement, it gives you a great advantage in terms of code quality. Besides providing a way for you to give an early return to a method, it allows you to put the "good" outcome of a method in the same indentation as the method itself, making your method's intent far easier to be understood by your colleague. The improvement is not difficult to spot in a chain of <code>if</code> statement:</p>
 <pre>
<code>func foo() {</code>
<code>    if a {</code>
<code>        if b {</code>
<code>            if c {</code>
<code>                //Good outcome</code>
<code>            } else {</code>
<code>                //Bad outcome 3</code>
<code>            }</code>
<code>        } else {</code>
<code>            //Bad outcome 2</code>
<code>        }</code>
<code>    } else {</code>
<code>        //Bad outcome 1</code>
<code>    }</code>
<code>}</code>
</pre>
 <pre>
<code>func foo() {</code>
<code>    guard a else {</code>
<code>        return //Bad outcome 1</code>
<code>    }</code>
<code>    guard b else {</code>
<code>        return //Bad outcome 2</code>
<code>    }</code>
<code>    guard c else {</code>
<code>        return //Bad outcome 3</code>
<code>    }</code>
<code>    //Good outcome</code>
<code>}</code>
</pre>
 <p>If you embrace the mindset of putting the good outcome of your method as close as possible to the method's indentation and the bad outcomes as far as possible from it, you'll find your code to be significantly easier to read as a mere glance at the end of the method will be enough for someone to understand what it's supposed to do. Use <code>guards</code> to isolate things that are not supposed to happen and restrict the usage of <code>ifs</code> to things that aren't necessary for the good outcome to happen, like changing the color of a cell based on a property's value.</p>
 <pre>
<code>func updatePromotions(animated: Bool = true) {</code>
<code>    guard isUserLogged else {</code>
<code>        displayLoginScreen()</code>
<code>        return</code>
<code>    }</code>
<code>    if animated {</code>
<code>        delegate?.didStartLoading()</code>
<code>    }</code>
<code>    //Good outcome: Fetch promotions</code>
<code>}</code>
</pre>
 <h2>Closure hells: Abstracting completion handlers</h2>
 <p>Callback hells caused by asynchronous calls are the trickier to solve as completion handlers can contain pretty much anything, but there are efficient ways to deal with them as well.</p>
 <h3>Promises</h3>
 <p>The concept of Promises is my go-to solution for managing anything that's asynchronous. If you have never seen them before, Promises relate to the concept of a type that may or may not resolve a value at a later time:</p>
 <pre>
<code>func getInt() -&gt; Promise&lt;Int&gt;</code>
<code>    return Promise { promise in</code>
<code>       //Do something async</code>
<code>       promise.fulfill(number)</code>
<code>       //Or promise.fail(error)</code>
<code>    }</code>
<code>}</code>
<code>let promise = getInt().then { number in</code>
<code>    print(number * 10) //if it succeeds</code>
<code>}.catch { error in</code>
<code>    print(error) //if it fails</code>
<code>}</code>
</pre>
 <p>The <code>Promise</code> type can receive closures that determine how to proceed depending on the result of resolving the value, represented by <code>then(completion:)</code> and <code>catch(completion:)</code> in this case. If you're wondering why this helps with callback hells, it's because <code>then</code> handlers can optionally receive <b>another promise</b>, creating a limitless straight flow of operations:</p>
 <pre>
<code>func perform&lt;T: Request&gt;(request: T) -&gt; Promise&lt;T.Response&gt;</code>
<code>    return Promise { promise in</code>
<code>       //Do the actual request here, then:</code>
<code>       promise.fulfill(response)</code>
<code>    }</code>
<code>}</code>
<code></code>
<code>perform(requestOne()).then { responseOne in </code>
<code>    perform(requestTwo(responseOne: responseOne))</code>
<code>}.then { responseTwo in</code>
<code>    perform(requestThree(responseTwo: responseTwo))</code>
<code>}.then { responseThree in</code>
<code>    perform(requestFour(responseThree: responseThree))</code>
<code>}.catch { error in</code>
<code>    print(error)</code>
<code>}.always {</code>
<code>    print("Finished")</code>
<code>}</code>
</pre>
 <p>By making your async operations return <code>Promise</code> types instead of receiving completion handlers, you will be able to chain any amount of them together into a nice straight line of code. They are specially great when your operations depend on things returned by previous operations as more powerful Promise implementations will contain several options for transforming values as well.</p>
 <p>I personally use <a href="https://github.com/mxcl/PromiseKit">PromiseKit</a> as it contains tons of features, <a href="https://github.com/khanlou/Promise">but there are lightweight libraries around the web</a> and you could certainly <a href="https://www.swiftbysundell.com/posts/under-the-hood-of-futures-and-promises-in-swift">develop a simple Promise implementation yourself.</a></p>
 <p>You'll see people recommending things like RxSwift for this purpose as well - I would personally not do so because I think that anything that holds your entire project hostage is a death sentence in the long term (as in, every single thing you do has to take RxSwift's architecture in mind in order to work), but that's my personal opinion and you can definitely use it if you know what you're doing.</p>
 <h3>"I don't want to add more code!": <code>OperationQueue</code></h3>
 <p>If Promises aren't your thing because you'd rather solve things the Apple way, you can use <code>Foundation</code>'s native solutions for managing sequential operations.</p>
 <p><code>OperationQueue</code> is Apple's abstraction of <code>DispatchQueue</code> that contains additional features to better support synchronizing and canceling operations. If your operations don't rely on data from previous operations, the <code>Operation</code> family of classes will do the trick. For synchronous operations, this is just a matter of queuing your custom operations:</p>
 <pre>
<code>let queue = OperationQueue()</code>
<code>queue.maxConcurrentOperationCount = 1</code>
<code></code>
<code>func doLotsOfStuff(completion: (() -&gt; Void)?) {</code>
<code>    let firstOperation: Operation = FirstOperation()</code>
<code>    let secondOperation: Operation = SecondOperation()</code>
<code>    secondOperation.completionBlock = {</code>
<code>      completion?()</code>
<code>    }</code>
<code>    secondOperation.addDependency(firstOperation)</code>
<code>    queue.addOperation(firstOperation)</code>
<code>    queue.addOperation(secondOperation)</code>
<code>}</code>
<code></code>
</pre>
 <p>However, things are trickier for asynchronous operations. To make the queue wait for your operation to truly finish, you'll either have to use thread-blocking mechanisms such as <code>DispatchGroups</code> or <a href="https://gist.github.com/Sorix/57bc3295dc001434fe08acbb053ed2bc">create/use a custom AsynchronousOperation type</a> that manages an <code>Operation</code>'s states for this purpose.</p>
 <p>If you need an operation to pass data to another one, you'll find no clean solution with <code>OperationQueue</code> as there's no guarantee that an operation's <code>completionBlock</code> will be called before the next one starts running. There a few hacks to achieve them through - you can wrap all your needed data in an external reference type that is accessible by all operations:</p>
 <pre>
<code>func doLotsOfStuff(completion: (() -&gt; Void)?) {</code>
<code>    let data = NeededOperationData()</code>
<code>    // data has all properties needed by all operations</code>
<code>    // and each operation fetches and sets the ones</code>
<code>    // needed by the next operation.</code>
<code>    let one = OperationOne(data)</code>
<code>    let two = OperationTwo(data)</code>
<code>    two.addDependency(one)</code>
<code>    let three = OperationThree(data)</code>
<code>    three.addDependency(two)</code>
<code></code>
<code>    queue.addOperation(one)</code>
<code>    queue.addOperation(two)</code>
<code>    queue.addOperation(three)</code>
<code>}</code>
</pre>
 <p>Alternatively, you can store the necessary data in the operation's dependency and access it by subclassing the operation and fetching its dependencies when it gets executed.</p>
 <pre>
<code>class SecondOperation: AsynchronousOperation {</code>
<code>    var data: Data?</code>
<code></code>
<code>    override func main() {</code>
<code>      super.main()</code>
<code>      let firstOperation = dependencies.first as? FirstOperation</code>
<code>      data = firstOperation.result</code>
<code>      //Run the operation</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>I dislike having to deal with optional properties everywhere, so I personally wouldn't use <code>OperationQueue</code> if my operations depended on data fetched by other operations.</p>
 <h3>"Foundation sucks!": Use high-order functions</h3>
 <p>If you want to do this without using additional data structures, you can treat callback hell with nothing but pure Swift by applying better coding practices and some principles from functional programming. Because closures are types, they can be passed as arguments to methods - normally as completion handlers. The thing is that Swift methods are just glorified closures, so you can pass <b>an entire method as a closure argument</b>. This exact concept can be used to reduce the amount of nested closures in a method:</p>
 <pre>
<code>let sum = array.reduce(0, +)</code>
<code>//reduce() here is an ((Int, ((Int, Int) -&gt; Int)) -&gt; Int)</code>
<code>//and the + operator is func +(lhs: Int, rhs: Int) -&gt; Int,</code>
<code>//... or ((Int, Int) -&gt; Int), so there's no need to define reduce's closure.</code>
</pre>
 <p>To see how this applies, let's assume that we have a method that downloads a picture from the web, locally applies a Sepia tone filter to it in another thread and then uploads it as the user's profile picture:</p>
 <pre>
<code>func applySepiaFilterAndUpload(picUrl: URL, completion: ((User) -&gt; Void)?) {</code>
<code>    session.perform(downloadPictureRequest(url: picUrl)) { data in</code>
<code>        filtersQueue.async {</code>
<code>            let filteredPicture = applySepiaFilterTo(picData: data)</code>
<code>            session.perform(uploadUserPictureRequest(data: filteredPicture)) { user in</code>
<code>                completion?(user)</code>
<code>            }</code>
<code>        }</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>I've left out any kind of error management to make this article easier to grasp, but as any classic callback hell problem, the first problem here is clear: this method does way too much stuff. Before we start thinking about the closures, let's first apply the single responsibility principle and divide each part of this workflow into separate methods:</p>
 <pre>
<code>func downloadPicture(fromUrl url: URL, completion: ((Data) -&gt; Void)?) {</code>
<code>    session.perform(downloadPictureRequest(url: url)) { data in</code>
<code>        completion?(data)</code>
<code>    }</code>
<code>}</code>
<code></code>
<code>func applySepiaFilter(toPicData data: Data, completion: ((Data) -&gt; Void)?) {</code>
<code>    filtersQueue.async {</code>
<code>        let filteredPicture = applySepiaFilterTo(picData: data)</code>
<code>        completion?(filteredPicture)</code>
<code>    }</code>
<code>}</code>
<code></code>
<code>func uploadUserPicture(data: Data, completion: ((User) -&gt; Void)?) {</code>
<code>    session.perform(uploadUserPictureRequest(data: data)) { user in</code>
<code>        completion?(user)</code>
<code>    }</code>
<code>}</code>
<code></code>
<code>func applySepiaFilterAndUpload(picUrl: URL, completion: ((User) -&gt; Void)?) {</code>
<code>    downloadPicture(fromUrl: picUrl) { data in</code>
<code>        applySepiaFilter(toPicData: data) { filtered in</code>
<code>            uploadUserPicture(data: filtered) { user in</code>
<code>                completion?(user)</code>
<code>            }</code>
<code>        }</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>Although the callback hell still exists here, we at least have something that's readable now.</p>
 <p>To reduce the amount of nested closures, analyze how this method works. Can you see the pattern in <code>applySepiaFilterAndUpload()</code>? The key to solving the nesting problem here is how each step works: every method here works in the exact same way. <code>downloadPicture</code> receives an <code>URL</code> and provides a <code>Data</code> completion, <code>applySepiaFilter</code> receives a <code>Data</code> and provides another <code>Data</code> completion, and <code>uploadUserPicture</code> receives a <code>Data</code> and provides a <code>User</code> completion. If you turn these types into generics, you'll end up with:</p>
 <pre>
<code>downloadPicture    = (T, (U -&gt; Void)) -&gt; Void</code>
<code>applySepiaFilter   = (U, (V -&gt; Void)) -&gt; Void</code>
<code>uploadUserPicture  = (V, (W -&gt; Void)) -&gt; Void</code>
</pre>
 <p>Because these async operations have the exact same structure and clearly depend on each other, we can completely remove the necessity of having closures by adapting these methods to recieve the next one as an argument. This would be trivial to do if each method had an explicit return type, but since we're dealing with completion handlers we need to write a little helper to achieve this effect. First, I'll define this shared behaviour as an <code>Operation</code> alias (with optionals so nobody's forced to do anything):</p>
 <pre>
<code>public typealias Operation&lt;T, U&gt; = ((T, ((U) -&gt; Void)?) -&gt; Void)?</code>
</pre>
 <p>With that, we can define a method that "merges" two operations into one as long as they have matching parameters - making <code>(T, (U -&gt; Void)) -&gt; Void</code> + <code>(U, (V -&gt; Void)) -&gt; Void</code> become <code>(T, (V -&gt; Void)) -&gt; Void</code>:</p>
 <pre>
<code>func merge&lt;T, U, V&gt;(_ lhs: Operation&lt;T, U&gt;, to rhs: Operation&lt;U, V&gt;) -&gt; Operation&lt;T, V&gt; {</code>
<code>    return { (input, completion) in</code>
<code>        lhs?(input) { output in</code>
<code>            rhs?(output, completion)</code>
<code>        }</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>This method returns a <b>new closure</b> that performs the first operation method with a given input, uses its output to execute the second one and finally executes a given completion for the second operation's result. If all our methods follow the <code>Operation</code> structure, we can use <code>merge()</code> to progressively merge all steps into a single operation. We can't really escape the nesting in this helper, but this allows us to rewrite our main method without them:</p>
 <pre>
<code>func applySepiaFilterAndUpload(picUrl: URL, completion: ((User) -&gt; Void)?) {</code>
<code>    let job = merge(merge(downloadPicture, to: applySephiaFilter), to: uploadUserPicture)</code>
<code>    job?(picUrl, completion)</code>
<code>}</code>
</pre>
 <p>Because the signature of our operations match <code>merge()</code>'s closure arguments, we can skip having to define closures by passing the methods' signatures as the arguments. In the end, <code>job</code> becomes an unified method that takes an <code>URL</code>, executes all operations in order and then finally the executes the method's completion handler with the result of the last operation. That's just like the first version, but with no nesting at all!</p>
 <p>Now, if you're thinking <i>"but that looks terrible!"</i>, you're absolutely right. Because we can only merge two operations at a time, we need to call <code>merge()</code> several times which will result in something that's probably harder to read than the original callback hell. There's a way to fix this though - we can define an operator for <code>merge()</code>'s behavior: </p>
 <pre>
<code>infix operator &gt;&gt;-&gt;&gt;: LogicalConjunctionPrecedence // Precedence of &amp;&amp;</code>
<code></code>
<code>func &gt;&gt;-&gt;&gt;&lt;T, U, V&gt;(lhs: Operation&lt;T, U&gt;, rhs: Operation&lt;U, V&gt;) -&gt; Operation&lt;T, V&gt; {</code>
<code>    return merge(lhs, rhs)</code>
<code>}</code>
</pre>
 <p>By using <code>&amp;&amp;</code>'s precedence, operations will be progressively merged all the way from the left. With that in place, we can now rewrite our workflow as a nice straight line of operations.</p>
 <pre>
<code>func applySepiaFilterAndUpload(picUrl: URL, completion: ((User) -&gt; Void)?) {</code>
<code>    let job = downloadPicture &gt;&gt;-&gt;&gt; applySepiaFilter &gt;&gt;-&gt;&gt; uploadUserPicture</code>
<code>    job?(picUrl, completion)</code>
<code>}</code>
</pre>
 <p>If you're into this sort of stuff, the formal name for this very specific merging operation is the <a href="https://blog.ssanj.net/posts/2017-06-07-composing-monadic-functions-with-kleisli-arrows.html">Kleisi composition.</a></p>
 <h2>Conclusion: Read articles and books about writing clean code</h2>
 <p>If you take a deep look at it, you'll notice that the presence of things like callback hell will always boil down to the lack of good coding practices.</p>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>Clean code is a big topic, but there are great resources about it around the web. I've personally read and highly recommend <a href="https://www.amazon.com/dp/B001GSTOAM/ref=dp-kindle-redirect?_encoding=UTF8&amp;btkr=1">Robert C. Martin's Clean Code book</a> as it teaches you how to see your code from the perspective of other developers - a great skill to have when learning how to write better looking code. You should definitely give it a try if you're a professional developer.</p>
 <p>Follow me on my Twitter - <a href="https://twitter.com/rockbruno_">@rockbruno_</a>, and let me know of any suggestions and corrections you want to share.</p>
 <h2>References and Good reads</h2>
 <a href="https://en.wikipedia.org/wiki/Futures_and_promises">Promises</a>
 <br>
 <a href="https://blog.ssanj.net/posts/2017-06-07-composing-monadic-functions-with-kleisli-arrows.html">Kleisi composition</a>
 <br>
 <a href="https://developer.apple.com/videos/play/wwdc2015/226/">WWDC: Advanced NSOperations</a>
 <br>
 <a href="https://gist.github.com/Sorix/57bc3295dc001434fe08acbb053ed2bc">AsynchronousOperation.swift</a>
</div>]]></description>
</item>
<item>
    <title>How @dynamicMemberLookup Works Internally in Swift (+ Creating Custom Swift Attributes)</title>
    <link>https://swiftrocks.com/how-dynamicmemberlookup-works-internally-in-swift</link>
    <guid>https://swiftrocks.com/how-dynamicmemberlookup-works-internally-in-swift</guid>
    <pubDate>Thu, 6 Dec 2018 11:42:07 GMT-2</pubDate>
<description><![CDATA[
 
  
  <!--WRITEIT_POST_NAME=How @dynamicMemberLookup Works Internally in Swift (+ Creating Custom Swift Attributes)--> 
  <!--WRITEIT_POST_HTML_NAME=how-dynamicmemberlookup-works-internally-in-swift--> 
  <!--WRITEIT_POST_SITEMAP_DATE_LAST_MOD=2020-04-12T14:00:00+02:00--> 
  <!--WRITEIT_POST_SITEMAP_DATE=2018-12-06T13:42:07+00:00--> 
  <!--Add here the additional properties that you want each page to possess.--> 
  <!--These properties can be used to change content in the template page or in the page itself as shown here.--> 
  <!--Properties must start with 'WRITE_IT_POST'.--> 
  <!--Writeit provides and injects WRITEIT_POST_NAME and WRITEIT_POST_HTML_NAME by default.--> 
  <!--WRITEIT_POST_SHORT_DESCRIPTION=The @dynamicMemberLookup attribute was introduced in Swift 4.2 to add a certain degree of dynamism into the language similar to what is seen in languages like Python.--> 
  <title>How @dynamicMemberLookup Works Internally in Swift (+ Creating Custom Swift Attributes)</title>  
 

<div class="blog-post"> 
 <div class="post-title-index">  
  <h1>How @dynamicMemberLookup Works Internally in Swift (+ Creating Custom Swift Attributes)</h1>
 </div> 
 <div class="post-info"> 
  <div class="category category-compiler">
   Compiler
  </div> 
  <div class="category category-swift">
   Swift
  </div> 
  <div class="post-info-text">
   Published on 06 Dec 2018 
  </div> 
 </div>  
 <p>The <code>@dynamicMemberLookup</code> attribute was introduced in Swift 4.2 to add a certain degree of dynamism into the language similar to what is seen in languages like Python. When applied to a type, properties from this type will be resolved in runtime, meaning that you can call things that don't necessarily exist like they were explicitly defined:</p>
 <pre>
<code>@dynamicMemberLookup class MyClass {</code>
<code>    subscript(dynamicMember input: String) -&gt; String {</code>
<code>	      return input == "foo" ? "bar" : "SwiftRocks"</code>
<code>    }</code>
<code>}</code>
<code></code>
<code>MyClass().foo // bar</code>
<code>MyClass().notFoo // SwiftRocks</code>
<code>// These properties don't exist, but they can be called because the type is @dynamicMemberLookup.</code>
</pre>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>As seen in the snippet, usage of this attribute instead forces the type to provide a <code>dynamicMember</code> subscript which receives the "fake" property name as a parameter and acts upon it.</p>
 <p><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0195-dynamic-member-lookup.md">The original motivation</a> was that it could be used in interoperability layers with dynamic languages, allowing you to call Python code in Swift like you would in Python itself, for example. Although this attribute doesn't have pure Swift in mind, you can certainly use it for it. I would probably never use it in regular iOS development, but my favorite use case is being able to improve JSON parsing:</p>
 <pre>
<code>let data: String? = dict["data"] as? String</code>
<code>//</code>
<code>let data: String? = dict.data //dynamically search for "data"</code>
</pre>
 <p>In a similar fashion, <code>@dynamicCallable</code> was added in Swift 5.0 as a follow-up to add the ability to dynamically call a method from a dynamicCallable type:</p>
 <pre>
<code>let myType: MyDynamicType = MyDynamicType()</code>
<code>myType(someArg2: someVal, someArg2: someVal2)</code>
</pre>
 <p>I was interested in learning how the attributes worked inside the compiler to know more about how they are able to transform these fake expressions into legit ones, so I've <i>once again</i> reverse-engineered the Swift compiler to find these answers - and used this knowledge to create my own Swift attribute.</p>
 <p><i>Disclaimer: As always, this is a result of my own research and reverse-engineering for the pure purpose of learning something new. As I obviously have nothing to do with the original development of these attributes, some assumptions might not be fully correct. Feel free to correct me if you know how the compiler works!</i></p>
 <p>This article will focus on the internals of <code>@dynamicMemberLookup</code>. <code>@dynamicCallable</code> works a bit differently, but overall follows the same idea.</p>
 <h2>Attribute Declaration/Parsing</h2>
 <p>A quick repo search shows us that in Swift, all attributes are mainly defined in the <a href="https://github.com/apple/swift/blob/master/include/swift/AST/Attr.def">Attr.def</a> file. Here's the definition of <code>@dynamicMemberLookup</code>:</p>
 <pre>
<code>SIMPLE_DECL_ATTR(dynamicMemberLookup, DynamicMemberLookup,</code>
<code>OnNominalType, 9)</code>
</pre>
 <p>A "simple attribute" is an attribute that holds no data (unlike <code>@available</code> which contains arguments). The first argument here is the name of the attribute in source files, the second one is the name of the attribute to be used inside the compiler (which will resolve to <code>DynamicMemberLookupAttr</code>), the third one defines its scope (in this case, a <code>NominalType</code> refers to the congregate of classes, structs, enums and protocols), and the last one is an unique code used internally to determine a valid attribute.</p>
 <p>The first contact the Swift compiler has with attributes is during parsing. After lexical analysis generates the tokenized version of your code, the Parser will step through these tokens in order to generate a basic Abstract Syntax Tree (your code in a tree-like structure) which will later be used to further "understand" your code once typechecking is performed. This process can fail if it finds something it didn't expect - a mistyped keyword, an attribute in the wrong place, and so on. You have certainly seen this before in the shape of a "expected X identifier" error.</p>
 <p>You can tell the compiler to print the Parser's resulting AST by running <code>swiftc -dump-parse</code>, but unfortunately for article purposes that doesn't print a type's attributes (a pull request opportunity?). But the good news is that we can confirm this by looking at the code that parses declaractions. The Parser does a gigantic amount of things, so I'll cheery-pick the relevant backtrace:</p>
 <p><a href="https://github.com/apple/swift/blob/facaad18732fd476c515c8b58dd8ccd964148c54/lib/Parse/ParseStmt.cpp#L387-L391">ParseStmt.cpp:387-391</a> - if the current token represents a declaration, attempt to parse it.</p>
 <pre>
<code>if isStartOfDecl()</code>
<code>  parseDecl(...)</code>
</pre>
 <p><a href="https://github.com/apple/swift/blob/facaad18732fd476c515c8b58dd8ccd964148c54/lib/Parse/ParseDecl.cpp#L2639-L2710">ParseDecl.cpp:2639-2710</a> - For a regular declaraction expression the attributes should be the first tokens, so they are the first tokens to be parsed:</p>
 <pre>
<code>Parser::parseDecl(ParseDeclOptions Flags, llvm::function_ref&lt;void(Decl*)&gt; Handler) {</code>
<code>    //removed: dealing with #if/#warning/#error</code>
<code>    parseDeclAttributeList(...)</code>
<code>    //rest of the parsing for a declaration</code>
<code>}</code>
</pre>
 <p>What <code>parseDeclAttributeList()</code> does is a <code>do while</code> loop to parse an attribute if the current token is an <code>@</code>, which then calls <a href="https://github.com/apple/swift/blob/facaad18732fd476c515c8b58dd8ccd964148c54/lib/Parse/ParseDecl.cpp#L1692">parseDeclAttribute()</a> to begin parsing the attribute:</p>
 <pre>
<code>bool Parser::parseDeclAttribute(DeclAttributes &amp;Attributes, SourceLoc AtLoc)</code>
<code>    if (Tok.isNot(tok::identifier) &amp;&amp;</code>
<code>        Tok.isNot(tok::kw_in) &amp;&amp;</code>
<code>        Tok.isNot(tok::kw_inout)) {</code>
<code>        diagnose(Tok, diag::expected_attribute_name); // Compiler error for "Expected attribute name"</code>
<code>        return true;</code>
<code>    }</code>  
<code>    DeclAttrKind DK = DeclAttribute::getAttrKindFromString(Tok.getText());</code>
<code></code>
<code>    // FIXME: This renaming happened before Swift 3, we can probably remove</code>
<code>    // the specific fallback path at some point.</code>
<code>    checkInvalidAttrName("availability", "available", DAK_Available, diag::attr_renamed); // Checks if the attribute name matches the old name and fails, suggesting the new</code>
<code>    // more checks for all renamed or deprecated attributes</code>
<code></code>
<code>    if (DK == "a valid attribute from Attr.def") // line 1805</code>
<code>        return parseNewDeclAttribute(Attributes, AtLoc, DK);</code>
<code>    diagnose(Tok, diag::unknown_attribute, Tok.getText()); // Compilation error for "unknown attribute %@"</code>
<code>}</code>
</pre>
 <p>I like this method because we can see how Swift treats renamed attributes - just explicitely check if the current token matches an old name and throw an error stating that it's now called something else. But in short, we're just seeing if the name of our attribute matches an attribute defined at <code>Attr.def</code>, halting compilation if that's not the case. If the attribute exists, <code>parseNewDeclAttribute</code> will consume the token and add it to an attributes list for that AST.</p>
 <p>By running the Swift compiler with the <code>-dump-parse</code> attribute, we'll tell the compiler to start compiling but stop as soon as the parsing step ends. This allows us to confirm that this is indeed where this logic is being executed:</p>
 <pre class="command-line language-bash" data-host="SwiftRocks">
<code>swiftc -dump-parse attrs.swift</code>
</pre>
 <pre>
<code>@swiftRocks class Foo {} // error: unknown attribute 'swiftRocks'</code>
<code>@availability class Foo {} // error: '@availability' has been renamed to '@available'</code>
</pre>
 <h2>Intermission: Creating a new <code>@swiftRocks</code> attribute</h2>
 <p>Before seeing how this attribute results in dynamic members, how about using this knowledge to actually make an attribute of our own?</p>
 <p>This brief introduction shows us that the barebones of an attribute aren't that complicated at all, and we can use that information to create a basic <code>@swiftRocks</code> attribute.</p>
 <p>For that, I'll just add an entry for a class attribute in <code>Attr.def</code>:</p>
 <pre>
<code>SIMPLE_DECL_ATTR(swiftRocks, SwiftRocks, OnClass, 83)</code>
</pre>
 <p>Doing so forced me to add my attribute to a few lists and add a <code>visitSwiftRocksAttr()</code> method in TypeCheckAttr.cpp, which I did but left it empty since my attribute does nothing at the moment:</p>
 <pre>
<code>void AttributeChecker::</code>
<code>visitSwiftRocksAttr(SwiftRocksAttr *attr) {}</code>
</pre>
 <p>This is enough to make a <code>@swiftRocks</code> type compile, although nothing will happen since there's no logic tied to it. To see something happen, I'll pretend that older Swift versions used this very useful attribute as <code>@rockingSwift</code> by adding a new check at <code>parseDeclAttribute</code>: </p>
 <pre>
<code>checkInvalidAttrName("rockingSwift", "swiftRocks", DAK_SwiftRocks, diag::attr_renamed);</code>
</pre>
 <pre>
<code>@rockingSwift class Foo {} //error: '@rockingSwift' has been renamed to '@swiftRocks'</code>
</pre>
 <p>We'll get back to it later.</p>
 <h2>Defining/changing behaviour based on attributes</h2>
 <p>After parsing, <code>@dynamicMemberLookup</code> will come to play again during semantic analysis. In order to confirm that your code is legit, the compiler will annotate the AST's nodes with their respective types and confirm that they can do whatever it is that they are doing. Some debugging revealed that the typechecking of a declaration triggers a typechecking call for every attribute it contains - first to confirm that the attribute is on the correct type (in this case, a <code>NominalType</code>), and second in order for you to confirm that the attribute is being used correctly. The latter happens in the same place where I had to create my <code>visitSwiftRocksAttr</code> method, but in <code>visitDynamicMemberLookupAttr</code> instead. In short, this method checks if the type implements one or more valid <code>subscript(dynamicMember)</code>, and throws a compilation error if that's not the case:</p>
 <pre>
<code>void AttributeChecker::</code>
<code>visitDynamicMemberLookupAttr(DynamicMemberLookupAttr *attr) {</code>
<code>    // This attribute is only allowed on nominal types.</code>
<code>    auto decl = cast&lt;NominalTypeDecl&gt;(D);</code>
<code>    auto type = decl-&gt;getDeclaredType();</code>
<code></code>
<code>    // Look up `subscript(dynamicMember:)` candidates.</code>
<code>    auto subscriptName = DeclName(TC.Context, DeclBaseName::createSubscript(),</code>
<code>                                  TC.Context.Id_dynamicMember);</code>
<code>    auto candidates = TC.lookupMember(decl, type, subscriptName);</code>
<code></code>
<code>    // If there are no candidates, then the attribute is invalid.</code>
<code>    if (candidates.empty()) {</code>
<code>      TC.diagnose(attr-&gt;getLocation(), diag::invalid_dynamic_member_lookup_type,</code>
<code>                  type);</code>
<code>      attr-&gt;setInvalid();</code>
<code>      return;</code>
<code>    }</code>
<code></code>
<code>    // If no candidates are valid, then reject one.</code>
<code>    auto oneCandidate = candidates.front();</code>
<code>    candidates.filter([&amp;](LookupResultEntry entry, bool isOuter) -&gt; bool {</code>
<code>      auto cand = cast&lt;SubscriptDecl&gt;(entry.getValueDecl());</code>
<code>      TC.validateDeclForNameLookup(cand);</code>
<code>      return isValidDynamicMemberLookupSubscript(cand, decl, TC);</code>
<code>    });</code>
<code></code>
<code>    if (candidates.empty()) {</code>
<code>      TC.diagnose(oneCandidate.getValueDecl()-&gt;getLoc(),</code>
<code>                  diag::invalid_dynamic_member_lookup_type, type);</code>
<code>      attr-&gt;setInvalid();</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>As far as developing attributes goes, the standard seems to end here. Because attributes can be used for virtually anything, each attribute is developed where it makes sense for it. In <code>@dynamicMemberLookup</code>'s case, this happens during semantic analysis - when the Constraint System fails to resolve our unexistent properties through normal means, checking the existence of this attribute is used as a last resort: (simplified for readability purposes, <a href="https://github.com/apple/swift/blob/1c82d4977d4d58b93a46f3e8022e356862f98d57/lib/Sema/CSSimplify.cpp#L3592">original method here</a>)</p>
 <pre>
<code>MemberLookupResult ConstraintSystem::</code>
<code>performMemberLookup(...) {</code>
<code>  //Removed: Attempt resolve member through several means, but fail since the property doesn't exist</code>
<code></code>
<code>  // If we're about to fail lookup, but we are looking for members in a type</code>
<code>  // with the @dynamicMemberLookup attribute, then we resolve a reference</code>
<code>  // to a `subscript(dynamicMember:)` method and pass the member name as a</code>
<code>  // string parameter.</code>
<code>  if (cantResolveIt &amp;&amp; isSimpleName) {</code>
<code>    auto name = memberName.getBaseIdentifier();</code>
<code>    if (hasDynamicMemberLookupAttribute(...)) {</code>
<code>      auto &amp;ctx = getASTContext();</code>
<code>      // Find `subscript(dynamicMember:)` methods in this type.</code>
<code>      auto subscriptName = DeclName(ctx, DeclBaseName::createSubscript(), ctx.Id_dynamicMember);</code>
<code>      auto subscripts = performMemberLookup(constraintKind,</code>
<code>                                            subscriptName,</code>
<code>                                            baseTy, functionRefKind,</code>
<code>                                            memberLocator,</code>
<code>                                            includeInaccessibleMembers);</code>
<code>      for (auto candidate : subscripts.ViableCandidates) {</code>
<code>        auto decl = cast&lt;SubscriptDecl&gt;(candidate.getDecl());</code>
<code>        if (isValidDynamicMemberLookupSubscript(decl, DC, TC))</code>
<code>          result.addViable(OverloadChoice::getDynamicMemberLookup(baseTy, decl, name));</code>
<code>      }</code>
<code>  }</code>
<code>}</code>
</pre>
 <p>By confirming that the fake property comes from a type that uses the attribute (remember that the attribute was added to the declaration's AST), the solver concludes that it's possible to resolve it by overloading it with the type's <code>subscript(dynamicMember:)</code> declaration.</p>
 <p>After the CS resolves the intended return type of the property, the Sema's Solution Application phase will detect the desired overload solution and generate a <code>subscript</code> expression that matches the original definition inside the type. Finally, this expression replaces the original property call. <a href="https://github.com/apple/swift/blob/1c82d4977d4d58b93a46f3e8022e356862f98d57/lib/Sema/CSApply.cpp#L2752">(original file here)</a></p>
 <pre>
<code>case OverloadChoiceKind::DynamicMemberLookup: {</code>
<code>  // Application of a DynamicMemberLookup result turns a member access of</code>
<code>  // x.foo into x[dynamicMember: "foo"].</code>
<code> </code>
<code>  // Removed for readability</code>
<code></code>
<code>  // Generate a (dynamicMember: T) expression.</code>
<code>  auto fieldName = selected.choice.getName().getBaseIdentifier().str();</code>
<code>  auto index = buildDynamicMemberLookupIndexExpr(fieldName, ...);</code>
<code></code>
<code>  // Build and return a subscript that uses this string as the index.</code>
<code>  return buildSubscript(base, index, ctx.Id_dynamicMember, ...)</code>
<code>}</code>
</pre>
 <p>As spoiled by the comment above, this means that <code>@dynamicMemberLookup</code> properties are just syntax sugars for subscript calls! Because our fake properties really don't exist, the compiler swaps them with calls to the subscript method required by the attribute.</p>
 <p>You can confirm this by compiling with the <code>-dump-ast</code> argument. Similar to <code>-dump-parse</code>, this argument will stop the compilation after typechecking is performed, allowing you to see the complete version of the AST. For <code>let foo: String = myType.bar</code>, the result will be something like this:</p>
 <pre>
<code>(pattern_named type='String' 'foo')</code>
<code> (subscript_expr type='String'</code>
<code>  (tuple_expr implicit type='(dynamicMember: String)' names=dynamicMember</code>
<code>   (string_literal_expr implicit type='String' value="bar")))</code>
</pre>
 <p>...which vaguely means <code>let foo: String = myType[dynamicMember: "bar"]</code>.</p>
 <h2>Bonus: Adding functionality to <code>@swiftRocks</code></h2>
 <h3>Adding requirements</h3>
 <p>Now that <code>@dynamicMemberLookup</code> is uncovered, we're ready to make our custom attribute <i>actually</i> do something.</p>
 <p>The first thing I want to change is the checker function I had to add when the attribute was created. I want this attribute to work only in classes that are called <code>ClassThatRocks</code>. If that's not the case, compilation must fail.</p>
 <p>To be able to do that, I added a new identifier called <code>id_ClassThatRocks</code> to the <a href="https://github.com/apple/swift/blob/cc329fee03d6d6a30eb526e4be28bb876bd6ba0f/include/swift/AST/KnownIdentifiers.def">compiler's list of known identifiers</a>, and a "not ClassThatRocks" error to the <a href="https://github.com/apple/swift/blob/f871b0e661bb951b8943d235694f382921aa9994/include/swift/AST/DiagnosticsSema.def">compiler's list of semantic analysis related errors:</a></p>
 <pre>
<code>ERROR(invalid_swiftrocks_name,none,</code>
<code>"@swiftRocks requires %0 to be called 'ClassThatRocks'", (Type))</code>
</pre>
 <p>With that in place, I just need to compare the declaration's name in <code>visitSwiftRocksAttr()</code>:</p>
 <pre>
<code>void AttributeChecker::</code>
<code>visitSwiftRocksAttr(SwiftRocksAttr *attr) {</code>
<code>  auto decl = cast&lt;NominalTypeDecl&gt;(D);</code>
<code>  auto type = decl-&gt;getDeclaredType();</code>
<code>  if (decl-&gt;getName() != TC.Context.Id_ClassThatRocks) {</code>
<code>    TC.diagnose(attr-&gt;getLocation(),</code>
<code>                diag::invalid_swiftrocks_name, type);</code>
<code>    attr-&gt;setInvalid();</code>
<code>  }</code>
<code>}</code>
</pre>
 <p>And the result is:</p>
 <pre>
<code>@swiftRocks class Foo {} //error: @swiftRocks requires 'Foo' to be called 'ClassThatRocks'</code>
<code>@swiftRocks class ClassThatRocks {} //Works!</code>
</pre>
 <h3>Adding the actual functionality: Wholesome reminders</h3>
 <p>For the actual use, I've thought that such an incredible attribute should have an equally incredible use: When applied to a type, the compiler will put a warning on all properties that don't have "ThatRocks" in their name, because they are doing a good job and deserve recognition.</p>
 <p>To do this, I'll intercept the typechecker in order to have access to all getter declarations. Given a getter, I can recursively its parents to see if someone has a <code>@swiftRocks</code> attribute and check if the getter's name doesn't contain "ThatRocks" in order to send the coder a friendly warning.</p>
 <p>After a very long time of searching for suitable places for this implementation, I've found that <code>typeCheckDecl()</code> has all the information I need. It's probably a terrible place to do this, but the members of SwiftRocks unanimously decided that this attribute is more important than coding practices. After another very long time of trying to figure out how to retrieve a getter's "type tree", here's what I ended up with</p>
 <pre>
<code>void TypeChecker::typeCheckDecl(Decl *D) {</code>
<code>  if (auto AD = dyn_cast&lt;AccessorDecl&gt;(D)) {</code>
<code>    DeclName name = AD-&gt;getStorage()-&gt;getFullName();</code>
<code>    if (auto nominal = D-&gt;getDeclContext()-&gt;getSelfNominalTypeDecl()) {</code>
<code>      auto type = nominal-&gt;getDeclaredType();</code>
<code>      if (name.isSimpleName() &amp;&amp; !name.isSpecial() &amp;&amp; hasSwiftRocksAttribute(type)) {</code>
<code>        StringRef rocks = "ThatRocks";</code>
<code>        StringRef strName = name.getBaseIdentifier().str();</code>
<code>        if (!strName.contains(rocks)) {</code>
<code>          diagnose(AD-&gt;getLoc(), </code>
<code>                   diag::invalid_swiftrocks_property_name,</code>
<code>                   strName);</code>
<code>        }</code>
<code>      }</code>
<code>    }</code>
<code>  }</code>
<code>  //removed: rest of the method</code>
<code>}</code>
</pre>
 <p>I'll spare you the details of <code>hasSwiftRocksAttribute()</code> because I just copied <code>hasDynamicMemberLookupAttribute()</code> and changed the attribute name, but it checks a type's parents until it find the attribute. <a href="https://github.com/apple/swift/blob/bf2a4712ecafbcaa364579dd762e3f7398331bf9/lib/Sema/CSSimplify.cpp#L3110">Here's the original one if you're curious.</a></p>
 <p>After building the compiler and running the following snippet, all properties of <code>AwesomeClass</code> get their hardwork recognized!</p>
 <pre>
<code>@swiftRocks class AwesomeClass {</code>
<code>    let number: Int = 1  //warning: Property 'number' is doing its best. Consider naming it 'numberThatRocks'.</code>
<code>    let stringThatRocks: String = "stringy"</code>
<code>}</code>
</pre>
 <h2>Conclusion</h2>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>I enjoy researching these features because they tell you a lot about how the language works. In this case, we can see that attributes have infinite possibilities - from stupid name checks to making properties pop from thin air. One might argue that they aren't "swifty" compared to the rest of the language, but they'll likely continue to be an integral part of the language for years to come.</p>
 <p>Follow me on my Twitter - <a href="https://twitter.com/rockbruno_">@rockbruno_</a>, and let me know of any suggestions and corrections you want to share.</p>
 <h2>References and Good reads</h2>
 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0195-dynamic-member-lookup.md">SE-0195 - @dynamicMemberLookup</a>
 <br>
 <a href="https://github.com/apple/swift/pull/14546">Original implementation of SE-0195</a>
 <br>
 <a href="https://github.com/apple/swift/blob/master/docs/TypeChecker.rst">Typechecker Docs</a>
 <br>
 <a href="https://github.com/apple/swift">The Swift Source Code</a>
 <br>
</div>]]></description>
</item>
<item>
    <title>How Never Works Internally in Swift</title>
    <link>https://swiftrocks.com/how-never-works-internally-in-swift</link>
    <guid>https://swiftrocks.com/how-never-works-internally-in-swift</guid>
    <pubDate>Wed, 14 Nov 2018 11:42:07 GMT-2</pubDate>
<description><![CDATA[
 
  
  <!--WRITEIT_POST_NAME=How Never Works Internally in Swift--> 
  <!--WRITEIT_POST_HTML_NAME=how-never-works-internally-in-swift--> 
  <!--WRITEIT_POST_SITEMAP_DATE_LAST_MOD=2020-04-12T14:00:00+02:00--> 
  <!--WRITEIT_POST_SITEMAP_DATE=2018-11-14T13:42:07+00:00--> 
  <!--Add here the additional properties that you want each page to possess.--> 
  <!--These properties can be used to change content in the template page or in the page itself as shown here.--> 
  <!--Properties must start with 'WRITE_IT_POST'.--> 
  <!--Writeit provides and injects WRITEIT_POST_NAME and WRITEIT_POST_HTML_NAME by default.--> 
  <!--WRITEIT_POST_SHORT_DESCRIPTION=Added in Swift 3, the Never type allows you to define a method that is guaranteed to crash your app.--> 
  <title>How Never Works Internally in Swift</title>  
 

<div class="blog-post"> 
 <div class="post-title-index">  
  <h1>How Never Works Internally in Swift</h1>
 </div> 
 <div class="post-info"> 
  <div class="category category-compiler">
   Compiler
  </div> 
  <div class="category category-swift">
   Swift
  </div> 
  <div class="post-info-text">
   Published on 14 Nov 2018 
  </div> 
 </div>  
 <p>Added in Swift 3, the <code>Never</code> type allows you to define a method that is guaranteed to crash your app. Although we rarely write methods that use this type directly, we do interact with it constantly given that it is the return type of forced-crash methods like <code>fatalError()</code>. The advantage this type brings is that a method that calls another <code>Never</code>-returning method does not need to provide a return value, after all, a crash is certain to happen:</p>
 <pre>
<code>func getSomeNumber() -&gt; Int</code>
<code>    fatalError()</code>
<code>    //I'm not returning an Int, but this still compiles</code>
<code>    //because fatalError() returns 'Never'.</code>
<code>}</code>
</pre>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>Deep down, <code>Never</code> is just the revamped "swifty" version of <code>@noreturn</code>: an attribute which provided the exact same functionality but was removed for being too complex due to its nature as an attribute. Connecting this behaviour to a return type allowed the compiler to work better, and certainly ended up looking better for the developer as well.</p>
 <p>Something about <code>Never</code> intrigued me, though. We know that there's nothing in the language itself that allows you to skip return values, so what magic is done in the compiler to allow this?</p>
 <p>Just like in my <a href="https://swiftrocks.com/how-caseiterable-works-internally-in-swift">previous article about the innards of CaseIterable</a>, I'm going to dive into the compiler in order to extract and analyze the pieces of code that intercept and change the functionality of methods that return <code>Never</code> in order to learn more about how the Swift compiler works.</p>
 <p><i>Disclaimer: As always, this is a result of my own research and reverse-engineering. As I obviously have nothing to do with the original development of <code>Never</code>, some assumptions might be not fully correct. Feel free to correct me if you know how the compiler works!</i></p>
 <h2>Uninhabited Types / Never Patterns</h2>
 <p>Expecting to find complex pieces of code, the implementation of <code>Never</code> in the Standard Library show us something else - the type is nothing but an empty enum:</p>
 <pre>
<code>public enum Never {}</code>
</pre>
 <p>Although that certainly looks weird, it is correct in its theory. When <code>Never</code> got implemented, Swift also added the concept of <b>uninhabited types</b> to its lingo - a type with no value, often used to represent the unexistant result of something that will never happen. Because an enum with no cases can't be instantiated in any way, it becomes perfect to represent this concept. But if the type itself doesn't do anything, where is the magic done?</p>
 <p>A quick search for <code>"never typecheck"</code> in the Swift repo reveals a method called <code>isNoReturnFunction()</code>, which searches for the presence of an uninhabited type return:</p>
 <pre>
<code>bool SILFunctionType::isNoReturnFunction() const {</code>
<code>    for (unsigned i = 0, e = getNumResults(); i &lt; e; ++i) {</code>
<code>        if (getResults()[i].getType()-&gt;isUninhabited())</code>
<code>            return true;</code>
<code>    }</code>
<code>    return false;</code>
<code>}</code>
</pre>
 <p>The implementation of the mentioned <code>isUninhabited()</code> itself just checks if we're dealing with an empty enum:</p>
 <pre>
<code>bool TypeBase::isUninhabited() {</code>
<code>    // Empty enum declarations are uninhabited</code>
<code>    if (auto nominalDecl = getAnyNominal())</code>
<code>        if (auto enumDecl = dyn_cast&lt;EnumDecl&gt;(nominalDecl))</code>
<code>            if (enumDecl-&gt;getAllElements().empty())</code>
<code>                return true;</code>
<code>    return false;</code>
<code>}</code>
</pre>
 <p>Because <code>Never</code> has no actual code, I expected the compiler to directly identify and change it somehow, but what this shows is that <code>Never</code> <b>really</b> is just an empty enum - the behaviour we see has nothing to do with the type itself, but with the concept of an uninhabited type. This means that you don't need <code>Never</code> at all to ignore return statements:</p>
 <pre>
<code>enum Crash {}</code>
<code></code>
<code>func logAndCrash() -&gt; Crash {</code>
<code>    print("Oops!")</code>
<code>    fatalError()</code>
<code>}</code>
<code></code>
<code>func doSomething() -&gt; Int {</code>
<code>    logAndCrash() //Compiles!</code>
<code>}</code>
</pre>
 <p>In fact, because the compiler doesn't know the difference, my <code>Crash</code> type will even throw errors that mention <code>Never</code>:</p>
 <pre>
<code>func logAndCrash() -&gt; Crash {</code>
<code>    //Function with uninhabited return type 'Crash'</code>
<code>    //is missing call to another never-returning function on all paths</code>
<code>}</code>
</pre>
 <p>For completeness, the very first commit of <code>Never</code> was indeed using the type itself to generate this behaviour, but it was later changed to work with all uninhabited types due to multiple bugs that a <code>Never</code>-only solution was causing.</p>
 <p>That's a great start, but I still have two major questions:</p>
 <p>First, where are these methods used?</p>
 <p>Second, if all never-returning methods need to return another never-returning method, don't we have an infinite recursion? Because the app is guaranteed to crash, <b>someone</b> down the line will have to not return something. Who makes this decision?</p>
 <h2>SIL generation of Never-returning methods</h2>
 <p>The first question can be answered by inspecting what Swift does to your code during the compile process. To make it straight-forward, the secrets of <code>Never</code> are hidden into a source file's SIL representation.</p>
 <h3>Swift Intermediate Language</h3>
 <p>In short, SIL is the middle-ground between your .swift files and the LLVM IR, basically acting as your Swift files translated to a "language" that contains high-level semantic information of what's happening behind the scenes. This allows the compiler to diagnose compilation errors and perform early optimizations while still allowing it to seamlessly generate the final LLVM IR necessary to let LLVM handle the rest of the compilation.</p>
 <div class="post-image margin-top-40 margin-bottom-40"> 
  <img src="https://i.imgur.com/xbVOfbq.png" alt="" style="background-color: #fff"> 
 </div>
 <p>Inspecting the SIL version of a method that returns <code>Never</code> should reveal us an optimized version of it, with hopefully an indicator of how the type works behind the scenes. I'm going to compile the following snippet - with an explicit return statement just to see how the SIL version reacts to it:</p>
 <pre>
<code>@inline(never) func crash() -&gt; Never {</code>
<code>    fatalError()</code>
<code>}</code>
<code></code>
<code>func doSomething() -&gt; Int {</code>
<code>    crash()</code>
<code>    let number = 1+1</code>
<code>    let otherNumber = number * 2</code>
<code>    return otherNumber</code>
<code>}</code>
</pre>
 <pre class="command-line language-bash" data-host="SwiftRocks">
<code>swiftc -emit-sil never.swift</code>
</pre>
 <p>After running the command above, the output will contain the following reference to <code>doSomething()</code>:</p>
 <pre>
<code>// doSomething()</code>
<code>sil hidden @$S5never11doSomethingSiyF : $@convention(thin) () -&gt; Int {</code>
<code>bb0:</code>
<code>  // function_ref crash()</code>
<code>  %0 = function_ref @$S5never5crashs5NeverOyF : $@convention(thin) () -&gt; Never // user: %1</code>
<code>  %1 = apply %0() : $@convention(thin) () -&gt; Never</code>
<code>  unreachable // id: %2</code>
<code>} // end sil function '$S5never11doSomethingSiyF'</code>
</pre>
 <p>SIL is not very easy to read, but it thankfully comes with a few comments that helps us understand what's going on. The first thing we can notice here is the beauty of optimizations: all the unreachable number code I added there is completely gone!</p>
 <p>Besides that, we can see that an <code>unreachable</code> statement was added right after the call to <code>crash()</code>. Normal methods would show a return statement, so this was clearly added by the whatever logic handles <code>Never</code>.</p>
 <p>A quick search into the Swift repo revealed that <code>unreachable</code> relates to <code>UnreachableInst</code>, a type that is injected and later used when the compiler needs to make decisions when it comes to code that will never succeed, or even be executed in this case.</p>
 <pre>
<code>TERMINATOR(UnreachableInst, unreachable,</code>
<code>           TermInst, None, DoesNotRelease)</code>
</pre>
 <p>However, this type is not exclusively used by <code>Never</code>, so more investigation is needed: After attaching lldb to the command used above and creating a breakpoint for <code>UnreachableInst</code>'s init, a call inside <code>simplifyBlocksWithCallsToNoReturn()</code> is revealed: a method defined inside <code>DiagnoseUnreachable.cpp</code>, whose's backtrace revealed it to be one of the mandatory optimization passes before attempting to generate the final LLVM IR. (take a look at my CaseIterable article for details on how to manually use lldb!)</p>
 <p><a href="https://github.com/apple/swift/blob/ad8cd1423398124f7dea0441395ba9c42ed6a0d6/lib/SILOptimizer/Mandatory/DiagnoseUnreachable.cpp#L473">The actual method is quite large</a>, so I've pseudo-coded it:</p>
 <pre>
<code>static bool simplifyBlocksWithCallsToNoReturn(SILBasicBlock &amp;BB,</code>
<code>                                 UnreachableUserCodeReportingState *State) {</code>
<code>    if method_returns_never</code>
<code>        delete_everything_after_call</code>
<code>        inject_fake_unreachable_instruction</code>
<code>}</code>
</pre>
 <p>This does exactly what we've seen in the snippet, but still doesn't answer the first question! Why is this enough to stop requiring return values?</p>
 <p>The answer is another mandatory optimization pass file named <code>DataflowDiagnostics.cpp</code>: the responsible for throwing unreachable-related compilation errors such as "missing return", "guard body missing return" and the "never method must call another never-method" from the previous examples.</p>
 <p>One of the methods inside this file is called <code>diagnoseMissingReturn()</code>, which throws the "missing return" error: (note the call to <code>isNoReturnFunction()</code> to throw the different <code>Never</code> error!)</p>
 <pre>
<code>static void diagnoseMissingReturn(const UnreachableInst *UI,</code>
<code>                                  ASTContext &amp;Context) {</code>
<code>    //Removed: Retrieving type data</code>
<code>    auto diagID = F-&gt;isNoReturnFunction() ? diag::missing_never_call</code>
<code>                                          : diag::missing_return;</code>
<code></code>
<code>    //"diagnose" throws the compilation error</code>
<code>    diagnose(Context,</code>
<code>             L.getEndSourceLoc(),</code>
<code>             diagID, ResTy,</code>
<code>             FLoc.isASTNode&amp;ClosureExpr&gt;() ? 1 : 0);</code>
<code>}</code>
</pre>
 <p>The decision to call <code>diagnoseMissingReturn()</code> is handled by <code>diagnoseUnreachable()</code>, which checks if the relevant <code>UnreachableInst</code> points to an actual position in the code (when you're really missing a return, so throw an error) or was injected by the compiler (like returning <code>Never</code>, so do nothing), which is exactly our case. Remember that the previous optimization removed everything after the <code>Never</code> call, so we only have the injected one at this point:</p>
 <pre>
<code>static void diagnoseUnreachable(const SILInstruction *I,</code>
<code>                                ASTContext &amp;Context) {</code>
<code>  if (auto *UI = dyn_cast&lt;UnreachableInst&gt;(I)) {</code>
<code>    SILLocation L = UI-&gt;getLoc();</code>
<code></code>
<code>    // Invalid location means that the instruction has been generated by SIL</code>
<code>    // passes, such as DCE. FIXME: we might want to just introduce a separate</code>
<code>    // instruction kind, instead of keeping this invariant.</code>
<code>    //</code>
<code>    // We also do not want to emit diagnostics for code that was</code>
<code>    // transparently inlined. We should have already emitted these</code>
<code>    // diagnostics when we process the callee function prior to</code>
<code>    // inlining it.</code>
<code>    if (!L || L.is&lt;MandatoryInlinedLocation&gt;())</code>
<code>      return;</code>
<code></code>
<code>    // The most common case of getting an unreachable instruction is a</code>
<code>    // missing return statement. In this case, we know that the instruction</code>
<code>    // location will be the enclosing function.</code>
<code>    if (L.isASTNode&lt;AbstractFunctionDecl&gt;() || L.isASTNode&lt;ClosureExpr&gt;()) {</code>
<code>      diagnoseMissingReturn(UI, Context);</code>
<code>      return;</code>
<code>    }</code>
<code></code>
<code>    if (auto *Guard = L.getAsASTNode&lt;GuardStmt&gt;()) {</code>
<code>      diagnose(Context, Guard-&gt;getBody()-&gt;getEndLoc(),</code>
<code>               diag::guard_body_must_not_fallthrough);</code>
<code>      return;</code>
<code>    }</code>
<code>  }</code>
<code>}</code>
</pre>
 <p>In summary, <code>Never</code>'s behaviour is defined in the optimization passes - after <code>DiagnoseUnreachable.cpp</code> detects and marks the instruction after a never call as unreachable, <code>DataflowDiagnostics.cpp</code> sees that this specific unreachable statement was injected by the compiler itself, avoids throwing a "missing return" compilation error and lets the compilation continue.</p>
 <h2>Internals of <code>fatalError()</code></h2>
 <p>Although the main functionality is now uncovered, something still bugs me: we've seen that creating a <code>Never</code> returning method will result in a compilation error if it doesn't call another <code>Never</code> method. Isn't this an infinite loop? Where is this loop broken?</p>
 <p>To get the answer for that, we can inspect the contents of <code>fatalError()</code> and start going up its backtrace. Here's how <code>fatalError()</code> is defined:</p>
 <pre>
<code>public func fatalError(</code>
<code>  _ message: @autoclosure () -&gt; String = String(),</code>
<code>  file: StaticString = #file, line: UInt = #line</code>
<code>) -&gt; Never {</code>
<code>  _assertionFailure("Fatal error", message(), file: file, line: line,</code>
<code>    flags: _fatalErrorFlags())</code>
<code>}</code>
</pre>
 <p>This will compile correctly, since <code>_assertionFailure</code> also returns <code>Never</code>. Going up the backtrace, we'll see that it has the following implementation:</p>
 <pre>
<code>internal func _assertionFailure(</code>
<code>  _ prefix: StaticString, _ message: StaticString,</code>
<code>  file: StaticString, line: UInt,</code>
<code>  flags: UInt32</code>
<code>) -&gt; Never {</code>
<code>  //Removed: Write to file</code>
<code>  Builtin.int_trap()</code>
<code>}</code>
</pre>
 <p>Now, <code>Builtin.int_trap()</code> also returns <code>Never</code>, so this too will compile correctly. Going up the backtrace, we'll see that <code>int_trap()</code> is defined as... uhhh....</p>
 <p>Actually, there's no definition for this method! <code>Builtin</code> is not a normal framework - it seems to be generated inside the compiler as a way to allow Swift code to directly access LLVM functions. It appears to be all done <a href="https://github.com/apple/swift/blob/4fb4cb058d5d81f5fc3f8aaeb0adec2b933c5511/lib/AST/Builtins.cpp">in Builtins.cpp</a> by parsing <a href="https://github.com/apple/swift-llvm/blob/e9e59b13f33aadfb02075c373d52506b261a26ac/include/llvm/IR/Intrinsics.td#L835">a table all the way from the swift-llvm repository</a> and generating "pre-compiled" Swift methods from them. In this case, <code>int_trap()</code> is parsed as a <code>Never</code> returning method that calls <a href="https://llvm.org/docs/LangRef.html#llvm-trap-intrinsic">llvm.trap()</a>, a function that adds an instruction to blow up your app.</p>
 <p>So how does the infinite loop stops? The answer seems to be that it simply does not. Because the final call of the chain is inside a "pre-compiled framework" in a sense, diagnostics do not seem to affect it, allowing the app to compile correctly.</p>
 <h2>Conclusion</h2>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>That was quite the ride, but I hope that you found this useful. As I mentioned in previous articles, compilers are scary monsters, but knowing the internals of a language can really help you write efficient code. In this case, spelunking <code>Never</code> was interesting to see how each optimization pass complements each other when it comes to finding problems or changing the behaviour of a piece of code.</p>
 <p>Follow me on my Twitter - <a href="https://twitter.com/rockbruno_">@rockbruno_</a>, and let me know of any suggestions and corrections you want to share.</p>
 <h2>References and Good reads</h2>
 <a href="https://github.com/apple/swift">The Swift Source Code</a>
 <br>
 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0102-noreturn-bottom-type.md">SE-0102: Introduce Never</a>
 <br>
 <a href="https://github.com/apple/swift/blob/master/docs/SIL.rst">Swift Intermediate Language</a>
 <br>
 <a href="https://github.com/apple/swift-llvm">swift-llvm</a>
 <br>
 <a href="https://llvm.org/docs/LangRef.html">LLVM Ref</a>
 <br>
</div>]]></description>
</item>
<item>
    <title>What's .self, .Type and .Protocol? Understanding Swift Metatypes</title>
    <link>https://swiftrocks.com/whats-type-and-self-swift-metatypes</link>
    <guid>https://swiftrocks.com/whats-type-and-self-swift-metatypes</guid>
    <pubDate>Mon, 29 Oct 2018 09:23:13 GMT-3</pubDate>
<description><![CDATA[
 
  
  <!--WRITEIT_POST_NAME=What's .self, .Type and .Protocol? Understanding Swift Metatypes--> 
  <!--WRITEIT_POST_HTML_NAME=whats-type-and-self-swift-metatypes--> 
  <!--WRITEIT_POST_SITEMAP_DATE_LAST_MOD=2020-04-12T14:00:00+02:00--> 
  <!--WRITEIT_POST_SITEMAP_DATE=2018-10-29T12:23:13+00:00--> 
  <!--Add here the additional properties that you want each page to possess.--> 
  <!--These properties can be used to change content in the template page or in the page itself as shown here.--> 
  <!--Properties must start with 'WRITE_IT_POST'.--> 
  <!--Writeit provides and injects WRITEIT_POST_NAME and WRITEIT_POST_HTML_NAME by default.--> 
  <!--WRITEIT_POST_SHORT_DESCRIPTION=Metatypes are pretty useful in Swift, and you have certainly used it in multiple occasions. Unfortunately they look pretty weird in code, which can cause some confusion when trying to understand what they really are.--> 
  <title>What's .self, .Type and .Protocol? Understanding Swift Metatypes</title>  
 

<div class="blog-post"> 
 <div class="post-title-index">  
  <h1>What's .self, .Type and .Protocol? Understanding Swift Metatypes</h1>
 </div> 
 <div class="post-info"> 
  <div class="category category-swift">
   Swift
  </div> 
  <div class="post-info-text">
   Published on 29 Oct 2018 
  </div> 
 </div>   
 <p>Ah metatypes. That's another one for the list of <i>things I use everyday but couldn't explain in an interview if my life depended on it</i>.</p>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>Metatypes are pretty useful in Swift, and you have certainly used it in multiple occasions. Unfortunately they look pretty weird in code, which can cause some confusion when trying to understand what they really are.</p>
 <p>I for one know how these weird suffixes can confuse you, but don't worry, they are actually pretty straightforward once you get to know the differences between each of them. But before getting into that, let's take a step back:</p>
 <h2>What's a Metatype?</h2>
 <p>If you take a look at Apple's docs, you'll see that a metatype is defined as being the <b>type of a type</b>. Wait, isn't <code>String</code> a type? What could possibly be type of a <code>String</code> that's already a type? <code>SuperString</code>??</p>
 <p>It sounds weird in theory, but that's because we got used to Swift's syntax which specifically hides some of these details from us in order to make the language easy to use. To understand metatypes, try to stop seeing things as types and start seeing them more as <b>instances</b> and <b>classes</b> (the usage keyword, not the object!) instead.</p>
 <p>Considering the following snippet: How would you define <code>SwiftRocks()</code> and <code>: SwiftRocks</code>?</p>
 <pre>
<code>struct SwiftRocks {</code>
<code>    static let author = "Bruno Rocha"</code>
<code>    func postArticle(name: String) {}</code>
<code>}</code>
<code></code>
<code>let blog: SwiftRocks = SwiftRocks()</code>
</pre>
 <p>You can say that <code>SwiftRocks()</code> is an object and <code>SwiftRocks</code> is its type, but instead, try seeing <code>SwiftRocks()</code> as an <b>instance</b>, and <code>: SwiftRocks</code> itself as the representation of the <b>type of an instance</b>. After all, you can call the instance method <code>postArticle()</code> from <code>blog</code>, but you can't access the class property <code>author</code>.</p>
 <p>Now, how can we access <code>author</code>? The most common way would be through <code>SwiftRocks.author</code> which will directly return you a <code>String</code>, but I will ask you to forget about that one for a moment. Is there another way?</p>
 <p><i>I know that Bruno! You can call <code>type(of: blog).author</code>!</i></p>
 <p>Yup! That is also correct, as <code>type(of)</code> transforms something an object into something that allows you to access all class properties. But have you ever tried to call <b>just</b> <code>type(of: blog)</code> to see what would happen?</p>
 <pre>
<code>let something = type(of: blog) // SwiftRocks.Type</code>
</pre>
 <p>One of the weird suffixes! The <b>type of SwiftRocks</b> is <code>SwiftRocks.Type</code>, which means that <code>SwiftRocks.Type</code> is <code>SwiftRocks's</code> <b>metatype</b>.</p>
 <p>By using Xcode's code completion on the <code>something</code> property, you'll see that a reference to a metatype allows you to use all of that type's class properties and methods, including <code>init()</code>:</p>
 <pre>
<code>let author: String = something.author</code>
<code>let instance: SwiftRocks = something.init()</code>
</pre>
 <p>That's very useful when you want a method to instantiate objects for you (like how <code>UITableView</code> cell reuse and <code>Decodable</code> work), access class properties or just overall do actions based on the type of an object. Doing so in a generic way is easy as you can pass metatypes as arguments:</p>
 <pre>
<code>func createWidget&lt;T: Widget&gt;(ofType: T.Type) -&gt; T {</code>
<code>    let widget = T.init()</code>
<code>    myWidgets.insert(widget)</code>
<code>    return widget</code>
<code>}</code>
</pre>
 <p>Metatypes can also be used in equality checks, which I personally find handy when designing factories:</p>
 <pre>
<code>func create&lt;T: BlogPost&gt;(blogType: T.Type) -&gt; T {</code>
<code>    switch blogType {</code>
<code>    case is TutorialBlogPost.Type:</code>
<code>        return blogType.init(subject: currentSubject)</code>
<code>    case is ArticleBlogPost.Type:</code>
<code>        return blogType.init(subject: getLatestFeatures().random())</code>
<code>    case is TipBlogPost.Type:</code>
<code>        return blogType.init(subject: getKnowledge().random())</code>
<code>    default:</code>
<code>        fatalError("Unknown blog kind!")</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>You can define the metatype of any type, including classes, structs, enums and protocols as being the <b>name of that type followed by </b><code>.Type</code>. In short, while <code>SwiftRocks</code> refers to the type of an instance (which only lets you use instance properties), the metatype <code>SwiftRocks.Type</code> refers to the type of class itself, which lets you use the <code>SwiftRocks's</code> class properties. "type of a type" makes a lot more sense now, right?</p>
 <h2>type(of:) Dynamic Metatypes vs .self Static Metatypes</h2>
 <p>So <code>type(of)</code> returns the metatype of an object, but what happens if I don't have an object? Xcode gives me a compiler error if I try to call <code>create(blogType: TutorialBlogPost.Type)</code>!</p>
 <p>To make it short, the reason you can't do that is the same reason why you can't call <code>myArray.append(String)</code>: <code>String</code> is the name of the type, not the value! To get a metatype as a value, you need to type the <b>name of that type followed by</b> <code>.self</code>.</p>
 <p>If that sounds confusing, you can see it like this: Just like <code>String</code> is the type and <code>"Hello World"</code> is the value of an instance, <code>String.Type</code> is the type and <code>String.self</code> is the value of a metatype.</p>
 <pre>
<code>let intMetatype: Int.Type = Int.self</code>
<code>//</code>
<code>let widget = createWidget(ofType: MyWidget.self)</code>
<code>tableView.register(MyTableViewCell.self, forReuseIdentifier: "myCell")</code>
</pre>
 <p><code>.self</code> is what Apple calls a <b>static metatype</b> - a fancy word for what is the compile time type of an object. You use that more than you expect - remember when I told you to ignore <code>SwiftRocks.author</code>? The reason was because writing that is the same as writing <code>SwiftRocks.self.author</code>.</p>
 <p>Static metatypes are everywhere in Swift, and you implicitly use them every time you access a type's class property directly. You might find interesting that the <code>AnyClass</code> type used by a table's <code>register(cellClass:)</code> is just an alias for <code>AnyObject.Type</code>:</p>
 <pre>
<code>public typealias AnyClass = AnyObject.Type</code>
</pre>
 <p>On the other hand, <code>type(of)</code> will return a <b>dynamic metatype</b>, which is the metatype of the object's real, runtime type.</p>
 <pre>
<code>let myNum: Any = 1 // Compile time type of myNum is Any, but the runtime type is Int.</code>
<code>type(of: myNum) // Int.type</code>
</pre>
 <p>The actual contents of <code>type(of:)</code> and its <code>Metatype</code> return type are compiler magic (a subject for another article), but here's the method's signature:</p>
 <pre>
<code>func type&lt;T, Metatype&gt;(of value: T) -&gt; Metatype {}</code>
</pre>
 <p>In short, if the subclass of an object matters, you should use <code>type(of)</code> in order to have access to that subclass's metatype. Otherwise, you can simply access the static metatype directly through <code>(name of the desired type).self</code>.</p>
 <p>An interesting property of metatypes is that they are recursive, which means you can have meta-metatypes like <code>SwiftRocks.Type.Type</code>, but thankfully for our sanity, you can't do much with these as it's currently impossible to write extensions for metatypes.</p>
 <h2>Protocol Metatypes</h2>
 <p>Although everything said before applies to protocols, they have an important difference. The following code will not compile:</p>
 <pre>
<code>protocol MyProtocol {}</code>
<code>let metatype: MyProtocol.Type = MyProtocol.self // Cannot convert value of...</code>
</pre>
 <p>The reason for that is that in the context of protocols, <code>MyProtocol.Type</code> doesn't refer to the protocol's own metatype, but the metatype of whatever type is <b>inheriting</b> that protocol. Apple calls this an <b>existential metatype</b>.</p>
 <pre>
<code>protocol MyProtocol {}</code>
<code>struct MyType: MyProtocol {}</code>
<code>let metatype: MyProtocol.Type = MyType.self // Now works!</code>
</pre>
 <p>In this case, <code>metatype</code> only has access to <code>MyProtocol</code> class properties and methods, but <code>MyType's</code> implementations will be called. To get the <b>concrete metatype</b> of the protocol type itself, you can use the <code>.Protocol</code> suffix. That's basically the same as using <code>.Type</code> on other types.</p>
 <pre>
<code>let protMetatype: MyProtocol.Protocol = MyProtocol.self</code>
</pre>
 <p>Because we're referring to the uninherited protocol itself, there's nothing you can really do with <code>protMetatype</code> besides simple equality checks like <code>protMetatype is MyProtocol.Protocol</code>. If I had to make a guess, I would say that a protocol's concrete metatype's purpose is more about making protocols work in the compiler side of things, which is likely why we never see it in iOS projects.</p>
 <h2>Conclusion: More uses for Metatypes</h2>
 <p>Representing a type through a metatype can help you build very intelligent and type-safe generic systems. Here's an example of how we use them in deep link handlers to prevent having to deal with strings directly:</p>
 <pre>
<code>public protocol DeepLinkHandler: class {</code>
<code>    var handledDeepLinks: [DeepLink.Type] { get }</code>
<code>    func canHandle(deepLink: DeepLink) -&gt; Bool</code>
<code>    func handle(deepLink: DeepLink)</code>
<code>}</code>
<code></code>
<code>public extension DeepLinkHandler {</code>
<code>    func canHandle(deepLink: DeepLink) -&gt; Bool {</code>
<code>        let deepLinkType = type(of: deepLink)</code>
<code>        //Unfortunately, metatypes can't be added to Sets as they don't conform to Hashable!</code>
<code>        return handledDeepLinks.contains { $0.identifier == deepLinkType.identifier }</code>
<code>    }</code>
<code>}</code>
<code></code>
<code>//</code>
<code></code>
<code>class MyClass: DeepLinkHandler {</code>
<code>    var handledDeepLinks: [DeepLinks.Type] {</code>
<code>        return [HomeDeepLink.self, PurchaseDeepLink.self]</code>
<code>    }</code>
<code></code>
<code>    func handle(deepLink: DeepLink) {</code>
<code>        switch deepLink {</code>
<code>        case let deepLink as HomeDeepLink:</code>
<code>           //</code>
<code>        case let deepLink as PurchaseDeepLink:</code>
<code>           //</code>
<code>        default:</code>
<code>           //</code>
<code>        }</code>
<code>    }</code>
<code>}</code>
</pre>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>And as a more recent example, here's how we use metatypes to represent and retrieve information about A/B tests (called "Experiments"):</p>
 <pre>
<code>if ExperimentManager.get(HomeExperiment.self)?.showNewHomeScreen == true {</code>
<code>    //Show new home</code>
<code>} else {</code>
<code>    //Show old home</code>
<code>}</code>
<code></code>
<code>// Experiment Manager</code>
<code></code>
<code>public static func get&lt;T: Experiment&gt;(_ experiment: T.Type) -&gt; T? {</code>
<code>    return shared.experimentDictionary[experiment.identifier] as? T</code>
<code>}</code>
<code></code>
<code>public static func activate(_ experiment: Experiment) {</code>
<code>    shared.experimentDictionary[type(of: experiment).identifier] = experiment</code>
<code>}</code>
</pre>
 <p>Follow me on my Twitter - <a href="https://twitter.com/rockbruno_">@rockbruno_</a>, and let me know of any suggestions and corrections you want to share.</p>
 <h2>References and Good reads</h2>
 <a href="https://docs.swift.org/swift-book/ReferenceManual/Types.html#//apple_ref/swift/grammar/metatype-type">Apple Docs: Types</a>
 <br>
 <a href="https://developer.apple.com/documentation/swift/2885064-type">Apple Docs: type(of:)</a>
 <br>
</div>]]></description>
</item>
<item>
    <title>Unowned Properties in Swift</title>
    <link>https://swiftrocks.com/unowned-properties-in-swift</link>
    <guid>https://swiftrocks.com/unowned-properties-in-swift</guid>
    <pubDate>Fri, 26 Oct 2018 10:42:07 GMT-3</pubDate>
<description><![CDATA[
 
  
  <!--WRITEIT_POST_NAME=Unowned Properties in Swift--> 
  <!--WRITEIT_POST_HTML_NAME=unowned-properties-in-swift--> 
  <!--WRITEIT_POST_SITEMAP_DATE_LAST_MOD=2020-04-12T14:00:00+02:00--> 
  <!--WRITEIT_POST_SITEMAP_DATE=2018-10-26T13:42:07+00:00--> 
  <!--Add here the additional properties that you want each page to possess.--> 
  <!--These properties can be used to change content in the template page or in the page itself as shown here.--> 
  <!--Properties must start with 'WRITE_IT_POST'.--> 
  <!--Writeit provides and injects WRITEIT_POST_NAME and WRITEIT_POST_HTML_NAME by default.--> 
  <!--WRITEIT_POST_SHORT_DESCRIPTION=Learn more about this alternative to weak properties in Swift.--> 
  <title>Unowned Properties in Swift</title>  
 

<div class="blog-post"> 
 <div class="post-title-index">  
  <h1>Unowned Properties in Swift</h1>
 </div> 
 <div class="post-info"> 
  <div class="category category-swift">
   Swift
  </div> 
  <div class="post-info-text">
   Published on 02 May 2018 
  </div> 
 </div>   
 <p>It's very common to use the <code>weak</code> keyword in order to prevent reference cycles in properties like delegates:</p>
 <pre class="language-swift"><code class="language-swift">weak var delegate: HomeViewDelegate?</code></pre>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>Unfortunately, since it protects you from references being lost, the <code>weak</code> keyword forces the usage of <code>var</code> and an optional type, which can be quite jarring if you're building something like an <code>UIView</code> that is not supposed to be used without a delegate - much less change delegates suddenly:</p>
 <pre class="language-swift"><code class="language-swift">class HomeView: UIView {
    weak var delegate: HomeViewDelegate?

    func renderView() {
        guard let delegate = delegate else {
            //Timmy: this should never happen!
            return
        }
        let category = delegate.currentlySelectedCategory()
        categoryView.render(category: category)
        delegate.homeViewDidUpdate()
    }
}
</code></pre>
 <p>But <code>weak</code> is not the only way of breaking reference cycles. Just like in capture lists, the <code>unowned</code> keyword can be used in properties to create non-strong references:</p>
 <pre class="language-swift"><code class="language-swift">unowned let delegate: HomeViewModelDelegate</code></pre>
 <p>Unlike <code>weak</code>, <code>unowned</code> references are expected to always have a value. This allows you to not only use non-optional types when declaring them, but also to do so with <code>let</code>, bringing back immutability and making sure your objects won't act in unexpected ways:</p>
 <pre class="language-swift"><code class="language-swift">class HomeView: UIView {
    private unowned let delegate: HomeViewDelegate

    init(delegate: HomeViewDelegate) {
        self.delegate = delegate
        super.init(frame: .zero)
    }

    func renderView() {
        let category = delegate.currentlySelectedCategory()
        categoryView.render(category: category)
        delegate.homeViewDidUpdate()
    }
}
</code></pre>
 <p>With <code>weak</code>, there's nothing stopping <code>HomeView</code> from being used without a delegate, and a <code>guard</code> is required to unwrap values retrieved from the delegate due to the optional requirement of the keyword. On the other hand, <code>unowned</code> allows you to break reference cycles while still using the reference just like if it was strong.</p>
 <p>However, be aware that <code>unowned</code> properties will work just like the capture list keyword. If you try to access an unowned reference that has already deallocated, your app will crash.</p>
 <p>If your object is guaranteed to never outlive its unowned reference (like a <code>ViewModel</code>, for example), usage of <code>unowned</code> can greatly improve both code quality and performance.</p>
 <h2>But <code>unowned</code> can crash your app just like implicitly unwrapped optionals. Shouldn't you use <code>weak</code> for everything?</h2>
 <p>Most people rely on <code>weak</code> for everything and frown upon <code>unowned</code> due to its potential crashes, specially on capture lists. This is a safe way to use Swift, but not Apple's intended practice.</p>
 <p>Unlike implicitly unwrapped optionals, which in my opinion are just a lazy way of overcoming architectural problems, <code>unowned</code> references have significant advantages over <code>weak</code> ones: They have better performance, allow immutability, and since they can't be manually set to <code>nil</code>, your code will not accidentally follow unexpected paths. <code>unowned</code> references are perfectly safe - problems will only arise if you misuse the keyword.</p>
 <p>According to Apple, you should always use <code>unowned</code> references when your object can't outlive its reference:</p>
 <blockquote>
  <p>Use an unowned reference only when you are sure that the reference&nbsp;always&nbsp;refers to an instance that has not been deallocated.</p> 
  <p>If you try to access the value of an unowned reference after that instance has been deallocated, you‚Äôll get a runtime error.</p> 
  <p>If the captured reference will never become&nbsp;nil, it should always be captured as an unowned reference, rather than a weak reference.</p>
 </blockquote>
 <p>In any other cases, you should keep using <code>weak</code> references.</p>
 <h2>What else?</h2>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>The next time you create a delegate or an <code>@escaping</code> closure, think about its context and see if it's possible for it to outlive its reference. If it doesn't, you might find <code>unowned</code> properties an interesting tool to improve your code's quality.</p>
 <p>Follow me on my Twitter - <a href="https://twitter.com/rockbruno_">@rockbruno_</a>, and let me know of any suggestions and corrections you want to share.</p>
 <h2>References and Good reads</h2>
 <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/AutomaticReferenceCounting.html">Apple Docs: ARC and Keywords</a>
 <br>
</div>]]></description>
</item>
<item>
    <title>Understanding DispatchQueues</title>
    <link>https://swiftrocks.com/understanding-dispatchqueues</link>
    <guid>https://swiftrocks.com/understanding-dispatchqueues</guid>
    <pubDate>Fri, 26 Oct 2018 10:42:07 GMT-3</pubDate>
<description><![CDATA[
 
  
  <!--WRITEIT_POST_NAME=Understanding DispatchQueues--> 
  <!--WRITEIT_POST_HTML_NAME=understanding-dispatchqueues--> 
  <!--WRITEIT_POST_SITEMAP_DATE_LAST_MOD=2020-04-12T14:00:00+02:00--> 
  <!--WRITEIT_POST_SITEMAP_DATE=2018-10-26T13:42:07+00:00--> 
  <!--Add here the additional properties that you want each page to possess.--> 
  <!--These properties can be used to change content in the template page or in the page itself as shown here.--> 
  <!--Properties must start with 'WRITE_IT_POST'.--> 
  <!--Writeit provides and injects WRITEIT_POST_NAME and WRITEIT_POST_HTML_NAME by default.--> 
  <!--WRITEIT_POST_SHORT_DESCRIPTION=Multithreading in general is a difficult thing to fully understand, but understanding how the CPU deals with concurrency is the key to writing good, fast code that does what you expected it to do. Otherwise, you might be abusing your user's CPUs but thinking everything is fine because they are too fast for you to notice that something is wrong.--> 
  <title>Understanding DispatchQueues</title>  
 

<div class="blog-post"> 
 <div class="post-title-index">  
  <h1>Understanding DispatchQueues</h1>
 </div> 
 <div class="post-info"> 
  <div class="category category-swift">
   Swift
  </div> 
  <div class="post-info-text">
   Published on 14 Feb 2018 
  </div> 
 </div>  
 <i>What on earth are these "DispatchQueues"?<br></i>
 <i>Why do I have to use it to send UI code to the main thread? It clearly still works if I do nothing.<br></i>
 <i>What's the point of these "Quality of Services" queues? I use .main for everything and never had a problem.<br></i>
 <i>Why do I get a crash if I call DispatchQueue.main.sync? What's the point of it?<br></i>
 <i>Just what is this Main Thread anyway?</i>
 <br>
 <br>
 <p>If you're developing iOS apps for more than a few weeks, then you have probably dealt with concurrent code before. If you have no background on Operating Systems, you may have asked yourself one of these questions.</p>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>Multithreading in general is a difficult thing to fully understand, but understanding how the CPU deals with concurrency is the key to writing good, fast code that does what you expected it to do. Otherwise, you might be abusing your user's CPUs but thinking everything is fine because they are too fast for you to notice that something is wrong.</p>
 <p>Before we can answer these questions, we need to take a step back and understand how things work behind the scenes.</p>
 <h2>What's a Process?</h2>
 <p>The definition of a process is quite simple: it is a running program. Your app is a process, Slack is a process, Safari is a process, and so on. It contains a list of instructions (your code in Assembly format) and sits there on your disk until the user wishes to run it. The OS will then load that process into memory, start an <b>instruction pointer</b> that tells us which instruction of the program is currently being executed, and have the CPU sequentially execute its instructions until they end, terminating the process.</p>
 <pre>        Address space of a single thread process
|- - - - - - - - - - - - - - - - - - - - - - - - - - |
|                    Instructions                    |
|- - - - - - - - - - - - - - - - - - - - - - - - - - -
|                    Global Data                     |
|- - - - - - - - - - - - - - - - - - - - - - - - - - -
|           malloc'd data (Reference Types)          |
|- - - - - - - - - - - - - - - - - - - - - - - - - - -
| Nothing (Stack and malloc'd data grow towards here)|
|- - - - - - - - - - - - - - - - - - - - - - - - - - -
|   Stack (Value Types (if possible), args, returns) |
|- - - - - - - - - - - - - - - - - - - - - - - - - - -</pre>
 <p>Each process gets its own section of physical memory dedicated to itself. They do not share these addresses with other processes.</p>
 <h2>I'm reading something on Safari while listening to Spotify. How can the CPU run several processes at the same time?</h2>
 <p>It can't. What you are experiencing is an illusion caused by the absurd amount of speed a CPU has.</p>
 <p>A CPU simply cannot do two things at the same time. Things are slightly different for CPUs with multiple cores, but for simplicity, let's assume we only have one CPU: What happens is that it executes something in Safari, then something in Spotify, then something in iOS, then something in Safari again, and so on. The OS will save whatever the CPU was doing for a specific process in memory (in the form of registers and pointers), decide what will be the next process to run, retrieve what it was doing for that process, have the CPU run it for a while, and repeat. This is called a <b>context switch</b> and it happens very, very quickly, giving the impression it can actually run several things at once. (In CPUs with multiple cores the work can be divided between the cores, actually doing several things at once. However, the same principles apply when all the cores are in use.)</p>
 <p>The exact way the OS decides what should be the next process to run is rather complex (read the book at the end of the article if you're interested), but what you should know is that it's possible to dictate manually what's the "priority" of something in our app. (Are iOS's "Quality of Services" starting to making sense now?)</p>
 <h2>What's a Thread?</h2>
 <p>Instead of the classic concept of a single thread process that starts at a <code>main()</code> function and ends at some <code>exit()</code> a few lines below, a multi-threaded program has more than one point of execution (each of which is being fetched and executed from). Perhaps another way to think of this is that each thread is very much like a separate process, except for one difference: they share the same address space and thus can access the same data.</p>
 <pre>        Address space of a multi-threaded process
|- - - - - - - - - - - - - - - - - - - - - - - - - - |
|                    Instructions                    |
|- - - - - - - - - - - - - - - - - - - - - - - - - - -
|                    Global Data                     |
|- - - - - - - - - - - - - - - - - - - - - - - - - - -
|           malloc'd data (Reference Types)          |
|- - - - - - - - - - - - - - - - - - - - - - - - - - -
| Nothing (Stack and malloc'd data grow towards here)|
|- - - - - - - - - - - - - - - - - - - - - - - - - - -
|                 Stack of Thread 2                  |
|- - - - - - - - - - - - - - - - - - - - - - - - - - -
|                 Stack of Thread 1                  |
|- - - - - - - - - - - - - - - - - - - - - - - - - - -</pre>
 <p>Just like processes, a CPU cannot run two threads at the same time - they are instead targeted by <b>context switches</b> just like processes. The CPU runs something in Safari's Thread 1 (which is doing some UI updates), then something in Spotify's Thread 3 (which is downloading a song), then something in Safari's Thread 2 (which is pinging a DNS), and so on.</p>
 <h2>iOS: The Main Thread</h2>
 <p>Your iOS app has several threads. The <b>Main Thread</b> is simply the intial starting point of execution in your app (starting for you at <code>didFinishLaunchingWithOptions</code>). The Main Thread executes a loop every frame (a <code>RunLoop</code>) that draws the current screen if needed, handles UI events such as touches and executes the contents of the <code>DispatchQueue.main</code>. It keeps doing this until the app is terminated. It has extremely high priority - pretty much anything on it gets executed immediatly. That's why you need to route UI code to the Main Thread - by execute some UI-changing code outside of it, your code might start running properly only to suddenly get <b>context switched</b> for several miliseconds because something more important arrived to the OS (like a notification). Your UI updates will then be delayed, giving a bad experience to your users.</p>
 <p>However, you can't simply execute <b>everything</b> on the Main Thread. Since this thread deals with everything related to screen draws / UI updates, if you run a huge task on it, it won't be able to do anything else until it ends. That's why we need several threads (points of execution) to begin with.</p>
 <pre>
<code>@IBAction func actionOne(_ sender: Any) {</code>
<code>    //Button actions are in the Main Thread.</code>
<code>    //This takes about 5 seconds to finish</code>
<code>    var counter = 0</code>
<code>    for _ in 0..&lt;1000000000 {</code>
<code>        counter += 1</code>
<code>        //The screen is totally frozen here. How can I scroll my screen (an UI action)</code>
<code>        //If I blocked the thread by doing this meaningless thing?</code>
<code>        //The scroll action is waiting to be run, but it can't because it's also a Main Thread action.</code>
<code>        //You can't simply context switch actions on the same thread.</code>
<code>        //This needs to be run in a different thread.</code>
<code>    }</code>
<code>}</code>
</pre>
 <h2>iOS: Background Threads and DispatchQueues</h2>
 <p>A background thread is anything that is not the Main Thread. They can run alongside the Main Thread (like they were a different process, but remember the definition of a thread!), dealing with complex tasks without interferring with the Main Thread's UI updates. In iOS, the safest way of spawning a background thread is to use <code>DispatchQueues</code>. However, be aware that DispatchQueues are not threads - they are merely queues of closures that will <b>eventually</b> be forwarded to a relevant thread. A <code>DispatchQueue</code> will automatically create and reuse a pool of threads as it finds necessary, abstracting from you the hassle of spawning threads manually and dealing with potential issues of doing so.</p>
 <p>The Main Thread will <b>serially</b> run the contents of <code>DispatchQueue.main</code> (that is, action 2 only happens after action 1 ends), while the contents of <code>DispatchQueue.global(qos:)</code> will <b>concurrently</b> (everything at the same time) run into background thread(s) (if there are several actions) with priority equal to the priority of the selected QoS. If you'd like custom behavior (such as a queue that forwards closures to a background thread, but serially), you can create your own <code>DispatchQueue</code>.</p>
 <h2>Background Queue Priorities (QoS)</h2>
 <p>By assigning a Quality of Service to an action, you indicate its importance, and the system prioritizes it and schedules it accordingly.</p>
 <p>Because higher priority work is performed more quickly and with more resources than lower priority work, it typically requires more energy than lower priority work. Accurately specifying appropriate QoS classes for the work your app performs ensures that your app is responsive as well as energy efficient.</p>
 <p>There are a few levels of QoS for background threads for several different kinds of actions, but none with higher priority than the Main Thread (after all, there would be no point to this if a background task blocked an UI update, don't you think?). The Quality of Services are:</p>
 <b>UserInteractive</b>
 <br>
 <b>UserInitiated</b>
 <br>
 <b>Utility</b>
 <br>
 <b>Background</b>
 <br>
 <h2>Visualizing the impact of different QoS levels</h2>
 <p>By using <b>Instruments</b>, we can see how the different QoS levels affect the execution of our code.</p>
 <h2>Heavy task on the Main Thread</h2>
 <pre>
<code>@IBAction func actionOne(_ sender: Any) {</code>
<code>    //We already are in the main thread, but we will use a dispatch operation</code>
<code>    //to see how long it takes for the task to begin.</code>
<code>    DispatchQueue.main.async { [unowned self] in</code>
<code>        self.timeIntensiveTask()</code>
<code>    }</code>
<code>}</code>
</pre>
 <div class="post-image margin-top-40 margin-bottom-40"> 
  <img src="https://i.imgur.com/5h5izfu.png" alt=""> 
 </div>
 <p>The task got executed instantly after I pressed the IBAction, and took about 5 seconds to complete. However, the entire screen was frozen, as we blocked the thread.</p>
 <h2>Heavy task on an UserInitiated QoS thread</h2>
 <pre class="language-swift"><code class="language-swift">@IBAction func actionOne(_ sender: Any) {
    DispatchQueue.global(qos: .userInitiated).async { [unowned self] in
        self.timeIntensiveTask()
    }
}
</code></pre>
 <div class="post-image margin-top-40 margin-bottom-40"> 
  <img src="https://i.imgur.com/13G62Yw.png" alt=""> 
 </div>
 <p>A new thread spawned, and the task got executed almost instantly after I pressed the IBAction, also taking about 5 seconds to complete. No screen freeze this time! This thread is completely independent.</p>
 <h2>Heavy task on a Background QoS thread</h2>
 <pre class="language-swift"><code class="language-swift">@IBAction func actionOne(_ sender: Any) {
    DispatchQueue.global(qos: .background).async { [unowned self] in
        self.timeIntensiveTask()
    }
}
</code></pre>
 <div class="post-image margin-top-40 margin-bottom-40"> 
  <img src="https://i.imgur.com/jPgtDEt.png" alt=""> 
 </div>
 <p>Just like UserInitiated, a thread got spawned, but in this case, not only it took some time for the task to start - and it took almost 10 seconds for it to end! This lower priority thread had delayed and reduced access to system resources. However, this is good: If you're sending a task to a background QoS queue, it means you don't want to ruin your user's CPU by focusing on it. </p>
 <h2>Visualizing Serial Queues versus Concurrent Queues</h2>
 <pre class="language-swift"><code class="language-swift">@IBAction func actionOne(_ sender: Any) {
    DispatchQueue.main.async { [unowned self] in
        self.timeIntensiveTask()
    }
    DispatchQueue.main.async { [unowned self] in
        self.timeIntensiveTask()
    }
    DispatchQueue.main.async { [unowned self] in
        self.timeIntensiveTask()
    }
}
</code></pre>
 <div class="post-image margin-top-40 margin-bottom-40"> 
  <img src="https://i.imgur.com/MeS2Hbv.png" alt=""> 
 </div>
 <pre class="language-swift"><code class="language-swift">@IBAction func actionOne(_ sender: Any) {
    DispatchQueue.global(qos: .background).async { [unowned self] in
        self.timeIntensiveTask()
    }
    DispatchQueue.global(qos: .background).async { [unowned self] in
        self.timeIntensiveTask()
    }
    DispatchQueue.global(qos: .background).async { [unowned self] in
        self.timeIntensiveTask()
    }
}
</code></pre>
 <div class="post-image margin-top-40 margin-bottom-40"> 
  <img src="https://i.imgur.com/9menZsz.png" alt=""> 
 </div>
 <h2>DispatchQueue.sync vs DispatchQueue.async</h2>
 <p>If the concept of a multi-threaded process wasn't mind-boggling enough, we need to careful with the definition of <code>.async</code> and <code>.sync</code> operations.</p>
 <p>A common misconception is to think that <code>DispatchQueue.async</code> means executing something in background, and that's not true.</p>
 <p>What will be the output on <code>actionOne()</code>?</p>
 <pre class="language-swift"><code class="language-swift">@IBAction func actionOne(_ sender: Any) {
    DispatchQueue.main.async { [unowned self] in
        print("async started")
        self.timeIntensiveTask()
        print("async ended")
     }
     print("sync task started")
     timeIntensiveTask()
     print("sync task ended")
}

private func timeIntensiveTask() {
    var counter = 0
    for _ in 0..&lt;1000000000 {
        counter += 1
    }
}
</code></pre>
 <p>The answer will always be:</p>
 <pre class="language-swift"><code class="language-swift">sync task started
sync task ended
async task started
async task ended
</code></pre>
 <p>If you thought the two tasks would start together, just think about the context of this method: we are dispatching a task to the Main Thread, but <code>actionOne</code> is already on the Main Thread! There's no way a thread can run two sequences of instructions at the same time, that's why we have different threads.</p>
 <p>The <code>async</code> task will also only execute after the <code>sync</code> task (and never before) because <code>DispatchQueue.main</code> tasks will only start executing at the end of the Main Thread's <code>RunLoop</code> - which is blocked by our sync task. If <code>actionOne</code> happened to be in a different thread or the <code>async</code> task happened to be in a different <code>DispatchQueue</code>, the tasks would start together in an order dependant to how fast the <code>async</code> task would be dispatched.</p>
 <p>What <code>DispatchQueue.async</code> means is: <b>Make sure this task is eventually executed on thread X (main, or any other global background thread depending on what queue you are using), but I don't care about the details. I'll keep doing my stuff.</b> </p>
 <p>On the contrary, <code>DispatchQueue.sync</code> means is: <b>Make sure this task is eventually executed on thread X. Please warn me when you do so, because I will also block myself (the calling thread) until this task finishes running.</b> </p>
 <p>Given that, what do you think will be the output of the following <code>actionOne()</code>?</p>
 <pre class="language-swift"><code class="language-swift">@IBAction func actionOne(_ sender: Any) {
    DispatchQueue.main.sync { [unowned self] in
        print("a")
    }
    print("b")
}
</code></pre>
 <p>A <code>sync</code> task is forwarded to the queue, and the main thread will freeze until <code>"a"</code> gets printed. The task gets sent to the Main Thread, which is frozen because it's waiting for the task to run. But the task can't run, because the thread is frozen waiting for the task to run, and on and on and on until your app decides to crash. You can't call <code>sync</code> dispatches from the thread itself, it has to come from somewhere else. Nothing will get printed here. As you most likely know, this is called a <b>deadlock</b>.</p>
 <h2>What else?</h2>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>Hopefully, this is to answer the questions at the beginning of the article. Concurrency is a very wide issue, and in iOS, <code>DispatchQueues</code> are just one way to approach concurrency problems. There's still much more in the shape of <code>Atomicity</code>, <code>OperationQueues</code>, <code>Locks</code>, <code>Semaphores</code>. However, <code>DispatchQueues</code> are the most used concurrency tools in iOS, and when understood, one of the keys to writing efficient multi-threaded code.</p>
 <p>Follow me on my Twitter - <a href="https://twitter.com/rockbruno_">@rockbruno_</a>, and let me know of any suggestions and corrections you want to share.</p>
 <h2>References and Good reads</h2>
 <a href="http://www.cs.albany.edu/~sdc/CSI500/Fal13/OSTEP/">Operating Systems: Three Easy Pieces</a>
 <br>
 <a href="https://developer.apple.com/library/content/documentation/Performance/Conceptual/EnergyGuide-iOS/PrioritizeWorkWithQoS.html">Apple Docs: QoS</a>
 <br>
 <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/CreatingThreads/CreatingThreads.html#//apple_ref/doc/uid/10000057i-CH15-SW2">Apple Docs: Thread Management</a>
 <br>
 <a href="https://medium.com/flawless-app-stories/basics-of-parallel-programming-with-swift-93fee8425287">Basic of Parallel Programming with Swift</a>
</div>]]></description>
</item>
<item>
    <title>Lazy Sequences in Swift And How They Work</title>
    <link>https://swiftrocks.com/lazy-sequences-in-swift-and-how-they-work</link>
    <guid>https://swiftrocks.com/lazy-sequences-in-swift-and-how-they-work</guid>
    <pubDate>Fri, 26 Oct 2018 10:42:07 GMT-3</pubDate>
<description><![CDATA[
 
  
  <!--WRITEIT_POST_NAME=Lazy Sequences in Swift And How They Work--> 
  <!--WRITEIT_POST_HTML_NAME=lazy-sequences-in-swift-and-how-they-work--> 
  <!--WRITEIT_POST_SITEMAP_DATE_LAST_MOD=2020-04-12T14:00:00+02:00--> 
  <!--WRITEIT_POST_SITEMAP_DATE=2018-10-26T13:42:07+00:00--> 
  <!--Add here the additional properties that you want each page to possess.--> 
  <!--These properties can be used to change content in the template page or in the page itself as shown here.--> 
  <!--Properties must start with 'WRITE_IT_POST'.--> 
  <!--Writeit provides and injects WRITEIT_POST_NAME and WRITEIT_POST_HTML_NAME by default.--> 
  <!--WRITEIT_POST_SHORT_DESCRIPTION=Usage of high-order functions like map and filter are very common in Swift projects, as they are simple algorithms that allow you to convert extensive ideas into simple one-liners. Unfortunately, they don't solve every issue - at least not in their default implementations.--> 
  <title>Lazy Sequences in Swift And How They Work</title>  
 

<div class="blog-post"> 
 <div class="post-title-index">  
  <h1>Lazy Sequences in Swift And How They Work</h1>
 </div> 
 <div class="post-info"> 
  <div class="category category-compiler">
   Compiler
  </div> 
  <div class="category category-swift">
   Swift
  </div> 
  <div class="post-info-text">
   Published on 27 Aug 2018 
  </div> 
 </div>  
 <p>Usage of high-order functions like <code>map</code> and <code>filter</code> are very common in Swift projects, as they are simple algorithms that allow you to convert extensive ideas into simple one-liners. Unfortunately, they don't solve every issue - at least not in their default implementations. High-order functions are <i>eager</i>: they use the closure immediately and return a new array, regardless if you need an early return or only going to use specific elements. When performance is important, you might be cornered into writing specialized helper methods to avoid the <i>eager</i> nature of high-orders:</p>
 <pre>
<code>let addresses = getFirstThreeAddresses(withIdentifier: "HOME")</code>
<code>func getFirstThreeAddresses(withIdentifier identifier: String) -&gt; [Address] {</code>
<code>    //Not using .filter{}.prefix(3) because we need an early return</code>
<code>    var addresses = [Address]()</code>
<code>    for address in allAddresses where address.identifier == identifier {</code>
<code>        addresses.append(address)</code>
<code>        if addresses.count == 3 {</code>
<code>            break</code>
<code>        }</code>
<code>    }</code>
<code>    return addresses</code>
<code>}</code>
</pre>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>Fortunately, Swift has a way to use high-order functions while still keeping the improved performance of the helper methods - Lazy versions of the Swift Standard Library <code>Sequences</code> and <code>Collections</code> can be accessed through the <code>lazy</code> property.</p>
 <p>These lazy variations work just like their regular counterparts, but with one twist: they have custom implementations of methods like <code>map</code> and <code>filter</code> in order to make them work <b>lazily</b> - meaning that the actual computations will only happen <b>where and when you need them.</b></p>
 <pre>
<code>let allNumbers = Array(1...1000)</code>
<code>let normalMap = allNumbers.map { $0 * 2 } // The entire Sequence will be mapped, regardless of what you need to do.</code>
<code>let lazyMap = allNumbers.lazy.map { $0 * 2 } // Nothing happens here.</code>
<code>print(lazyMap[0]) // Prints 2, but everything else is still untouched!</code>
</pre>
 <p>While somewhat scary at first, they allow you to reduce most <code>for</code> loops with early returns into one-liners. For example, here's how it compares to other methods when used to find the first element that fulfills a predicate:</p>
 <pre>
<code>// allAddresses in an [Address] with 10000 elements, and a "HOME" address is placed at the beginning</code>
<code>let address = allAddresses.filter { $0.identifier == "HOME" }.first // ~0.15 seconds</code>
<code></code>
<code>// Versus</code>
<code></code>
<code>func firstAddress(withIdentifier identifier: String) -&gt; Address? {</code>
<code>    // Nowadays you can use the Standard Library's first(where:) method,</code>
<code>    // but lets pretend that doesn't exist.</code>
<code>    for address in allAddresses where address.identifier == identifier {</code>
<code>        return address</code>
<code>    }</code>
<code>    return nil</code>
<code>}</code>
<code></code>
<code>let address = firstAddress(withIdentifier: "HOME") // Instant</code>
<code></code>
<code>// Versus</code>
<code></code>
<code>let address = allAddresses.lazy.filter { $0.identifier == "HOME" }.first // Also instant with much less code!</code>
</pre>
 <p>Besides writing shorter code, they can also be very useful for delaying operations in general to make your code easier to read. Let's say you have a shopping app which displays offer incentives from a local database if the user's taking too long to finish a purchase:</p>
 <pre>
<code>let offerViews = offersJson.compactMap { database.load(offer: $0) }.map(OfferView.init) // O(n)</code>
<code>var currentOffer = -1</code>
<code></code>
<code>func displayNextOffer() {</code>
<code>    guard currentOffer + 1 &lt; offerViews.count else {</code>
<code>        return</code>
<code>    }</code>
<code>    currentOffer += 1</code>
<code>    offerViews[currentOffer].display(atViewController: self)</code>
<code>}</code>
</pre>
 <p>While this solution works, it has a major flaw: I am eagerly mapping the entire offer json into <code>OfferViews</code>, even though there's no guarantee that the user will see any of these offers. This isn't really an issue if <code>offerJson</code> is a small array, but with large data sets, pulling all the offers from a database can quickly become a problem.</p>
 <p>You can map only the necessary <code>OfferViews</code> by moving the parsing logic to <code>displayNextOffer()</code>, but your code quality might become harder to understand since you now have to keep the raw offer data around:</p>
 <pre>
<code>let offersJson: [[String: Any]] = //</code>
<code>var currentOffer = -1</code>
<code></code>
<code>func displayNextOffer() {</code>
<code>    guard currentOffer + 1 &lt; offerViews.count else {</code>
<code>        return</code>
<code>    }</code>
<code>    currentOffer += 1</code>
<code>    guard let offer = database.load(offer: offersJson[currentOffer]) else {</code>
<code>        return</code>
<code>    }</code>
<code>    let offerView = OfferView(offer: offer)</code>
<code>    offerView.display(atViewController: self)</code>
<code>}</code>
</pre>
 <p>By using <code>lazy</code>, the current <code>offerView</code> will only be mapped when the array position is accessed in <code>displayNextOffer()</code>, keeping the reading quality of the first implementation with the performance of the second one!</p>
 <pre>
<code>let offerViews = offersJson.lazy.compactMap { database.load(offer: $0) }.map(OfferView.init) // Nothing happens here!</code>
<code>var currentOffer = -1</code>
<code></code>
<code>func displayNextOffer() {</code>
<code>    guard currentOffer + 1 &lt; offerViews.count else {</code>
<code>        return</code>
<code>    }</code>
<code>    currentOffer += 1</code>
<code>    offerViews[currentOffer].display(atViewController: self) // Mapping only happens here, for the desired element only.</code>
<code>}</code>
</pre>
 <p>Note, however, that Lazy Sequences have no caching. This means that if <code>offerViews[0]</code> is accessed twice, <b>the entire mapping process will also happen twice.</b> If you need to access elements more than once, move them to a regular array.</p>
 <h2>Why this works?</h2>
 <p>While they look like magic when used, the internal implementation of Lazy Sequences aren't as complicated as it looks.</p>
 <p>If we print the type of our second example, we can see that even though our lazily mapped <code>Collection</code> works like a regular <code>Collection</code>, we are dealing with different types:</p>
 <pre>
<code>let lazyMap = Array(1...1000).lazy.map { $0 * 2 }</code>
<code>print(lazyMap) // LazyMapCollection&lt;Array&lt;Int&gt;, Int&gt;</code>
<code>let lazyMap = Array(1...1000).lazy.filter { $0 % 2 == 0 }.map { $0 * 2 }</code>
<code>print(lazyMap) // LazyMapCollection&lt;LazyFilterCollection&lt;Array&lt;Int&gt;&gt;, Int&gt;</code>
<code>//In this case, the first generic argument is the inner Collection of the lazy operation, while the second one is the transformation function of the map operation.</code>
</pre>
 <p>Looking at Swift's source code, we can see that the non-eagerness comes from the fact that these methods don't actually do anything besides return a new type:</p>
 <p>(I'll be using <code>LazySequence</code> code examples instead of <code>LazyCollections</code> ones because they are much simpler in nature. If you don't know how regular <code>Sequences</code> work, <a href="https://developer.apple.com/documentation/swift/sequence">take a look at this Apple page.</a>)</p>
 <pre>
<code>extension LazySequenceProtocol {</code>
<code>    /// Returns a `LazyMapSequence` over this `Sequence`.  The elements of</code>
<code>    /// the result are computed lazily, each time they are read, by</code>
<code>    /// calling `transform` function on a base element.</code>
<code>    @inlinable</code>
<code>    public func map&lt;U&gt;(_ transform: @escaping (Elements.Element) -&gt; U) -&gt; LazyMapSequence&lt;Self.Elements, U&gt; {</code>
<code>        return LazyMapSequence(_base: self.elements, transform: transform)</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>The magic comes from the internal implementation of these specialized types. If we take a look at <code>LazyMapSequence</code> and <code>LazyFilterSequence</code>, for example, we can see that they are nothing more than regular <code>Sequences</code> that stores an operation and applies their counterpart eager functions only when iterated:</p>
 <pre>
<code>// _base is the original Sequence</code>
<code>extension LazyMapSequence.Iterator: IteratorProtocol, Sequence {</code>
<code>    @inlinable</code>
<code>    public mutating func next() -&gt; Element? {</code>
<code>        return _base.next().map(_transform)</code>
<code>    }</code>
<code>}</code>
</pre>
 <pre>
<code>extension LazyFilterSequence.Iterator: IteratorProtocol, Sequence {</code>
<code>    @inlinable</code>
<code>    public mutating func next() -&gt; Element? {</code>
<code>        while let n = _base.next() {</code>
<code>            if _predicate(n) {</code>
<code>                return n</code>
<code>            }</code>
<code>        }</code>
<code>        return nil</code>
<code>    }</code>
<code>}</code>
</pre>
 <h2>LazyCollection Performance Traps</h2>
 <p>If would be nice if the article ended here, but it's important to know that Lazy Sequences have flaws - specifically when the underlying type is a <code>Collection</code>.</p>
 <p>In the opening example, our method gets the first three addresses that fulfill a certain predicate. By chaining lazy operations together, this can also be reduced to an one-liner:</p>
 <pre>
<code>let homeAddresses = allAddresses.lazy.filter { $0.identifier == "HOME" }.prefix(3)</code>
</pre>
 <p>However, look how this specific example performs when compared to the eager counterpart:</p>
 <pre>
<code>allAddresses.filter { $0.identifier == "HOME" }.prefix(3) // ~0.11 secs</code>
<code>Array(allAddresses.lazy.filter { $0.identifier == "HOME" }.prefix(3)) // ~0.22 secs</code>
</pre>
 <p>Even though the <code>lazy</code> version stops as soon as the three addresses are found, it performs twice as bad as the eager one!</p>
 <p>The unfortunate reason comes from the subtle differences between <code>Sequences</code> and <code>Collections</code>. While prefixing a <code>Sequence</code> is as simple as moving the desired elements to a separate <code>Array</code>, slicing operations on <code>Collections</code> require knowing the <code>end</code> index of the desired slice:</p>
 <pre>
<code>public func prefix(_ maxLength: Int) -&gt; SubSequence {</code>
<code>    _precondition(maxLength &gt;= 0, "Can't take a prefix of negative length from a collection")</code>
<code>    let end = index(startIndex, offsetBy: maxLength, limitedBy: endIndex) ?? endIndex</code>
<code>    return self[startIndex..&lt;end]</code>
<code>}</code>
<code></code>
<code>@inlinable</code>
<code>public subscript(bounds: Range&lt;Index&gt;) -&gt; Slice&lt;Self&gt; {</code>
<code>    _failEarlyRangeCheck(bounds, bounds: startIndex..&lt;endIndex)</code>
<code>    return Slice(base: self, bounds: bounds)</code>
<code>}</code>
</pre>
 <p>The problem is that in <code>Collection</code> lingo, an <code>endIndex</code> isn't the index of the last element, but the index <b>after</b> the last element (<code>index(startIndex, offsetBy: maxLength)</code>). For our lazy <code>filter</code>, this means that in order to slice the first three home addresses, we must find <b>four</b> of them - which may not even exist.</p>
 <p>The documentation of <a href="https://github.com/apple/swift/blob/master/stdlib/public/core/PrefixWhile.swift#L106">certain lazy types</a> states this issue:</p>
 <pre>
<code>/// - Note: The performance of accessing `endIndex`, `last`, any methods that</code>
<code>///   depend on `endIndex`, or moving an index depends on how many elements</code>
<code>///   satisfy the predicate at the start of the collection, and may not offer</code>
<code>///   the usual performance given by the `Collection` protocol. Be aware,</code>
<code>///   therefore, that general operations on `${Self}` instances may not have</code>
<code>///   the documented complexity.</code>
<code>public struct LazyPrefixWhileCollection&lt;Base: Collection&gt; {</code>
</pre>
 <p>To make it worse, since a <code>Slice</code> is a mere window to the original <code>Collection</code>, the casting to <code>Array</code> will invoke functions that call the lazy filtered <code>Collection</code>'s <code>count</code> properties - but since the <code>lazy.filter(_:)</code> operation doesn't conform to <code>RandomAccessCollection</code>, <code>count</code> can only be found by iterating the entire <code>Collection</code> - again.</p>
 <p>Due to the Lazy Sequence's lack of caching, this results in the entire filtering/slicing process happening <b>again</b>. Thus, if the fourth element doesn't exist or is too far from the third one, the <code>lazy</code> version will perform twice as worse as the original one.</p>
 <p>The good news is that this can be avoided - if you're not sure your lazy operation will run in reasonable time, you can guarantee it by treating the result as a <code>Sequence</code>. This has the downside of losing the reverse-iteration capabilities of a <code>BidirectionalCollection</code>, but guarantees that forward operations will be fast again.</p>
 <pre>
<code>let sequence: AnySequence = allAddresses.lazy.filter { $0.identifier == "HOME" }.prefix(3)</code>
<code>let result = Array(sequence) // ~0.004 secs!</code>
</pre>
 <h2>Conclusion</h2>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>Usage of <code>lazy</code> objects can allow you to write high-performance complicated things very quickly - at the cost of requiring some understanding of Swift internals to prevent major issues. Like all features, they have great advantages with equal downsides, and in this case knowledge of the main differences between <code>Sequences</code> and <code>Collections</code> is required to extract the best of them. Once mastered, mapping specific elements becomes very simple and intuitive.</p>
 <p>Follow me on my Twitter - <a href="https://twitter.com/rockbruno_">@rockbruno_</a>, and let me know of any suggestions and corrections you want to share.</p>
 <h2>References and Good reads</h2>
 <a href="https://github.com/apple/swift/blob/master/stdlib/public/core/Filter.swift">Filter.swift</a>
 <br>
 <a href="https://bugs.swift.org/browse/SR-4164">SR-4164</a>
 <br>
 <a href="https://developer.apple.com/documentation/swift/lazyprefixwhilecollection">LazyPrefixWhileCollection</a>
 <br>
 <a href="https://developer.apple.com/documentation/swift/lazysequenceprotocol">LazySequenceProtocol</a>
 <br>
 <a href="https://developer.apple.com/documentation/swift/sequence">Sequence</a>
 <br>
</div>]]></description>
</item>
<item>
    <title>Writing Cleaner View Code in Swift By Overriding loadView()</title>
    <link>https://swiftrocks.com/writing-cleaner-view-code-by-overriding-loadview</link>
    <guid>https://swiftrocks.com/writing-cleaner-view-code-by-overriding-loadview</guid>
    <pubDate>Fri, 26 Oct 2018 10:42:07 GMT-3</pubDate>
<description><![CDATA[
 
  
  <!--WRITEIT_POST_NAME=Writing Cleaner View Code in Swift By Overriding loadView()--> 
  <!--WRITEIT_POST_HTML_NAME=writing-cleaner-view-code-by-overriding-loadview--> 
  <!--WRITEIT_POST_SITEMAP_DATE_LAST_MOD=2020-04-12T14:00:00+02:00--> 
  <!--WRITEIT_POST_SITEMAP_DATE=2018-10-26T13:42:07+00:00--> 
  <!--Add here the additional properties that you want each page to possess.--> 
  <!--These properties can be used to change content in the template page or in the page itself as shown here.--> 
  <!--Properties must start with 'WRITE_IT_POST'.--> 
  <!--Writeit provides and injects WRITEIT_POST_NAME and WRITEIT_POST_HTML_NAME by default.--> 
  <!--WRITEIT_POST_SHORT_DESCRIPTION=The choice between using Storyboards and writing views programmatically is very subjetive. Having dealt with both in the past, I personally vouch for writing projects entirely through view code as it allows multiple people to work in the same class without nasty conflicts, and easier code reviews.--> 
  <title>Writing Cleaner View Code in Swift By Overriding loadView()</title>  
 

<div class="blog-post"> 
 <div class="post-title-index">  
  <h1>Writing Cleaner View Code in Swift By Overriding loadView()</h1>
 </div> 
 <div class="post-info"> 
  <div class="category category-theory">
   Theory
  </div> 
  <div class="category category-swift">
   Swift
  </div> 
  <div class="post-info-text">
   Published on 23 Jul 2018 
  </div> 
 </div>   
 <p>The choice between using Storyboards and writing views programmatically is very subjetive. Having dealt with both in the past, I personally vouch for writing projects entirely through view code as it allows multiple people to work in the same class without nasty conflicts, and easier code reviews.</p>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>When starting with the practice of writing views programatically, a common problem people face is <i>where</i> to put the code in the first place. If you follow the regular storyboard approach of putting everything view related in your view controller, it's very easy to end up with a giant god class:</p>
 <pre class="language-swift"><code class="language-swift">final class MyViewController: UIViewController {
    private let myButton: UIButton = {
    	//
    }()
  
  	private let myView: UIView = {
    	//
    }()
  
  	//Other 10 views or so
  
  	override func viewDidLoad() {
        super.viewDidLoad()
      	setupViews()
    }
  
  	private func setupViews() {
    	setupMyButton()
      	setupMyView()
      	//setup for all the other views
    }
  
  	private func setupMyButton() {
  	    view.addSubview(myButton)
    	//10 lines of constraints
    }
  
    private func setupMyView() {
  	    view.addSubview(myView)
    	//10 lines of constraints
    }
  
  	//All other setups
  
  	//All ViewModel logic
  
  	//All the button clicking logic and stuff...
}
</code></pre>
 <p>You can make this better by moving the views to a different file and adding a reference back to the View Controller, but you'll still have to fill your View Controller with things that are not supposed to be in it, such as constraint code and other forms of view setup - not to mention you now have two different view properties (<code>myView</code> and the native <code>view</code>) in it for no good reason:</p>
 <pre class="language-swift"><code class="language-swift">final class MyViewController: UIViewController {
    
	let myView = MyView()
  
  	override func viewDidLoad() {
        super.viewDidLoad()
      	setupMyView()
    }
  
  	private func setupMyView() {
  	    view.addSubview(myView)
    	//10 lines of constraints or so
    	myView.delegate = self
    	//We now have both 'view' and 'myView'...
    }
}
</code></pre>
 <p>Giant View Controllers and View Controllers that know <i>too much</i> are very difficult to maintain and scale. In architectures like MVVM, the View Controller should act mostly as a router between the View itself and the View Model - it's not its job to know how to setup the views or constrain them, it should merely <b>route</b> information back and forth.</p>
 <p>In a View Code project where most of the code are the views themselves, it's very important to have a clear separation of responsibilities between the aspects of your architecture in order to have a maintainable project. You want your actual view code to be completely separate from your View Controller - and fortunately, there is a very simple way to override the original <code>view</code> property of an <code>UIViewController</code>, allowing you to maintain separate files for your views while still making sure your view controller doesn't have to do any kind of view setup.</p>
 <h2>loadView()</h2>
 <p><code>loadView()</code> is an <code>UIViewController</code> method that you don't see very often, but it is very important to a view controller's lifecycle since it is responsible for making the <code>view</code> property exist in the first place. When using Storyboards, this is the method that will load your nib and attach it to the <code>view</code>, but when instantiating view controllers manually, all this method does is create an empty <code>UIView</code>. You can override it to change this behaviour and add any kind of view to the view controller's <code>view</code> property.</p>
 <pre class="language-swift"><code class="language-swift">final class MyViewController: UIViewController {
	override func loadView() {
	    let myView = MyView()
	    myView.delegate = self
        view = myView
    }

    override func viewDidLoad() {
        super.viewDidLoad()
		print(view) // a MyView instance
	}
}
</code></pre>
 <p>Notice that <code>view</code> will automatically constrain itself to the edges of the View Controller, so no constraints are needed for the outer <code>myView</code>!</p>
 <p>Now, <code>view</code> is a reference to my custom view (<code>MyView</code> in this case). You can build the entire functionality of the view inside its own separate file without the View Controller having to know anything about it. Nice!</p>
 <p>To access the contents of <code>MyView</code>, you can cast <code>view</code> to your custom type:</p>
 <pre class="language-swift"><code class="language-swift">var myView: MyView {
    return view as! MyView
}
</code></pre>
 <p>This looks a bit weird, but it's because <code>view</code> will still be defined as an <code>UIView</code> regardless of the type you change it for.</p>
 <p>To avoid duplicating this code across my View Controllers, I like defining this behaviour inside a <code>CustomView</code> protocol with an associated type requirement:</p>
 <pre class="language-swift"><code class="language-swift">/// The HasCustomView protocol defines a customView property for UIViewControllers to be used in exchange of the regular view property.
/// In order for this to work, you have to provide a custom view to your UIViewController at the loadView() method.
public protocol HasCustomView {
    associatedtype CustomView: UIView
}

extension HasCustomView where Self: UIViewController {
    /// The UIViewController's custom view.
    public var customView: CustomView {
        guard let customView = view as? CustomView else {
            fatalError("Expected view to be of type \(CustomView.self) but got \(type(of: view)) instead")
        }
        return customView
    }
}
</code></pre>
 <p>Which results in:</p>
 <pre class="language-swift"><code class="language-swift">final class MyViewController: UIViewController, HasCustomView {
	typealias CustomView = MyView

	override func loadView() {
	    let customView = CustomView()
	    customView.delegate = self
        view = customView
    }

    override func viewDidLoad() {
    	super.viewDidLoad()
    	customView.render() //some MyView method
	}
}
</code></pre>
 <p>If defining this <code>CustomView</code> typealias every time is something that would bother you, you can go further and define this behaviour inside a generic class: </p>
 <pre class="language-swift"><code class="language-swift">class CustomViewController&lt;CustomView: UIView&gt;: UIViewController {
    var customView: CustomView {
        return view as! CustomView //Will never fail as we're overriding 'view'
    }

    override func loadView() {
        view = CustomView()
    }
}

final class MyViewController: CustomViewController&lt;MyView&gt; {
	override func loadView() {
		super.loadView()
	    customView.delegate = self
    }
}
</code></pre>
 <p>I personally don't like the generic approach because the compiler doesn't allow generic classes to have extensions with <code>@objc</code> methods, which forbids you from having protocols like <code>UITableViewDataSource</code> in extensions. However, it allows you to skip overriding <code>loadView()</code> unless something special needs to be done (like setting delegates), which really helps keep your View Controllers clean.</p>
 <h2>Conclusion</h2>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>Overriding <code>loadView()</code> is a great way to make a View Code project easier to read and maintain, and I've been using <code>HasCustomView</code> specifically in my last few projects with great results. View coding is something that might not be your thing, but it brings many advantages to the table. Try it out, and see what works better for you.</p>
 <p>Let me know if you have other ways of defining views in a project without storyboards, along with any other questions, comments or feedback you might have.</p>
 <h2>References and Good reads</h2>
 <a href="https://developer.apple.com/documentation/uikit/uiviewcontroller/1621454-loadview">Apple Docs: loadView()</a>
 <br>
</div>]]></description>
</item>
<item>
    <title>Competitive Programming With Swift</title>
    <link>https://swiftrocks.com/competitive-programming-with-swift</link>
    <guid>https://swiftrocks.com/competitive-programming-with-swift</guid>
    <pubDate>Fri, 26 Oct 2018 10:42:07 GMT-3</pubDate>
<description><![CDATA[
 
  
  <!--WRITEIT_POST_NAME=Competitive Programming With Swift--> 
  <!--WRITEIT_POST_HTML_NAME=competitive-programming-with-swift--> 
  <!--WRITEIT_POST_SITEMAP_DATE_LAST_MOD=2020-04-12T14:00:00+02:00--> 
  <!--WRITEIT_POST_SITEMAP_DATE=2018-10-26T13:42:07+00:00--> 
  <!--Add here the additional properties that you want each page to possess.--> 
  <!--These properties can be used to change content in the template page or in the page itself as shown here.--> 
  <!--Properties must start with 'WRITE_IT_POST'.--> 
  <!--Writeit provides and injects WRITEIT_POST_NAME and WRITEIT_POST_HTML_NAME by default.--> 
  <!--WRITEIT_POST_SHORT_DESCRIPTION=Competitive programming is a great way to master a specific programming language. Even if you're not interested in competing in world events like the Facebook Hacker Cup, tackling difficult algorithm problems using nothing but the language's bread and butter will expose you to aspects/shortcuts of the language you would otherwise never see, such as how efficient certain methods/operations are and how to code better alternatives.--> 
  <title>Competitive Programming With Swift</title>  
 

<div class="blog-post"> 
 <div class="post-title-index">  
  <h1>Competitive Programming With Swift</h1>
 </div> 
 <div class="post-info"> 
  <div class="category category-theory">
   Compiler
  </div> 
  <div class="post-info-text">
   Published on 21 May 2018 
  </div> 
 </div>  
 <p>Competitive programming is a great way to master a specific programming language. Even if you're not interested in competing in world events like the <b>Facebook Hacker Cup</b>, tackling difficult algorithm problems using nothing but the language's bread and butter will expose you to aspects/shortcuts of the language you would otherwise never see, such as how efficient certain methods/operations are and how to code better alternatives. This is a cool hobby to have, and as a bonus you'll even be indirectly preparing yourself to the feared Big 4 interviews where you have to solve algorithm problems in a whiteboard!</p>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>Even though in a real competition coding in Swift would be a big disavantage (as it's slightly slow compared to other languages and has few native data structures), lots of popular online platforms like <a href="https://leetcode.com/">LeetCode</a>, <a href="https://www.hackerrank.com/">HackerRank</a> and <a href="https://codefights.com/">Codefights</a> support Swift and they are a great way to make yourself a better iOS developer, specially since competitive problems will only accept very fast algorithms as possible solutions. If you've never did this before, I highly recommend giving it a shot.</p>
 <p>In this article, I'll give a brief tutorial on how to use Swift to read input data and some tips for tackling competitive problems in Swift.</p>
 <h2>Reading Standard Input with Swift</h2>
 <p>In competitive programming, the problem's input is usually fed into a command line application which makes some sense of it and prints the desired result.</p>
 <p>Platforms like <b>LeetCode</b> and <b>CodeFights</b> will automatically process input data for you and expose an empty Swift method that should return the problem's solution, but other platforms like <b>HackerRank</b> will sometimes have you manually read, parse the standard input and then print the result. Thankfully, that's not as complex as it sounds.</p>
 <p>To simulate a competitive programming environment, create a <b>Command Line Tool</b> project in Xcode:</p>
 <div class="post-image margin-top-40 margin-bottom-40"> 
  <img src="https://i.imgur.com/MyAl2I0.png" alt=""> 
 </div>
 <p>Be aware that a Command Line Tool is not a Cocoa app, so you'll have no access to things like <code>UIKit</code>! The core frameworks like <code>Foundation</code> are all you have here.</p>
 <p>In <code>main.swift</code>, type and run the following code:</p>
 <pre class="language-swift"><code class="language-swift">let line = readLine()
print("Got something! \(line)")
</code></pre>
 <p>At this point, the program will be frozen. <code>readLine()</code> is a Standard Library method that synchronously reads the standard input and returns a <code>String?</code> once a full line is retrieved or <code>nil</code> if EOF is reached.</p>
 <p>If you type something in Xcode's console, the program's execution will continue and print what you wrote:</p>
 <div class="post-image margin-top-40 margin-bottom-40"> 
  <img src="https://i.imgur.com/U5IwGnn.png" alt=""> 
 </div>
 <p>However, a competitive programming problem will likely have several hundred lines of input. You can use a <code>while</code> loop to make your code run until the input ends:</p>
 <pre class="language-swift"><code class="language-swift">while let line = readLine() {
    print("Got something! \(line)")
}
</code></pre>
 <div class="post-image margin-top-40 margin-bottom-40"> 
  <img src="https://i.imgur.com/KLUwiBK.png" alt=""> 
 </div>
 <p>That is all you need to know to get started. From here forward, your skill with pure Swift is the only variable.</p>
 <p>Here's an example problem if you've never done this before:</p>
 <h2>Example Problem</h2>
 <p>Given an array of integers, find the sum of its elements.</p>
 <h3>Input Format</h3>
 <p>The first line contains an integer, denoting the size of the array.</p>
 <p>The second line contains <code>n</code> space-separated integers representing the array's elements.</p>
 <h3>Output Format</h3>
 <p>Print the sum of the array's elements as a single integer.</p>
 <h3>Sample Input</h3>
 <pre class="language-swift"><code class="language-swift">6
1 2 3 4 10 11
</code></pre>
 <h3>Sample Output</h3>
 <p><code>31</code></p>
 <h2>Solution</h2>
 <p>Every problem has multiple possible solutions. For this one, we can harness the power of <code>reduce</code>:</p>
 <pre class="language-swift"><code class="language-swift">import Foundation

_ = readLine() //Read and drop the array size line.
//Knowing the size of the array beforehand is needed for some languages
//But as readLine() returns the whole line, Swift doesn't need it!

let array = readLine()!.components(separatedBy: " ").map { Int($0)! }
let result = array.reduce(0, +)
print(result)
</code></pre>
 <h2>Swift tips for Competitive Programming</h2>
 <p>The beauty of competitive programming is that merely solving the problem is not enough - your program must solve it as fast as possible.</p>
 <p>There's a lot to talk about <a href="https://pt.khanacademy.org/computing/computer-science/algorithms/asymptotic-notation/a/big-o-notation">runtime complexity</a>, but this section is supposed to cover Swift tips that are useful when things need to be quick.</p>
 <p><b>If you have a tip that is not here, feel free to contact me and I'll add it and credit you!</b></p>
 <h3>Use Overflow Operators</h3>
 <p>Swift naturally protects you from numbers overflowing at the cost of performance. This can cost you some valuable nano-seconds, and some problems might even <b>want</b> you to overflow numbers. Luckily, Swift has special arithmetic operators that ignore overflow checks, making them faster than the regular operators:</p>
 <pre class="language-swift"><code class="language-swift">1 &amp;+ 1
1 &amp;- 1
1 &amp;* 1
1 &amp;&gt;&gt; 1
</code></pre>
 <h3>Printing is slow</h3>
 <p>The <code>print(_:)</code> method is very slow, and it can be particularly painful when printing things like <code>Arrays</code>. You can gain some performance if you print everything at once.</p>
 <pre class="language-swift"><code class="language-swift">let array = [String](repeating: "A", count: 1000)

for a in array {
    print(separated, terminator: " ") // slow
}

/////

let separated = array.joined(separator: " ")
print(separated) // a lot quicker, even though we're processing the array beforehand
</code></pre>
 <h3>Allocate Array capacities in advance</h3>
 <p>Swift's <code>Arrays</code> have dynamic sizes, meaning that the language automatically allocates more memory space for it as it increases in size. Even if this is quite fast, you can make it even faster if you know the array size in advance by using the <code>Array.reserveCapacity(_:)</code> method. This is useful if you have a problem where the solution is an <code>Array</code> with a specific size.</p>
 <pre class="language-swift"><code class="language-swift">let arraySize = Int(readLine()!)!
var array = [Int]()
array.reserveCapacity(arraySize) //Runtime is slightly slower without manually setting the array's capacity.
for i in 0..&lt;arraySize {
    array.append(solve(for: i))
}
</code></pre>
 <p>Alternatively, you can use the <code>repeating:count:</code> initializer when you need a pre-filled array:</p>
 <pre class="language-swift"><code class="language-swift">let fiveZs = Array(repeating: "Z", count: 5)
print(fiveZs)
// Prints "["Z", "Z", "Z", "Z", "Z"]"
</code></pre>
 <h3>Abuse Implicitly Unwrapped Optionals</h3>
 <p>While the dreaded <code>!</code> should be avoided in real applications, safety is not a concern in competitive programming. Since inputs are guaranteed to always be the same, you can completely skip the overhead of unwrapping optionals.</p>
 <h3>Use <code>inout</code> - Dmitry Volevodz</h3>
 <p>Using <code>inout</code> arguments can be really useful when passing data around recursive functions, and I was able to confirm that <code>inout</code> arguments are even faster to create than regular ones when passing around value types with inner reference types.</p>
 <h3>Subtract Dates to measure performance - Rodrigo Carvalho</h3>
 <p>The following snippet will measure how long it takes to run something:</p>
 <pre class="language-swift"><code class="language-swift">func measure(function: () -&gt; Void) {
    let start = Date()
    function()
    let end = Date()
    print("Elapsed time: \(end.timeIntervalSince(start))")
}

measure {
    timeIntensiveTask()
}
</code></pre>
 <p>This can be useful when you have multiple approaches and is not sure which one is faster. Be sure to run this with optimizations turned on to properly measure things, as most of the Swift compiler's tricks require it.</p>
 <h2>Swift Algorithm Club</h2>
 <p>Most competitive programming problems will rely on a specific data structure, and since Swift unfortunately has no native support for most of them, that means you'll have to code them yourself.</p>
 <p>Fortunately, the <a href="https://github.com/raywenderlich/swift-algorithm-club/">swift-algorithm-club</a> repo has Swift implementations of pretty much everything, making it a great place to learn how to code popular data structures in Swift.</p>
 <h2>What else?</h2>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>Regardless if you are studying for an interview, wanting to compete at world events or just trying to get better at iOS development, solving competitive programming problems is a very interesting way of increasing your Swift skills. I've personally benefited a lot from it, and would love to know what you think of it.</p>
 <p>Follow me on my Twitter - <a href="https://twitter.com/rockbruno_">@rockbruno_</a>, and let me know of any suggestions and corrections you want to share.</p>
 <h2>References and Good reads</h2>
 <a href="https://pt.khanacademy.org/computing/computer-science/algorithms/asymptotic-notation/a/big-o-notation">Big O Notation</a>
 <br>
 <a href="http://jordansmith.io/on-performant-arrays-in-swift/">Performant Arrays In Swift</a>
 <br>
 <a href="https://developer.apple.com/documentation/swift/1641199-readline">Apple Docs: readLine()</a>
</div>]]></description>
</item>
<item>
    <title>Running Other Apps' Siri Shortcuts Through Deep Links in Swift</title>
    <link>https://swiftrocks.com/running-other-apps-siri-shortcuts-through-deep-links-in-swift</link>
    <guid>https://swiftrocks.com/running-other-apps-siri-shortcuts-through-deep-links-in-swift</guid>
    <pubDate>Fri, 26 Oct 2018 10:42:07 GMT-3</pubDate>
<description><![CDATA[
 
  
  <!--WRITEIT_POST_NAME=Running Other Apps' Siri Shortcuts Through Deep Links in Swift--> 
  <!--WRITEIT_POST_HTML_NAME=running-other-apps-siri-shortcuts-through-deep-links-in-swift--> 
  <!--WRITEIT_POST_SITEMAP_DATE_LAST_MOD=2020-04-12T14:00:00+02:00--> 
  <!--WRITEIT_POST_SITEMAP_DATE=2018-10-26T13:42:07+00:00--> 
  <!--Add here the additional properties that you want each page to possess.--> 
  <!--These properties can be used to change content in the template page or in the page itself as shown here.--> 
  <!--Properties must start with 'WRITE_IT_POST'.--> 
  <!--Writeit provides and injects WRITEIT_POST_NAME and WRITEIT_POST_HTML_NAME by default.--> 
  <!--WRITEIT_POST_SHORT_DESCRIPTION=Siri Shortcuts are definitely my favorite iOS 12 feature. Ever since SiriKit first came out I was very disappointed that you couldn't use it for your own custom commands, but the new Shortcuts app solves this problem. Not only it allows you to create your custom commands, but it also provides a very intuitive UI to allow even non-devs to automate tons of kinds of workflows in their iPhones.--> 
  <title>Running Other Apps' Siri Shortcuts Through Deep Links in Swift</title>  
 

<div class="blog-post"> 
 <div class="post-title-index">  
  <h1>Running Other Apps' Siri Shortcuts Through Deeplinks in Swift</h1>
 </div> 
 <div class="post-info"> 
  <div class="category category-ios">
   iOS
  </div> 
  <div class="post-info-text">
   Published on 18 Oct 2018 
  </div> 
 </div>   
 <p>Siri Shortcuts are definitely my favorite iOS 12 feature. Ever since SiriKit first came out I was very disappointed that you couldn't use it for your own custom commands, but the new Shortcuts app solves this problem. Not only it allows you to create your custom commands, but it also provides a very intuitive UI to allow even non-devs to automate tons of kinds of workflows in their iPhones.</p>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>We've all seen how to create a workflow and make your app expose custom actions, but one thing that I haven't seen people mention is that the Shortcuts app exposes several deep links for opening and running shortcuts - meaning that you can make an app that runs other apps' Siri Shortcuts. <a href="https://twitter.com/rockbruno_/status/1052625467147083777">I used this to make an app run my "Take Picture" shortcut every time I tapped my AirPods.</a></p>
 <p>The URL Scheme for the Shortcuts app is <code>shortcuts://</code>, and you can test all of them by typing them into Safari.</p>
 <h2>Running a specific Shortcut</h2>
 <p><code>shortcuts://run-shortcut?name=[name]&amp;input=[input]</code></p>
 <p>For this deep link, <code>name</code> is the URL-encoded name of the shortcut you're trying to run, and <code>input</code> is the string input of the shortcut, if applicable. (You can type <code>clipboard</code> as the input to use the clipboard's contents!)</p>
 <p>To run my "Take Picture" shortcut, we just have to tell iOS to open this deep link:</p>
 <pre>
<code>let shortcut = URL(string: "shortcuts://run-shortcut?name=Take%20Picture")!</code>
<code>UIApplication.shared.open(shortcut, options: [:], completionHandler: nil)</code>
</pre>
 <p><img class="margin-top-40 margin-bottom-40" src="https://i.imgur.com/MS6hRNW.gif"></p>
 <br>
 <h2>Returning to your app after a Shortcut ends</h2>
 <p>Running the shortcut is great, but you might have noticed that the deep link has to open the Shortcuts app in order to work. How can we return to our app after the shortcut ends?</p>
 <p>Luckily for us, the Shortcuts app supports the <code>x-callback-url</code> standard, which is a standardized way for you to send data to other apps through URLs and get something back - in the shape of another URL. It looks like this:</p>
 <p><code>shortcuts://x-callback-url/run-shortcut?name=[name]&amp;x-success=[url]</code></p>
 <p>When the <code>[name]</code> shortcut succeeds, the Shortcuts app will automatically try to open the URL passed to the <code>x-success</code> argument. This can be any url, and we can use this to return to our app by registering a URL scheme of our own. Assuming that our app is listening to a <code>myapp://</code> URL scheme, we can make the Shortcuts app route back to our app by running:</p>
 <pre><code>let shortcut = URL(string: "shortcuts://x-callback-url/run-shortcut?name=Take%20Picture&amp;x-success=myapp://")!</code>
<code>UIApplication.shared.open(shortcut, options: [:], completionHandler: nil)</code>
</pre>
 <p><img class="margin-top-40 margin-bottom-40" src="https://i.imgur.com/WLbQrLD.gif"></p>
 <br>
 <p>Besides <code>x-success</code>, <code>x-cancel</code> and <code>x-error</code> can be used to treat interruptions and errors, respectively.</p>
 <h2>Other Deep Links</h2>
 <h3>Import a shortcut</h3>
 <p><code>shortcuts://import-shortcut?url=[url]&amp;name=[name]</code></p>
 <p>For this specific shortcut, <code>url</code> is the URL for a <code>.shortcut</code> file, and <code>name</code> is the name of the shortcut to be imported. You can also pass <code>&amp;silent=true</code> to this deep link to prevent the shortcuts app from opening the imported shortcut.</p>
 <p>This deep link also supports <code>x-callback-url</code>.</p>
 <h3>Open (not run) a specific shortcut</h3>
 <p><code>shortcuts://open-shortcut?name=[name]</code></p>
 <h3>Open the Shortcuts app</h3>
 <p><code>shortcuts://</code></p>
 <h3>Open the Create Shortcut screen</h3>
 <p><code>shortcuts://create-shortcut</code></p>
 <h3>Open the Shortcuts Gallery</h3>
 <p><code>shortcuts://gallery</code></p>
 <h3>Search the Shortcuts Gallery</h3>
 <p><code>shortcuts://gallery/search?query=[query]</code></p>
 <h2>Conclusion</h2>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>Because there's no way for you to retrieve a list of the user's shortcuts, there are probably not many uses for these deep links in regular apps - but they can be very useful for personal automation projects like my AirPods camera trick. What are you planning to do?</p>
 <p>Follow me on my Twitter - <a href="https://twitter.com/rockbruno_">@rockbruno_</a>, and let me know of any suggestions and corrections you want to share.</p>
 <h2>References and Good Reads</h2>
 <a href="http://x-callback-url.com/">x-callback-url</a>
 <br>
 <a href="https://support.apple.com/guide/shortcuts/about-url-schemes-apd621a1ad7a/ios">Apple Docs: Shortcuts URL Schemes</a>
 <br>
</div>]]></description>
</item>
<item>
    <title>Swift Associated Types With Default Values</title>
    <link>https://swiftrocks.com/swift-associated-types-with-default-values</link>
    <guid>https://swiftrocks.com/swift-associated-types-with-default-values</guid>
    <pubDate>Fri, 26 Oct 2018 10:42:07 GMT-3</pubDate>
<description><![CDATA[
 
  
  <!--WRITEIT_POST_NAME=Swift Associated Types With Default Values--> 
  <!--WRITEIT_POST_HTML_NAME=swift-associated-types-with-default-values--> 
  <!--WRITEIT_POST_SITEMAP_DATE_LAST_MOD=2020-04-12T14:00:00+02:00--> 
  <!--WRITEIT_POST_SITEMAP_DATE=2018-10-26T13:42:07+00:00--> 
  <!--Add here the additional properties that you want each page to possess.--> 
  <!--These properties can be used to change content in the template page or in the page itself as shown here.--> 
  <!--Properties must start with 'WRITE_IT_POST'.--> 
  <!--Writeit provides and injects WRITEIT_POST_NAME and WRITEIT_POST_HTML_NAME by default.--> 
  <!--WRITEIT_POST_SHORT_DESCRIPTION=I was browsing the Swift forums when I stumbled across a discussion regarding an undocumented feature of Swift (as of this post's date): the ability to give associated types a default value.--> 
  <title>Swift Associated Types With Default Values</title>  
 

<div class="blog-post"> 
 <div class="post-title-index">  
  <h1>Swift Associated Types With Default Values</h1>
 </div> 
 <div class="post-info"> 
  <div class="category category-swift">
   Swift
  </div> 
  <div class="post-info-text">
   Published on 16 Sep 2018 
  </div> 
 </div>  
 <p>I was browsing the Swift forums when I stumbled across a <a href="https://forums.swift.org/t/a-question-about-associatedtype-in-protocols/16168">discussion</a> regarding an undocumented feature of Swift (as of this post's date): the ability to give associated types a default value.</p>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>I've shown associated types in action before <a href="https://swiftrocks.com/writing-cleaner-view-code-by-overriding-loadview">in my article about loadView()</a> - they are a great tool to define generic behaviour inside protocols in the shape of a specific type. As the feature implies, setting a default value for an associated type will allow the children of the protocol to skip having to define a typealias for the type, unless they specifically want to use a different type.</p>
 <p>This is the regular way to define a associated type:</p>
 <pre>
<code>protocol Foo {</code>
<code>    associatedtype FooType</code>
<code>}</code>
<code></code>
<code>struct Bar: Foo {</code>
<code>    typealias Foo = BarType</code>
<code>}</code>
</pre>
 <p>With just an equal sign, you can define a default type to it.</p>
 <pre>
<code>protocol Foo {</code>
<code>    associatedtype FooType = BarType</code>
<code>}</code>
<code></code>
<code>struct Bar: Foo {} //Automatically sets FooType to BarType</code>
<code>//unless another type is specified</code>
</pre>
 <p>It is a very simple thing in nature, but I've found this undocumented feature very interesting. Having to set typealiases really bothered me - being forced to provide a typealias means that the type inherting the protocol is certainly going to do something unique, which might not <i>really</i> be true. Consider this structure used to define a HTTP request:</p>
 <pre>
<code>/// The representation of a HTTPClient's request.</code>
<code>public protocol HTTPRequest {</code>
<code>    /// The Value of a HTTPRequest is the response object retrieved after parsing the request's response.</code>
<code>    associatedtype Value</code>
<code>    /// The endpoint path of the request, to be appended after the HTTPClient's baseURL property.</code>
<code>    var path: String { get }</code>
<code>    /// Serializes the response of this request to its associated value type.</code>
<code>    func serialize(data: Data) throws -&gt; Value</code>
<code>}</code>
<code></code>
<code>extension HTTPRequest where Value: Unboxable {</code>
<code>    public func serialize(data: Data) throws -&gt; Value {</code>
<code>        let value: Value = try unbox(data: data)</code>
<code>        return value</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>This structure works very well for my current project because defining <code>path</code> and the <code>Value</code> type is all a request needs to do in order to work, and if <code>Value</code> conforms to <code>Unboxable</code>, the object is even retrieved automatically. This works perfectly for requests such as this one that retrieves an user:</p>
 <pre>
<code>struct UserRequest: HTTPRequest {</code>
<code>    typealias Value = User // is Unboxable</code>
<code>    let path: String = "v1/profiles"</code>
<code>}</code>
</pre>
 <p>But that implementation is not perfect: Using associated types like that means that I can't test an endpoint without defining a fully fledgled response type to it.</p>
 <p>Worse: What if I don't <i>need</i> my request to return something meaningful? Perhaps I don't care about the response, perhaps I just need to cache some <code>Data</code> on the device, or a plain dictionary is enough. For all these cases, I have to explicitly set <code>Value</code> to something and code a custom <code>serialize()</code> method.</p>
 <p>If that situation was common, I would simply not use associated types for my requests. Luckily, the existence of default values for associated types solve this problem entirely. Now, I can solve it by making all <code>HTTPRequest</code> objects return a <code>Data</code> object by default:</p>
 <pre>
<code>/// The representation of a HTTPClient's request.</code>
<code>public protocol HTTPRequest {</code>
<code>    /// The Value of a HTTPRequest is the response object retrieved after parsing the request's response.</code>
<code>    associatedtype Value = Data</code>
<code>    /// The endpoint path of the request, to be appended after the HTTPClient's baseURL property.</code>
<code>    var path: String { get }</code>
<code>    /// Serializes the response of this request to it's associated value type.</code>
<code>    func serialize(data: Data) throws -&gt; Value</code>
<code>}</code>
<code></code>
<code>extension HTTPRequest where Value: Data {</code>
<code>    public func serialize(data: Data) throws -&gt; Value {</code>
<code>        return data</code>
<code>    }</code>
<code>}</code>
<code></code>
<code>extension HTTPRequest where Value: Unboxable {</code>
<code>    public func serialize(data: Data?, error: Error?) throws -&gt; Value {</code>
<code>        let value: Value = try unbox(data: data)</code>
<code>        return value</code>
<code>    }</code>
<code>}</code>
</pre>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>Plain requests can now work purely with a <code>path</code> property (and return a plain <code>Data</code> object) while still allowing the regular requests to provide their custom responses.</p>
 <pre>
<code>struct ABTestDataRequest: HTTPRequest {</code>
<code>    let path: String = "v1/abtest"</code>
<code>}</code>
</pre>
 <p>Follow me on my Twitter - <a href="https://twitter.com/rockbruno_">@rockbruno_</a>, and let me know of any suggestions and corrections you want to share.</p>
 <h2>Reference</h2>
 <a href="https://bugs.swift.org/browse/SR-8761">SR-8761</a>
 <br>
</div>]]></description>
</item>
<item>
    <title>Detecting TouchID fingerprint/FaceID face changes</title>
    <link>https://swiftrocks.com/detecting-touchid-fingerprint-changes</link>
    <guid>https://swiftrocks.com/detecting-touchid-fingerprint-changes</guid>
    <pubDate>Fri, 26 Oct 2018 10:42:07 GMT-3</pubDate>
<description><![CDATA[
 
  
  <!--WRITEIT_POST_NAME=Detecting TouchID fingerprint/FaceID face changes--> 
  <!--WRITEIT_POST_HTML_NAME=detecting-touchid-fingerprint-changes--> 
  <!--WRITEIT_POST_SITEMAP_DATE_LAST_MOD=2020-04-12T14:00:00+02:00--> 
  <!--WRITEIT_POST_SITEMAP_DATE=2018-10-26T13:42:07+00:00--> 
  <!--Add here the additional properties that you want each page to possess.--> 
  <!--These properties can be used to change content in the template page or in the page itself as shown here.--> 
  <!--Properties must start with 'WRITE_IT_POST'.--> 
  <!--Writeit provides and injects WRITEIT_POST_NAME and WRITEIT_POST_HTML_NAME by default.--> 
  <!--WRITEIT_POST_SHORT_DESCRIPTION=By default, LAContext's evaluatePolicy method will consider any registered fingerprint/face valid - even if they were added after your app was installed.--> 
  <title>Detecting TouchID fingerprint/FaceID face changes</title>  
 

<div class="blog-post"> 
 <div class="post-title-index">  
  <h1>Detecting TouchID fingerprint/FaceID face changes</h1>
 </div> 
 <div class="post-info"> 
  <div class="category category-ios">
   iOS
  </div> 
  <div class="post-info-text">
   Published on 20 Jan 2018 
  </div> 
 </div> 
 <div class="sponsor-article-ad-auto hidden"></div>  
 <p>By default, <b>LAContext's</b> <b>evaluatePolicy</b> method will consider any registered fingerprint/face valid - even if they were added after your app was installed.</p>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>If your app contains sensitive data (like a bank or marketplace app would), you probably don't want this "feature". If someone with bad intentions gets a hold of your user's unlocked phone and adds new fingerprints, he could efforteslly pretend to be the original user - and your TouchID/FaceID enabled app would never notice the difference.</p>
 <p>To detect hardware biometry changes, we can compare the value of one of <b>LAContext's</b> properties: <b>evaluatedPolicyDomainState</b>.</p>
 <p>From Apple's documentation:</p>
 <blockquote class="margin-top-40 margin-bottom-40"> 
  <p>This property is set only when evaluatePolicy is called and succesful Touch ID or Face ID authentication was performed, or when canEvaluatePolicy succeeds for a biometric policy. It stays nil for all other cases.</p> 
  <p>If biometric database was modified (fingers or faces were removed or added), evaluatedPolicyDomainState data will change. Nature of such database changes cannot be determined but comparing data of evaluatedPolicyDomainState after different evaluatePolicy will reveal the fact database was changed between calls.</p> 
  <p>Please note that the value returned by this property can change exceptionally between major OS versions even if the state of biometry has not changed.</p> 
 </blockquote>
 <p>Since this property returns a <b>Data</b> object, you can effortlessly save it to the user's device.</p>
 <div class="post-image margin-top-40 margin-bottom-40"> 
  <img src="https://i.imgur.com/1EFJdZj.jpg" alt=""> 
 </div>
 <p>Although Apple warns that this property can be unstable, at least by the time of this post's creation it managed to remain stable between updates.</p>
 <p>If you're concerned about stability, you could potentially check for major system updates through <b>UIDevice.current.systemVersion</b> and act accordingly.</p>
 <p>But what if the biometry data changes legitimally, like upgrading to an iPhone X? TouchID data will become FaceID data, changing <b>evaluatedPolicyDomainState</b>'s value.</p>
 <p>You could store all your data on the Keychain to prevent it from being backed up, but it turns out that <b>LAContext</b> contains several interesting properties.</p>
 <p>One of them is <b>biometryType</b>, which indicates which biometry system (TouchID/FaceID/none) is enabled at the user's device.</p>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>Like <b>evaluatedPolicyDomainState</b>, it starts at nil, requiring a canEvaluatePolicy or evaluatePolicy call to be filled. I personally use this property to change messages and errors, but it can be used to detect system changes as well.</p>
 <p>Due to possible stability issues, one could consider this a premature security measure. Because of that, consider if your app really needs this sort of protection - or even should have TouchID/FaceID support in first place.</p>
</div>]]></description>
</item>
<item>
    <title>Writing Custom Pattern Matching in Swift</title>
    <link>https://swiftrocks.com/writing-custom-pattern-matching-rules-in-swift</link>
    <guid>https://swiftrocks.com/writing-custom-pattern-matching-rules-in-swift</guid>
    <pubDate>Fri, 26 Oct 2018 10:42:07 GMT-3</pubDate>
<description><![CDATA[
 
  
  <!--WRITEIT_POST_NAME=Writing Custom Pattern Matching in Swift--> 
  <!--WRITEIT_POST_HTML_NAME=writing-custom-pattern-matching-rules-in-swift--> 
  <!--WRITEIT_POST_SITEMAP_DATE_LAST_MOD=2020-04-12T14:00:00+02:00--> 
  <!--WRITEIT_POST_SITEMAP_DATE=2018-10-26T13:42:07+00:00--> 
  <!--Add here the additional properties that you want each page to possess.--> 
  <!--These properties can be used to change content in the template page or in the page itself as shown here.--> 
  <!--Properties must start with 'WRITE_IT_POST'.--> 
  <!--Writeit provides and injects WRITEIT_POST_NAME and WRITEIT_POST_HTML_NAME by default.--> 
  <!--WRITEIT_POST_SHORT_DESCRIPTION=Pattern matching is available everywhere in Swift, and you have likely used it tons of times to deconstruct and bind values in things like switch cases. While regular switch cases are the most common use for patterns, Swift has several types of patterns which can be mixed and even used outside of switches to result in really cool and short lines of code.--> 
  <title>Writing Custom Pattern Matching in Swift</title>  
 

<div class="blog-post"> 
 <div class="post-title-index">  
  <h1>Writing Custom Pattern Matching in Swift</h1>
 </div> 
 <div class="post-info"> 
  <div class="category category-swift">
   Swift
  </div> 
  <div class="post-info-text">
   Published on 08 Aug 2018 
  </div> 
 </div>  
 <p>Pattern matching is available everywhere in Swift, and you have likely used it tons of times to deconstruct and bind values in things like <code>switch</code> cases. While regular <code>switch</code> cases are the most common use for patterns, Swift has several types of patterns which can be mixed and even used outside of <code>switches</code> to result in really cool and short lines of code. One thing that interests me in particular is that pattern matching can be used for a wide variety of things.</p>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>At first glance, it's easy to see pattern matching as simple equality checks:</p>
 <pre class="language-swift"><code class="language-swift">switch 80 {
case 100:
    //
case 80:
    //Matches, because 80 == 80
default:
    break
}
</code></pre>
 <p>Given that, you might think that something like <code>case "eighty"</code> wouldn't compile, after all, <code>"eighty"</code> and <code>80</code> aren't even the same type - and it's indeed what happens if you try it right now:</p>
 <pre class="language-swift"><code class="language-swift">if case "eighty" = 80 {
    //error: expression pattern of type 'String' cannot match values of type 'Int'
}
</code></pre>
 <p>But that's not necessarily the case. When developing your projects, you might have noticed that some types have special interactions between each other, such as <code>Ranges</code> and their associated types:</p>
 <pre class="language-swift"><code class="language-swift">switch 80 {
case 0...20:
	break
case 21...50:
    break
case 51...100:
    //Matches, because 80 is inside 51...100
default:
    break
}
</code></pre>
 <p>The reason for this is the <code>~=</code> <b>pattern matching operator</b>. This operator doesn't see much use in regular projects (you might have seen it before for this exact <i>is number inside range</i> example), but it is used a lot internally in Swift and it's exactly what's used to confirm case statements.</p>
 <p>For most cases, the operator is a simple wrapper for an equality check (like the <code>Int</code> example), but <code>Range</code> has a special implementation for <code>~=</code> when used against its own associated type, allowing it to have this custom behaviour when pattern matching:</p>
 <pre class="language-swift"><code class="language-swift">extension RangeExpression {
    @inlinable
    public static func ~= (pattern: Self, value: Bound) -&gt; Bool {
      return pattern.contains(value)
    }
}
</code></pre>
 <p>And since <code>~=</code> is available globally, you can overload it in order to write your own pattern matching logic!</p>
 <p>To make <code>"eighty"</code> match <code>80</code>, for example, all you need to do is add a version of the operator that matches <code>String</code> patterns with <code>Int</code> values:</p>
 <pre class="language-swift"><code class="language-swift">func ~= (pattern: String, value: Int) -&gt; Bool {
    if pattern == "eighty" {
        return value == 80
    } else if pattern == "not eighty" {
        return value != 80
    } else {
        return false
    }
}

switch 80 {
case "eighty":
    //Compiles and matches!
case "not eighty":
    //
default:
   break
}
</code></pre>
 <p>Now let's say my app recieved a deep link in the shape of a path string and I need to decide which of my tabBar's <code>UIViewControllers</code> this deep link belongs too - in the form of a <code>AppTab</code> type:</p>
 <pre class="language-swift"><code class="language-swift">enum AppTab: String {
    case home
    case orderHistory
    case profile
}

let deepLink = DeepLink(path: "home", parameters: [:])
</code></pre>
 <p>There are several ways to do this, including adding a <code>correspondingTab</code> property to the deep link itself or subclassing the <code>DeepLink</code> type, but with custom pattern matching, this attribution can be one-lined without having to touch the <code>DeepLink</code> type!</p>
 <pre class="language-swift"><code class="language-swift">func ~= (pattern: AppTab, value: DeepLink) -&gt; Bool {
    return value.path.hasPrefix(pattern.rawValue)
}

switch deepLink {
case .home:
    homeViewController.handle(deepLink: deepLink)
case .orderHistory:
    historyViewController.handle(deepLink: deepLink)
case .profile:
    profileViewController.handle(deepLink: deepLink)
default:
    break
}
</code></pre>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>This allows you to bypass having to map broader types into more specific ones, such as how an <code>Int</code> can be mapped to a <code>WeekDay</code> enum. In this case in particular, your backend would return you the week day either as an <code>Int</code> or a <code>String</code>, and with custom pattern matching you can make use of this broader type while still treating it like it was mapped to the more specific enum type. This can be useful when you want to try concepts without commiting to certain approachs or types:</p>
 <pre class="language-swift"><code class="language-swift">enum WeekDay: Int {
    case sunday
    case monday
    case tuesday
    case wednesday
    case thursday
    case friday
    case saturday
}

func ~= (pattern: WeekDay, value: Int) -&gt; Bool {
    return pattern.rawValue == value
}

// Server returns:
// { nextHoliday: { weekDay: 5 } }

if case .friday? = nextHoliday?.weekDay {
    print("Woohoo!")
}
</code></pre>
 <p>Creation of custom patterns is a simple way to write cleaner code without too much effort, as you can leverage <code>cases</code> to jump straight to the point without having to add additional properties to your types - while making sure your code doesn't become harder to understand.</p>
 <h2>References and Good reads</h2>
 <a href="https://docs.swift.org/swift-book/ReferenceManual/Patterns.html">Apple Docs: Patterns</a>
 <br>
</div>]]></description>
</item>
<item>
    <title>How CaseIterable Works Internally in Swift</title>
    <link>https://swiftrocks.com/how-caseiterable-works-internally-in-swift</link>
    <guid>https://swiftrocks.com/how-caseiterable-works-internally-in-swift</guid>
    <pubDate>Fri, 26 Oct 2018 10:42:07 GMT-3</pubDate>
<description><![CDATA[
 
  
  <!--WRITEIT_POST_NAME=How CaseIterable Works Internally in Swift--> 
  <!--WRITEIT_POST_HTML_NAME=how-caseiterable-works-internally-in-swift--> 
  <!--WRITEIT_POST_SITEMAP_DATE_LAST_MOD=2020-04-12T14:00:00+02:00--> 
  <!--WRITEIT_POST_SITEMAP_DATE=2018-10-26T13:42:07+00:00--> 
  <!--Add here the additional properties that you want each page to possess.--> 
  <!--These properties can be used to change content in the template page or in the page itself as shown here.--> 
  <!--Properties must start with 'WRITE_IT_POST'.--> 
  <!--Writeit provides and injects WRITEIT_POST_NAME and WRITEIT_POST_HTML_NAME by default.--> 
  <!--WRITEIT_POST_SHORT_DESCRIPTION=CaseIterable is one of my favorite features in Swift 4.2. Despite being a simple protocol, it solves the common problem (that I personally faced many times) of needing access to an array containing all the cases of a certain enum.--> 
  <title>How CaseIterable Works Internally in Swift</title> 
 

<div class="blog-post"> 
 <div class="post-title-index">  
  <h1>How CaseIterable Works Internally in Swift</h1>
 </div> 
 <div class="post-info"> 
  <div class="category category-compiler">
   Compiler
  </div> 
  <div class="category category-swift">
   Swift
  </div> 
  <div class="post-info-text">
   Published on 21 Sep 2018 
  </div> 
 </div>  
 <p><code>CaseIterable</code> is one of my favorite features in Swift 4.2. Despite being a simple protocol, it solves the common problem (that I personally faced many times) of needing access to an array containing all the cases of a certain enum.</p>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>If we take a look at how <code>CaseIterable</code> is implemented in the Standard Library, we can see that the protocol is just what one would expect it to be: a simple definition of an array of cases.</p>
 <pre>
<code>public protocol CaseIterable {</code>
<code>    /// A type that can represent a collection of all values of this type.</code>
<code>    associatedtype AllCases: Collection where AllCases.Element == Self</code>
<code></code>
<code>    /// A collection of all values of this type.</code>
<code>    static var allCases: AllCases { get }</code>
<code>}</code>
</pre>
 <p>But this article isn't about the Swift aspect of this protocol. As you probably know, this protocol is special: you don‚Äôt need to define and fill the <code>allCases</code> type - <b>the compiler does it for you.</b></p>
 <pre>
<code>enum MyEnum: CaseIterable {</code>
<code>    case foo</code>
<code>    case bar</code>
<code></code>
<code> // Code generated by the compiler</code>
<code>    static var allCases: AllCases { // alias for [MyEnum]</code> 
<code>        return [.foo, .bar]</code>
<code>    }</code>
<code> // </code>
<code>}</code>
</pre>
 <p>This behaviour isn‚Äôt new - the same concept is applied in many other protocols like <code>RawRepresentable</code> and <code>Codable</code> (and now also <code>Equatable</code>/<code>Hashable</code>), but I had never really researched how this was done. Since I've been studying compilers lately to be able to fix <a href="https://github.com/rockbruno/swiftshield">SwiftShield's</a> edge cases, I took this opportunity to jump into Swift's source code, learn something and show you how it's done.</p>
 <h2>Retrieving a .swift file's Abstract Syntax Tree</h2>
 <p>In order to find out how Swift's generated code is generated, we need to know what this generated code <i>actually</i> looks like.</p>
 <p>You can reverse engineer the resulting binary, but it would be painfully hard to understand what the assembly means. Another option is to fork the Swift compiler and attach lldb to it, but you would need to know what to breakpoint in the first place - which I have no idea.</p>
 <p>Luckily, the Swift compiler in your Xcode's toolchain offers several arguments that allow you to extract human-readable files that represent "processed" versions of Swift source files, and one of these options allow you to retrieve the <b>Abstract Syntax Tree (AST)</b> of a file. </p>
 <p>Although the AST is just the contents of your file written as a tree-like structure, the AST returned by the Swift compiler will contain all the optimizations and overall magic done to your file. This allows us to see what an enum with <code>CaseIterable</code> looks like after compiling. </p>
 <p>First, I'll create a basic enum at some file named <code>enum.swift</code>:</p>
 <pre>
<code>enum MyEnum: CaseIterable {</code>
<code>    case foo</code>
<code>    case bar</code>
<code>}</code>
</pre>
 <p>Now, to get the AST of that, I'll run <code>swiftc</code> with the <code>-dump-ast</code> argument:</p>
 <pre class="command-line language-bash" data-host="SwiftRocks">
<code>swiftc -dump-ast enum.swift</code>
</pre>
 <p>This returns a gigantic tree structure due to all the code generation involved in Swift, but I extracted the part relevant to the declaration of <code>allCases</code>:</p>
 <pre>
<code>(var_decl implicit "allCases" type='[MyEnum]' interface type='[MyEnum]' access=internal type storage_kind=computed</code>
<code>  (accessor_decl implicit 'anonname=0x7fa86f015c28' interface type='(MyEnum.Type) -&gt; () -&gt; [MyEnum]' access=internal type getter_for=allCases</code>
<code>    (parameter_list</code>
<code>      (parameter "self" interface type='MyEnum.Type'))</code>
<code>    (parameter_list)</code>
<code>    (brace_stmt</code>
<code>      (return_stmt implicit</code>
<code>        (array_expr type='[MyEnum]'</code>
<code>          (dot_syntax_call_expr implicit type='MyEnum' nothrow</code>
<code>            (declref_expr implicit type='(MyEnum.Type) -&gt; MyEnum' decl=moduletest.(file).MyEnum.foo@/Users/bruno.rocha/Desktop/moduletest.swift:2:10 function_ref=double)</code>
<code>            (type_expr implicit type='MyEnum.Type' typerepr='&lt;&lt;NULL&gt;&gt;'))</code>
<code>          (dot_syntax_call_expr implicit type='MyEnum' nothrow</code>
<code>            (declref_expr implicit type='(MyEnum.Type) -&gt; MyEnum' decl=moduletest.(file).MyEnum.bar@/Users/bruno.rocha/Desktop/moduletest.swift:3:10 function_ref=double)</code>
<code>            (type_expr implicit type='MyEnum.Type' typerepr='&lt;&lt;NULL&gt;&gt;')))))))</code>
</pre>
 <p>ASTs are very verbose, but the names help us understand what this actually means. We have a declaration of an <code>allCases</code> property (<code>var_decl</code>), which (<code>brace_stmt</code>) returns (<code>return_stmt</code>) a <code>MyEnum</code> array (<code>array_expr</code>) containing <code>.foo</code> (defined by the <code>dot_syntax_call_expr</code> of implicit type <code>MyEnum</code> followed by the <code>declref_expr</code> reference of <code>MyEnum.foo</code>) and <code>.bar</code> (same as before).</p>
 <p> Verbosity aside, this is the same as the <code>return [.foo, .bar]</code> shown above. But where is this code injection happening?</p>
 <h2>Debugging the Swift Compiler</h2>
 <p>Since <code>CaseIterable</code> is a relatively simple protocol, we can likely uncover its internals by searching the <a href="https://github.com/apple/swift">open source Swift repository</a> on GitHub. I did this and got only about 2 pages of references - most being unit tests.</p>
 <p>One of the results is a reference to the actual thing: A suspicious method named <code>deriveCaseIterable_enum_getter</code> in a file named <a href="https://github.com/apple/swift/blob/537954fb9338951ce94dbe8549bbc7f0e2b1395f/lib/Sema/DerivedConformanceCaseIterable.cpp#L43">DerivedConformanceCaseIterable.cpp</a> that takes a property's body and appends some content to it. Bingo!</p>
 <p>But before analyzing what this method does, I'm interested in knowing how the compiler got here in the first place.</p>
 <p>By making a fork of the Swift compiler and building it in debug mode, we're able to attach lldb to it, breakpoint this method and call <code>bt</code> to print its backtrace.</p>
 <pre class="command-line language-bash" data-host="SwiftRocks">
<code>lldb -- /swift-fork/build/Ninja-ReleaseAssert+swift-DebugAssert/swift-macosx-x86_64/bin/swiftc -dump-ast enum.swift</code>
</pre>
 <p><b><i>(Note)</i></b> Since I researched this all by myself, some assumptions might not be fully correct. Feel free to correct me if you know the Swift compiler!</p>
 <p>If you take a look at the file in question, you'll find that <code>deriveCaseIterable_enum_getter</code> isn't called directly. Instead, it gets passed as a reference from another method called <code>deriveCaseIterable</code>. This means that backtracing won't reveal the information we want - so instead of backtracing it directly, I'll backtrace <code>deriveCaseIterable</code> itself.</p>
 <pre class="command-line language-bash" data-host="SwiftRocks" , data-prompt="(lldb)" data-output="3-4">
<code>b DerivedConformanceCaseIterable.cpp:82
run
Process 15104 stopped
frame #0: 0x0000000101ca809e DerivedConformance::deriveCaseIterable(this=0x00007ffeefbf6d60, requirement=0x000000010d97d838) at DerivedConformanceCaseIterable.cpp:82
bt</code>
</pre>
 <p>The backtrace goes a long way, but if we take the last seven stack nodes, we end up with:</p>
 <pre>
<code>DerivedConformance::deriveCaseIterable(this=0x00007ffeefbf6d60, requirement=0x000000010d97d838) at DerivedConformanceCaseIterable.cpp:82</code>
<code>TypeChecker::deriveProtocolRequirement(this=0x00007ffeefbf95f0, DC=0x000000010c8d9730, TypeDecl=0x000000010c8d9718, Requirement=0x000000010d97d838) at TypeCheckProtocol.cpp:5137</code>
<code>ConformanceChecker::resolveWitnessViaDerivation(this=0x00007ffeefbf82d0, requirement=0x000000010d97d838) at TypeCheckProtocol.cpp:3081</code>
<code>ConformanceChecker::checkConformance(this=0x00007ffeefbf82d0, Kind=ErrorFixIt) at TypeCheckProtocol.cpp:3665</code>
<code>MultiConformanceChecker::checkIndividualConformance(this=0x00007ffeefbf8058, conformance=0x000000010c8db5e8, issueFixit=true) at TypeCheckProtocol.cpp:1707</code>
<code>MultiConformanceChecker::checkAllConformances(this=0x00007ffeefbf8058) at TypeCheckProtocol.cpp:1328</code>
<code>TypeChecker::checkConformancesInContext(this=0x00007ffeefbf95f0, dc=0x000000010c8d9730, idc=0x000000010c8d9790) at TypeCheckProtocol.cpp:4720</code>
</pre>
 <p>After a quick inspection at each of these symbol's files, we can see that after parsing the file's structure, the compiler starts running a couple workflows to determine if all protocols and conditions are being conformed correctly (take a look at the files from the backtrace to see them yourself!).</p>
 <p>At <code>checkConformancesInContext</code>, the compiler has access to a context (our enum's declaraction). It extracts an array of conformances from it (<code>CaseIterable.allCases</code> in this case) and calls <code>checkAllConformances</code>.</p>
 <p><code>checkAllConformances</code> loops the array of conformances and calls <code>checkIndividualConformance</code> for each of them. If the requirements are not being satisfied, compilation warnings/errors are dispatched.</p>
 <p><code>checkIndividualConformance</code> seems to make superficial checks to the conformance, such as checking if it's using a <code>class</code> protocol outside a <code>class</code>, or if it's an OBJ-C object trying to conform to a Swift protocol. If the compiler is still incapable of confirming the requirements (because we're literally missing an entire property), <code>checkConformance</code> is called.</p>
 <p><code>checkConformance</code> will attempt to validate a protocol through a few procedures. This is where my subpar knowledge of compilers leaves me hanging, but I was able to grasp the meaning of the procedure that matters to us: <code>resolveWitnessViaDerivation</code>. This is where requirements try to be confirmed by injecting the relevant missing code.</p>
 <h2>Deriving Protocols</h2>
 <p>But before <code>resolveWitnessViaDerivation</code> is called, two important methods that are not in the backtrace are called: <code>getDerivableRequirement</code> and <code>derivesProtocolRequirement</code>. <a href="https://github.com/apple/swift/blob/eb75ad80dcfdc21e7ee1954d2c66c2c11fdee04d/lib/Sema/DerivedConformances.cpp#L140">You can see them here.</a></p>
 <p><code>getDerivableRequirement</code> determines if a certain requirement even supports this kind of code generation in first place. If the name of the requirement matches a requirement in a known protocol, we proceed:</p>
 <pre>
<code>// CaseIterable.allValues</code>
<code>    if (name.isSimpleName(ctx.Id_allCases))</code>
<code>        return getRequirement(KnownProtocolKind::CaseIterable);</code>
</pre>
 <p>The <code>getRequirement</code> from the return statement then calls <code>derivesProtocolRequirement</code>, which will try to match the requirement with the protocol's own set of rules.</p>
 <p>For the "<code>CaseIterable</code> inside enums" feature, the rules are:</p>
 <pre>
<code>case KnownProtocolKind::CaseIterable:</code>
<code>    return !enumDecl-&gt;hasPotentiallyUnavailableCaseValue()</code>
<code>           &amp;&amp; enumDecl-&gt;hasOnlyCasesWithoutAssociatedValues();</code>
</pre>
 <p>To be honest, I'm not really sure what an <code>PotentiallyUnavailableCaseValue</code> refers to <i>(Update: ≈Åukasz Grzywacz discovered that this is checking for cases inside <code>#available</code> conditions!)</i>, but the second condition is something we know: The derivation will only work if your cases don't contain associated values, as the compiler can't possibly know which value you want to be there. That's not the case for <code>MyEnum</code>, so we're good!</p>
 <p>With the derivation being possible, we head back to the backtrace as <code>deriveProtocolRequirement</code> gets called. The compiler will now attempt to generate the remaining code.</p>
 <p>The same object/protocol name matching happens in this method, but in order to actually perform the code generation. For <code>CaseIterable</code>, this results in <code>deriveCaseIterable</code> being called.</p>
 <pre>
<code>case KnownProtocolKind::CaseIterable:</code>
<code>    return derived.deriveCaseIterable(Requirement);</code>
</pre>
 <p><code>deriveCaseIterable</code> performs a few more checks, like seeing if protocol was added in an extension (which is a no-no for derivation). If all goes well, it defines an empty <code>allCases</code> property and finally calls the method that fills it: the <code>deriveCaseIterable_enum_getter</code> that we first saw.</p>
 <pre>
<code>auto *returnTy = computeAllCasesType(Nominal); // [MyEnum]</code>
<code></code>
<code>VarDecl *propDecl;</code>
<code>PatternBindingDecl *pbDecl;</code>
<code>std::tie(propDecl, pbDecl) = declareDerivedProperty(TC.Context.Id_allCases, returnTy, returnTy, *isStatic=*/true, /*isFinal=*/true);</code>
<code></code>
<code>// Define the getter.</code>
<code>auto *getterDecl = addGetterToReadOnlyDerivedProperty(TC, propDecl, returnTy);</code>
<code></code>
<code>// Set the getter's body.</code>
<code>getterDecl-&gt;setBodySynthesizer(&amp;deriveCaseIterable_enum_getter);</code>
</pre>
 <p>This is the definition of <code>deriveCaseIterable_enum_getter</code>:</p>
 <pre>
<code>void deriveCaseIterable_enum_getter(AbstractFunctionDecl *funcDecl) {</code>
<code>    auto *parentDC = funcDecl-&gt;getDeclContext();</code>
<code>    auto *parentEnum = parentDC-&gt;getSelfEnumDecl();</code>
<code>    auto enumTy = parentDC-&gt;getDeclaredTypeInContext();</code>
<code>    auto &amp;C = parentDC-&gt;getASTContext();</code>
<code></code>
<code>    SmallVector&lt;Expr *, 8&gt; elExprs;</code>
<code>    for (EnumElementDecl *elt : parentEnum-&gt;getAllElements()) {</code>
<code>        auto *ref = new (C) DeclRefExpr(elt, DeclNameLoc(), /*implicit*/true);</code>
<code>        auto *base = TypeExpr::createImplicit(enumTy, C);</code>
<code>        auto *apply = new (C) DotSyntaxCallExpr(ref, SourceLoc(), base);</code>
<code>        elExprs.push_back(apply);</code>
<code>    }</code>
<code>    auto *arrayExpr = ArrayExpr::create(C, SourceLoc(), elExprs, {}, SourceLoc());</code>
<code></code>
<code>    auto *returnStmt = new (C) ReturnStmt(SourceLoc(), arrayExpr);</code>
<code>    auto *body = BraceStmt::create(C, SourceLoc(), ASTNode(returnStmt), SourceLoc());</code>
<code>    funcDecl-&gt;setBody(body);</code>
<code>}</code>
</pre>
 <p>The interesting thing about this method is that it is a lot less complicated than a non-compiler person like me would expect. Because we're in the middle of the compilation, the compiler has access to a mutable version of our AST seen above and a direct reference to the node that represents the main declaration of our CaseIterable-semi-conformant enum. To add <code>allCases</code> to it, we just literally write it in AST form and append it to the enum's node.</p>
 <p>Although C++ isn't the easiest language to understand, you can see that this is just iterating the enum's cases and creating a return statement as a bunch of expressions that match the expressions of the AST we've seen above. The parameter <code>funcDecl</code> is the empty body of <code>allClasses</code> - which was generated by <code>deriveCaseIterable</code>. After the expression is generated, it gets applied to the body.</p>
 <h2>Fun time: Adding more properties to CaseIterable</h2>
 <p>Now that we've figured out how it works, how about adding our own properties to it? I think my fake <code>CaseIterable</code> would benefit from having a <code>first</code> property that returned the first defined case.</p>
 <p>From the Standard Library's point of view, this is pretty straight-forward as we just need to define a new static <code>var</code>:</p>
 <pre>
<code>public protocol CaseIterable {</code>
<code>    /// A type that can represent a collection of all values of this type.</code>
<code>    associatedtype AllCases: Collection where AllCases.Element == Self</code>
<code></code>
<code>    /// A collection of all values of this type.</code>
<code>    static var allCases: AllCases { get }</code>
<code></code>
<code>    /// The first case of this type.</code>
<code>    static var first: Self { get }</code>
<code>}</code>
</pre>
 <p>But the users of this protocol don't need to fill the <code>first</code> property if it's being used on an enum, so I want this property to be derived by the compiler as well.</p>
 <p>To do this, I'll first clone the <code>deriveCaseIterable_enum_getter</code> method that generates the case array and modify it so the expression returns the first case instead of the array:</p>
 <pre>
<code>void deriveCaseIterable_first(AbstractFunctionDecl *funcDecl) {</code>
<code>    auto *parentDC = funcDecl-&gt;getDeclContext();</code>
<code>    auto *parentEnum = parentDC-&gt;getSelfEnumDecl();</code>
<code>    auto enumTy = parentDC-&gt;getDeclaredTypeInContext();</code>
<code>    auto &amp;C = parentDC-&gt;getASTContext();</code>
<code></code>
<code>    EnumElementDecl *elt = parentEnum-&gt;getAllElements().front();</code>
<code>    auto *ref = new (C) DeclRefExpr(elt, DeclNameLoc(), /*implicit*/true);</code>
<code>    auto *base = TypeExpr::createImplicit(enumTy, C);</code>
<code>    auto *dotExpr = new (C) DotSyntaxCallExpr(ref, SourceLoc(), base);</code>
<code></code>
<code>    auto *returnStmt = new (C) ReturnStmt(SourceLoc(), dotExpr);</code>
<code>    auto *body = BraceStmt::create(C, SourceLoc(), ASTNode(returnStmt), SourceLoc());</code>
<code>    funcDecl-&gt;setBody(body);</code>
<code>}</code>
</pre>
 <p>With that done, we now need to make this method get called. We've seen previously that <code>deriveCaseIterable_enum_getter</code> gets called by <code>deriveCaseIterable()</code> - if we inspect the contents of that method, we'll find that it's able to detect the name of the parameter being checked:</p>
 <pre>
<code>ValueDecl *DerivedConformance::deriveCaseIterable(ValueDecl *requirement) {</code>
<code>    // Deleted to make stuff shorter: Some pre-checks</code>
<code></code>
<code>    if (requirement-&gt;getBaseName() != TC.Context.Id_allCases) {</code>
<code>        // Deleted to make stuff shorter: Throw compilation error</code>
<code>    }</code>
<code></code>
<code>    auto *returnTy = computeAllCasesType(Nominal); // Define the [MyEnum] return type</code>
<code>    // Deleted to make stuff shorter: Define allCases's getter</code>
<code>    declareDerivedProperty(TC.Context.Id_allCases, returnTy, returnTy, *isStatic=*/true, /*isFinal=*/true);</code>
<code>    // Deleted to make stuff shorter: Prepare allCases's getter</code>
<code>    getterDecl-&gt;setBodySynthesizer(&amp;deriveCaseIterable_enum_getter);</code>
<code>}</code>
</pre>
 <p>After searching a bit, I've found that the <code>Id_allCases</code> property comes from a file named <a href="https://github.com/apple/swift/blob/cc329fee03d6d6a30eb526e4be28bb876bd6ba0f/include/swift/AST/KnownIdentifiers.def">KnownIdentifiers.def</a>. I've edited it to add a new <code>Id_first</code> property for our feature. I've also added <code>Id_first</code> to the <code>getDerivableRequirement()</code> method mentioned above so the compiler knows that this property can be derived.</p>
 <p>For this feature to work, we need to keep the old <code>allCases</code> logic but add an <code>else</code> block to treat the new <code>first</code> requirement.</p>
 <p>After creating a block for <code>first</code>, we need to change <code>returnTy</code> to be <code>MyEnum</code> instead of <code>[MyEnum]</code> and have <code>declareDerivedProperty()</code> use <code>Id_first</code> as the property name instead of <code>Id_allCases</code>, and finally, have <code>setBodySynthesizer</code> use the new method.</p>
 <p>To make <code>returnTy</code> be <code>MyEnum</code>, I just looked up how <code>computeAllCasesType()</code> was retrieving the enum's type, which ended up being by calling <code>Nominal-&gt;getDeclaredInterfaceType();</code>.</p>
 <p>After some coding, the final method looks like this: <a href="https://gist.github.com/rockbruno/410a4ce94383b27f6d48aaaeb12b0b4b">(You can see the full version here.)</a></p>
 <pre>
<code>ValueDecl *DerivedConformance::deriveCaseIterable(ValueDecl *requirement) {</code>
<code>    // Deleted to make stuff shorter: Some pre-checks</code>
<code></code>
<code>    Type returnTy;</code>
<code>    Identifier propertyId;</code>
<code></code>
<code>    if (requirement-&gt;getBaseName() == TC.Context.Id_allCases) {</code>
<code>        returnTy = computeAllCasesType(Nominal);</code>
<code>        propertyId = TC.Context.Id_allCases;</code>
<code>    } else if (requirement-&gt;getBaseName() == TC.Context.Id_first) {</code>
<code>        returnTy = Nominal-&gt;getDeclaredInterfaceType();</code>
<code>        propertyId = TC.Context.Id_first;</code>
<code>    } else {</code>
<code>        // Deleted to make stuff shorter: Throw compilation error</code>
<code>    }</code>
<code></code>
<code>    // Deleted to make stuff shorter: Define allCases's getter</code>
<code>    declareDerivedProperty(propertyId, returnTy, returnTy, /*isStatic=*/true, /*isFinal=*/true);</code>
<code></code>
<code>    if (requirement-&gt;getBaseName() == TC.Context.Id_allCases) {</code>
<code>        getterDecl-&gt;setBodySynthesizer(&amp;deriveCaseIterable_enum_getter);</code>
<code>    } else {</code>
<code>        getterDecl-&gt;setBodySynthesizer(&amp;deriveCaseIterable_first);</code>
<code>    }</code>
<code>}</code>
</pre>
 <p>After building the compiler, we can get a <code>CaseIterable</code> enum's first case without explicitely defining it!</p>
 <pre>
<code>enum MyEnum: CaseIterable {</code>
<code>    case foo</code>
<code>    case bar</code>
<code>}</code>
<code></code>
<code>print(MyEnum.first) // .foo</code>
</pre>
 <h2>Conclusion</h2>
 <p>Compilers are scary, and the Swift one is no different. I'm still trying to figure out how most things work (If you're a compiler expert, I'm looking for tips on great books and resources!), but one thing that I've said before on my posts is that knowing the internals of a language can really help you write efficient code. I had a lot of fun inspecting this feature and hope it was useful to you in some way.</p>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>Follow me on my Twitter - <a href="https://twitter.com/rockbruno_">@rockbruno_</a>, and let me know of any suggestions and corrections you want to share.</p>
 <h2>References and Good reads</h2>
 <a href="https://github.com/apple/swift">The Swift Source Code</a>
 <br>
 <br>
 <p>Update: People were curious on how <code>first</code> acts if the enum has no cases: It crashes! We can fix it by adding a new rule to <code>derivesProtocolRequirement</code> that returns false if the requirement is <code>first</code> and the enum is empty - which would make the compiler return a <code>does not conform to CaseIterable</code> error in that case.</p>
</div>]]></description>
</item>
<item>
    <title>The Forbidden @inline Attribute in Swift</title>
    <link>https://swiftrocks.com/the-forbidden-inline-attribute-in-swift</link>
    <guid>https://swiftrocks.com/the-forbidden-inline-attribute-in-swift</guid>
    <pubDate>Fri, 26 Oct 2018 10:42:07 GMT-3</pubDate>
<description><![CDATA[
 
  
  <!--WRITEIT_POST_NAME=The Forbidden @inline Attribute in Swift--> 
  <!--WRITEIT_POST_HTML_NAME=the-forbidden-inline-attribute-in-swift--> 
  <!--WRITEIT_POST_SITEMAP_DATE_LAST_MOD=2020-04-12T14:00:00+02:00--> 
  <!--WRITEIT_POST_SITEMAP_DATE=2018-10-26T13:42:07+00:00--> 
  <!--Add here the additional properties that you want each page to possess.--> 
  <!--These properties can be used to change content in the template page or in the page itself as shown here.--> 
  <!--Properties must start with 'WRITE_IT_POST'.--> 
  <!--Writeit provides and injects WRITEIT_POST_NAME and WRITEIT_POST_HTML_NAME by default.--> 
  <!--WRITEIT_POST_SHORT_DESCRIPTION=The @inline attribute is one of those obscure things in Swift - it's nowhere to be found in Apple's docs, doesn't help you write cleaner code and has no purpose but to help the compiler make optimization decisions, but it's related to a pretty important aspect of your app's performance.--> 
  <title>The Forbidden @inline Attribute in Swift</title>  
 

<div class="blog-post"> 
 <div class="post-title-index">  
  <h1>The Forbidden @inline Attribute in Swift</h1>
 </div> 
 <div class="post-info"> 
  <div class="category category-compiler">
   Compiler
  </div> 
  <div class="category category-swift">
   Swift
  </div> 
  <div class="post-info-text">
   Published on 26 May 2018 
  </div> 
 </div>  
 <p>The <code>@inline</code> attribute is one of those obscure things in Swift - it's nowhere to be found in Apple's docs, doesn't help you write cleaner code and has no purpose but to help the compiler make optimization decisions, but it's related to a pretty important aspect of your app's performance.</p>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>In programming, <b>function inlining</b> is a compiler optimization technique that removes the overhead of calling certain methods by directly replacing calls to them with the method's contents, basically pretending that the method never existed in first place. This provides a great performance boost.</p>
 <p>For example, consider the following code:</p>
 <pre class="language-swift"><code class="language-swift">func calculateAndPrintSomething() {
    var num = 1
    num *= 10
    num /= 5
    print("My number: \(num)")
}

print("I'm going to do print some number")
calculateAndPrintSomething()
print("Done!")
</code></pre>
 <p>Assuming that <code>calculateAndPrintSomething()</code> isn't used anywhere else, it's clear that the method doesn't need to exist in the compiled binary - it's purpose is purely to make the code easier to read.</p>
 <p>With function inlining, the Swift compiler can remove the overhead of calling an useless method by replacing it with it's contents:</p>
 <pre class="language-swift"><code class="language-swift">//The compiled binary version of the above example
print("I'm going to do print some number")
var num = 1
num *= 10
num /= 5
print("My number: \(num)")
print("Done!")
</code></pre>
 <p>Based on your optimization level, this is done automatically by the Swift compiler - favoring inlining if optimizing for speed (<code>-O</code>), or favoring <b>not</b> inlining if optimizing for binary size (<code>-Osize</code>), since inlining a long method that is called in several places would result in duplicated code, and a larger binary.</p>
 <p>Even though the compiler can make its own inlining decisions, the <code>@inline</code> attribute can be used in Swift to <b>force</b> its decision. It can be used in two ways:</p>
 <p><code>@inline(__always)</code>: Signals the compiler to always inline the method, if possible.</p>
 <p><code>@inline(never)</code>: Signals the compiler to never inline the method.</p>
 <p>Now, you might be asking: <i>When the hell is doing this a good idea?</i></p>
 <p>According to the Apple engineers, the answer is basically <a href="https://lists.swift.org/pipermail/swift-users/Week-of-Mon-20170227/004886.html">never.</a> Even though the attribute is available for public use and widely used in the Swift source code, it is not officially supported for public use. It was simply never meant to be publicly available, and to quote Jordan Rose: <i>the underscores are there for a reason.</i> Many known and unknown issues can arise if you use it.</p>
 <p>But since the attribute can be used publicly, I've decided that for the sake of learning something new I would experiment with it - and I've actually found cases where the attribute can be useful in iOS projects.</p>
 <p>The compiler will make its inlining decisions based on your project's optimization settings, but there are cases where you could want a method to go <b>against</b> the optimization setting. In these cases, <code>@inline</code> can be used to achieve the user's goals.</p>
 <p>For example, when optimizing for speed, it seems like the compiler will have a tendence to inline even methods that are not short, resulting in increased binary sizes. In this case, <code>@inline(never)</code> can be used to prevent the inlining of a specific widely-used-long method while still focusing on fast binaries.</p>
 <p>Another more practical example is that you might want a method to be hidden from possible hackers for containing some sort of sensitive info, regardless if it will make your code slower or bigger. You can try to make the code harder to understand or use some obfuscation tool like <a href="https://github.com/rockbruno/swiftshield">SwiftShield</a>, but <code>@inline(__always)</code> can achieve this without hurting your code. I've detailed this example below.</p>
 <h2>Using <code>@inline(__always)</code> to obfuscate Premium content</h2>
 <p>Let's pretend we have a music player in our app and some actions are premium-only. The <code>isUserSubscribed(_:)</code> method validates the user subscription and returns a boolean stating if the user is subscribed or not:</p>
 <pre class="language-swift"><code class="language-swift">func isUserSubscribed() -&gt; Bool {
    //Some very complex validation
    return true
}

func play(song: Song) {
	if isUserSubscribed() {
        //Play the song
    } else {
        //Ask user to subscribe
    }
}
</code></pre>
 <p>This works great for our code, but look what happens if I disassemble this app and search for the <code>play(_:)</code> method's assembly:</p>
 <div class="post-image margin-top-40 margin-bottom-40"> 
  <img src="https://i.imgur.com/3kqUFaF.png" alt=""> 
 </div>
 <p>If I was a hacker trying to crack this app's subscription, glancing at the <code>play(_:)</code> method was all I had to do to realize that a boolean called <code>isUserSubscribed(_:)</code> is controlling the app's subscription.</p>
 <p>I can now unlock the app's entire premium content by merely finding <code>isUserSubscribed(_:)</code> and forcing it to return <code>true</code>:</p>
 <div class="post-image margin-top-40 margin-bottom-40"> 
  <img src="https://i.imgur.com/JMjdAMS.png" alt=""> 
 </div>
 <p>In this case, likely because the method is widely used around the app, the compiler decided to not inline it. This naive decision created a security flaw that allowed the app to be quickly reverse-engineered.</p>
 <p>Now look what happens when <code>@inline(__always)</code> is applied to <code>isUserSubscribed(_:)</code>:</p>
 <pre class="language-swift"><code class="language-swift">@inline(__always) func isUserSubscribed() -&gt; Bool {
    //Some very complex validation
    return true
}

func play(song: Song) {
	if isUserSubscribed() {
        //Play the song
    } else {
        //Ask user to subscribe
    }
}
</code></pre>
 <div class="post-image margin-top-40 margin-bottom-40"> 
  <img src="https://i.imgur.com/JwkToz8.png" alt=""> 
 </div>
 <p>The same <code>play(_:)</code> method's assembly now contains no obvious reference to a subscription! The method call got completely replaced by the "complex validation" that happened inside of it, making the assembly look more cryptic and the subscription significantly harder to be cracked.</p>
 <p>As a bonus, since every call to <code>isUserSubscribed(_:)</code> got replaced by the validation, there is no single way to unlock the app's entire subscription - a hacker would now have to crack every single method that does the validation. Of course, this also means that our binary got larger as we now have duplicated code everywhere.</p>
 <p>Be aware that using <code>@inline(__always)</code> doesn't guarantee that the compiler will actually inline your method. The rules for it are unknown, and there are some cases where inlining is impossible, such as when dynamic dispatching can't be avoided.</p>
 <h2>What else?</h2>
 <p>Since <code>@inline</code> is not officially supported, you should really never use it in a real project and use this article only for the sake of learning something new.</p>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>However, I found it to be very useful and hope Apple decides to officially support it some day. If you are interested in more obscure Swift things, check out <a href="https://github.com/apple/swift">Swift's Source Code.</a></p>
 <p>Follow me on my Twitter - <a href="https://twitter.com/rockbruno_">@rockbruno_</a>, and let me know of any suggestions and corrections you want to share.</p>
 <h2>References and Good reads</h2>
 <a href="https://en.wikipedia.org/wiki/Inline_function">Inline Functions</a>
 <br>
 <a href="https://lists.swift.org/pipermail/swift-users/Week-of-Mon-20170227/004883.html">[swift-users] @inline Thread</a>
</div>]]></description>
</item>
<item>
    <title>Memory Management and Performance of Value Types</title>
    <link>https://swiftrocks.com/memory-management-and-performance-of-value-types</link>
    <guid>https://swiftrocks.com/memory-management-and-performance-of-value-types</guid>
    <pubDate>Fri, 26 Oct 2018 10:42:07 GMT-3</pubDate>
<description><![CDATA[
 
  
  <!--WRITEIT_POST_NAME=Memory Management and Performance of Value Types--> 
  <!--WRITEIT_POST_HTML_NAME=memory-management-and-performance-of-value-types--> 
  <!--WRITEIT_POST_SITEMAP_DATE_LAST_MOD=2020-04-12T14:00:00+02:00--> 
  <!--WRITEIT_POST_SITEMAP_DATE=2018-10-26T13:42:07+00:00--> 
  <!--Add here the additional properties that you want each page to possess.--> 
  <!--These properties can be used to change content in the template page or in the page itself as shown here.--> 
  <!--Properties must start with 'WRITE_IT_POST'.--> 
  <!--Writeit provides and injects WRITEIT_POST_NAME and WRITEIT_POST_HTML_NAME by default.--> 
  <!--WRITEIT_POST_SHORT_DESCRIPTION=It's very likely that you asked yourself at least once in your iOS career what's the difference between a struct and a class. While realistically the choice between using one or another always boils down to value semantics versus reference semantics, the performance differences between the two are expressive and can heavily favor one or another depending on the contents of your object, specially when dealing with value types.--> 
  <title>Memory Management and Performance of Value Types</title>  
 

<div class="blog-post"> 
 <div class="post-title-index">  
  <h1>Memory Management and Performance of Value Types</h1>
 </div> 
 <div class="post-info"> 
  <div class="category category-theory">
   Theory
  </div> 
  <div class="category category-compiler">
   Compiler
  </div> 
  <div class="category category-swift">
   Swift
  </div> 
  <div class="post-info-text">
   Published on 13 Apr 2018 
  </div> 
 </div>    
 <p>It's very likely that you asked yourself at least once in your iOS career what's the difference between a <code>struct</code> and a <code>class</code>. While realistically the choice between using one or another always boils down to <i>value semantics</i> versus <i>reference semantics</i>, the performance differences between the two are expressive and can heavily favor one or another depending on the contents of your object, specially when dealing with value types.</p>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>Some people might say that knowledge of memory architecture is irrelevant for application level developers, and I agree <i>partially</i>. Knowing how to save a few bits here and there will make no visible difference on newer iPhones, and premature optimization is a highly shunned practice.</p>
 <p>However, both reference and value types can severely slow down your app when misused, and such knowledge will define whether or not you can fix the problem efficiently.</p>
 <p>To understand the deeper differences between the two, let's look back at the address space of a process: (single thread for simplicity)</p>
 <pre>|- - - - - - - - - - - - - - - - - - - - - - - - - - |
|                    Instructions                    |
|- - - - - - - - - - - - - - - - - - - - - - - - - - -
|                    Global Data                     |
|- - - - - - - - - - - - - - - - - - - - - - - - - - -
|                        Heap                        |
|- - - - - - - - - - - - - - - - - - - - - - - - - - -
|      Nothing (Stack and heap grow towards here)    |
|- - - - - - - - - - - - - - - - - - - - - - - - - - -
|                        Stack                       |
|- - - - - - - - - - - - - - - - - - - - - - - - - - -</pre>
 <h2>Stack Allocation</h2>
 <p>In memory architecture, the stack is no different from the data structure you already know, and Stack Allocation is a simple and fast way to allocate/deallocate memory that involves the stack.</p>
 <p>Each "scope" in your app (like the inner contents of a method) will provide the amount of memory it needs to run, move the stack pointer in memory by such amount and run - adding data to the empty memory addresses it now posesses. After the scope is lost, the stack pointer will simply decrease by the same amount - safely deallocating all the scope's data. The cost of allocating/deallocating stack memory is literally the cost of assigning an integer.</p>
 <h3>Stack Allocated Value Types</h3>
 <p>In Stack Allocation, the data gathered by the scope means everything attributed to it - like method arguments, return values, but more importantly: <b>value types</b>. As long as the size of the value type is known during compile time and it doesn't contain / is not contained, recursively, by a reference type, it will not need reference counting, and its life will be <b>static</b> - equal to the life of its scope. It will be allocated completely on the stack, and when the scope is deallocated, so is the value type. The absence of reference counting overhead and the presence of stack allocation is a considerable performance boost.</p>
 <p><i>PS: All benchmarks done with -O. I had to add some special logic and keywords/attributes to prevent the compiler from skipping my methods, but I've hidden them in the examples to make the code easy to read.</i></p>
 <pre class="language-swift"><code class="language-swift">struct EmptyStruct {
	private let number: Int64 = 1
	//Empty classes have 64bits of storage by default for the pointer
	//so we're adding 64bits to our struct to make fair comparisons.
}

@inline(never) func createABunchOfEmptyStructs() {
    for _ in 0..&lt;1_000_000 {
        let myStruct = EmptyStruct()
    }
}

createABunchOfEmptyStructs()
//Moving the stack pointer up by the size of a million EmptyStructs.
//Adding a million EmptyStructs to the empty addresses created by moving the stack pointer.
//Moving the stack pointer down by the same amount.
//Total: ~0.005 seconds</code></pre>
 <p>If the contents of your value type are other stack allocated, static size value types, then your value type also is also static sized. That means your value type will also leverage full stack allocation as well as having a performance boost in copying operations.</p>
 <p>We once asked a candidate why he chose to use a <code>class</code> for something that was clearly immutable and meant to be treated with value semantics. His reasoning was that the object was being constantly sent as a parameter inside methods, and so he was concerned about the potential performance implications of copying that several times.</p>
 <p>Assigning a property to most value types will indeed create a full copy of the object. However, this <b>copy-on-assignment</b> behaviour for fully stack allocated value types is so fast and so cheap that Apple claims it runs in constant time:</p>
 <pre class="language-swift"><code class="language-swift">struct BigStaticStruct {
    let fp1: Int64 = 1
    let fp2: Int64 = 1
    let fp3: Int64 = 1
    let fp4: Int64 = 1
    let fp5: Int64 = 1
}

func createABunchOfCopiesOfHugeStruct() {
    let bigStruct = BigStaticStruct()
    for _ in 0..&lt;1_000_000 {
        let copy = bigStruct
    }
}

createABunchOfCopiesOfHugeStruct() // ~0.0033 secs

//Even if you increase the number of properties tenfold the runtime is unchanged
//because copying a static sized struct is a constant time operation.</code></pre>
 <p>Stack Allocation can, however, devour your app's memory if you're dealing with many depths of recursion. Thankfully, Swift has tail recursion optimization, meaning that if you disassemble a method with tail recursion you'll find an iterative version of your algorithm instead.</p>
 <h2>Heap Allocation</h2>
 <p>But what happens when you need to introduce objects with extendable sizes and <i>"shudders"</i> the concept of <b>pointers</b>?</p>
 <p>The stack is not meant to be used with objects that change in size, and the concept of pointers / dynamic lifetime means that an object's life could have nothing to do with its scope - after all, it's possible to have an object existing in memory even if there's nothing going on.</p>
 <p>The heap, like the stack, is not much different from the data structure with the same name, and in this case, it's meant to be used for dynamically-allocated, user-managed memory.</p>
 <p>When the process requests a certain amount of memory, the heap will search for a memory address that fulfills this request and return it to the process. When the memory is not being used anymore, the process must tell the heap to free that section of memory.</p>
 <p>In iOS, "not being used anymore" works in the shape of reference counting, and luckily the existence of ARC means that most things are automatically handled for you unless you have to deal with the <a href="https://developer.apple.com/documentation/swift/manual_memory_management">RawPointer family</a>.</p>
 <p>Heap Allocation is slower than Stack Allocation not just because of the more complex data structure - it also requires thread safety. Each thread has its own stack, but the heap is shared with everybody, demanding synchronization. However, it allows reference types and things like dynamic size arrays to exist.</p>
 <pre class="language-swift"><code class="language-swift">final class EmptyClass {}

@inline(never) func createABunchOfEmptyClasses() {
    for _ in 0..&lt;1_000_000 {
        let myClass = EmptyClass()
    }
}

createABunchOfEmptyClasses()

//Moving the stack pointer up by the size of a million EmptyClass pointers.
//Requesting memory in the heap for a million EmptyClasses.
//Adding a million EmptyClass pointers to the empty addresses created by moving the stack pointer, pointing to the heap's returned addresses.
//(Loop ends) Decrementing the reference count of the pointers.
//The reference count of each class drops to zero, and a request to free their memory addresses is sent.
//Moving the stack pointer down.
//Total: ~0.117 secs</code></pre>
 <p>It would be nice if memory management was as binary as saying that value types go to the stack and reference types go to the heap, but in reality, the life and performance of a value type is heavily defined by its contents.</p>
 <h3>Heap Allocated Value Types</h3>
 <p>If the size of your value type cannot be determined during compile time (because of a protocol/generic requirement), or if your value type recursively contains / is contained by a reference type (remember that closures are also reference types), then it will require heap allocation. This can range from being not being an issue at all to making your <code>struct</code> perform exponentially <b>worse</b> than it would if it was a <code>class</code> instead.</p>
 <p>Stack allocated value types are great because their life are directly related to their scope's life, but if your value type is the child of a <code>class</code>, a reference is all it takes for it to outlive its scope. This situation is common in <code>@escaping</code> closures, and this value type will lose its stack allocation properties in order to be fully <b>heap allocated</b> alongside the reference type. In a way, you could even say that this kind of value type is <b>a reference type itself</b>, as living in the heap means that several objects can point to it - even though it still possesses <i>value semantics</i>.</p>
 <p>If your value type is instead the parent of a heap allocated <code>class</code>, then it will not be heap allocated itself, but it <b>will</b> inherit reference counting overhead in order to be able to keep it's inner references alive. This can cause a considerable drop in performance depending on the complexity of the value type.</p>
 <p>In the Standard Library, examples of value types with child references are <code>String</code>, <code>Array</code>, <code>Dictionary</code> and <code>Set</code>. These value types contain internal reference types that manage the storage of elements in the heap, allowing them to increase/decrease in size as needed.</p>
 <p>Since heap operations are more expensive than stack ones, copying heap allocated value types is not a constant operation like in stack allocated ones. To prevent this from hurting performance, the Standard Library's extensible data structures are <b>copy-on-write</b>.</p>
 <p>With this capability, merely assigning properties will not copy the value type - instead, it will create a reference just like if it was a regular reference type. The actual copying will only happen when it's really necessary.</p>
 <pre class="language-swift"><code class="language-swift">//Copy on Assignment
let emptyStruct = EmptyStruct() //address A
let copy = emptyStruct //address B

//Copy on Write
let array = [1,2,3] //address C
var notACopy = array //still address C
notACopy = [4,5,6] //now address D</code></pre>
 <p>Be aware that any value type you create will be <b>copy-on-assignment</b>, but you can code them to have <b>copy-on-write</b> capabilities. This is not a compiler thing, The Standard Library itself does it on the code level and so can you. <a href="https://github.com/apple/swift/blob/master/docs/OptimizationTips.rst#advice-use-copy-on-write-semantics-for-large-values">Here's an example from Apple.</a></p>
 <h2>Problematic Reference Counting in Value Types With Inner References</h2>
 <p>A fully stack allocated value type will not need reference counting, but a value type with inner references <b>will</b> unfortunately inherit this ability.</p>
 <p>Consider two objects: a <code>struct</code> full of <code>classes</code> and a <code>class</code> full of the same <code>classes</code>:</p>
 <pre class="language-swift"><code class="language-swift">struct HugeDynamicStruct {
    var emptyClass = EmptyClass()
    var emptyClass2 = EmptyClass()
    var emptyClass3 = EmptyClass()
    var emptyClass4 = EmptyClass()
    var emptyClass5 = EmptyClass()
    var emptyClass6 = EmptyClass()
    var emptyClass7 = EmptyClass()
    var emptyClass8 = EmptyClass()
    var emptyClass9 = EmptyClass()
    var emptyClass10 = EmptyClass()
}

class HugeClass {
    var emptyClass = EmptyClass()
    var emptyClass2 = EmptyClass()
    var emptyClass3 = EmptyClass()
    var emptyClass4 = EmptyClass()
    var emptyClass5 = EmptyClass()
    var emptyClass6 = EmptyClass()
    var emptyClass7 = EmptyClass()
    var emptyClass8 = EmptyClass()
    var emptyClass9 = EmptyClass()
    var emptyClass10 = EmptyClass()
}
</code></pre>
 <p>The following snippet will check how long it takes to create a <code>HugeClass</code>, reference it ten million times, add all these references to an array and deallocate everything. Then it will do the same to a <code>struct</code> variant.</p>
 <pre class="language-swift"><code class="language-swift">func createABunchOfReferencesOfClass() {
    var array = [HugeClass]()
    let object = HugeClass()
    for _ in 0..&lt;10_000_000 {
        array.append(object)
    }
}

func createABunchOfCopiesOfStruct() {
    var array = [HugeDynamicStruct]()
    let object = HugeDynamicStruct()
    for _ in 0..&lt;10_000_000 {
        array.append(object)
    }
}

//Each object contains ten EmptyClasses

createABunchOfReferencesOfClass() // ~1.71 seconds
createABunchOfCopiesOfStruct() // ~5.1 seconds
</code></pre>
 <p>Judging from what was previously said it's somewhat expected that the <code>struct</code> version would take longer as it is <b>copy-on-assignment</b>, compared to the <code>class</code> version which is only increasing a reference count value.</p>
 <p>However, consider what happens when we increase the amount of <code>EmptyClasses</code> inside of each object:</p>
 <pre class="language-swift"><code class="language-swift">//Each object now contains TWENTY EmptyClasses

createABunchOfReferencesOfClass() // ~1.75 seconds
createABunchOfCopiesOfStruct() // ~14.5 seconds
</code></pre>
 <p>Adding more classes to <code>HugeClass</code> did nothing to the runtime of the algorithm, but <code>HugeDynamicStruct</code>'s version took <b>more than twice</b> as much to run!</p>
 <p>Since all reference types require reference counting, increasing the amount of properties of a <code>class</code> of <code>classes</code> will not change the runtime of this algorithm, as merely increasing the reference count of the parent reference will be enough to keep it's inner references alive.</p>
 <p>However, value types do not naturally have a reference count. If your value type contains inner references, copying it will require increasing the reference count of it's children instead - not the first, not the second, but literally <b>every single one</b> of them.</p>
 <pre class="language-swift"><code class="language-swift">final class ClassOfClasses {
    let emptyClass = EmptyClass()
    let emptyClass2 = EmptyClass()
    let emptyClass3 = EmptyClass()
}

let classOfClasses = ClassOfClasses()
let reference = classOfClasses
let reference2 = classOfClasses
let reference3 = classOfClasses

CFGetRetainCount(classOfClasses) // 4
CFGetRetainCount(classOfClasses.emptyClass) // 1
CFGetRetainCount(classOfClasses.emptyClass2) // 1
CFGetRetainCount(classOfClasses.emptyClass3) // 1

struct StructOfClasses {
    let emptyClass = EmptyClass()
    let emptyClass2 = EmptyClass()
    let emptyClass3 = EmptyClass()
}

let structOfClasses = StructOfClasses()
let copy = structOfClasses
let copy2 = structOfClasses
let copy3 = structOfClasses

CFGetRetainCount(structOfClasses) // Doesn't compile, structs themselves don't have a reference count.
CFGetRetainCount(structOfClasses.emptyClass) // 4
CFGetRetainCount(structOfClasses.emptyClass2) // 4
CFGetRetainCount(structOfClasses.emptyClass3) // 4
</code></pre>
 <p>The more reference types you have inside of a value type, the more reference counting overhead you are going to have when copying it, leading to potentially nasty performance issues.</p>
 <h2>Avoiding Reference Counting Overhead in Value Types</h2>
 <p>You can improve your app's performance by swapping unnecessary references with proper static size value types.</p>
 <p>Consider the following value type with inner references:</p>
 <pre class="language-swift"><code class="language-swift">struct DeliveryAddress {
    let identifier: String
    let type: String
}</code></pre>
 <p>If <code>identifier</code> represents an UUID, it can be safely replaced by <code>Foundation</code>'s <code>UUID</code> struct, which is statically sized.</p>
 <p>In a similar fashion, <code>type</code> could easily be a pre-defined <code>enum</code> instead.</p>
 <pre class="language-swift"><code class="language-swift">struct DeliveryAddress {
    enum AddressType {
        case home
        case work
    }
    let identifier: UUID
    let type: AddressType
}</code></pre>
 <p>With these changes, this struct is now statically sized. Not only reference counting overhead was eliminated, but it is also a lot more typesafe now.</p>
 <p>If your value type is more complicated than this (and you have a performance issue), ask yourself if it really shouldn't be a <code>class</code> with <b>copy-on-write</b> capabilities instead.</p>
 <p>From the Apple Docs:</p>
 <blockquote class="margin-top-40 margin-bottom-40"> 
  <p>As a general guideline, consider creating a structure when one or more of these conditions apply:</p> 
  <p><b>The structure‚Äôs primary purpose is to encapsulate a few relatively simple data values.</b></p> 
  <p><b>It is reasonable to expect that the encapsulated values will be copied rather than referenced when you assign or pass around an instance of that structure.</b></p> 
  <p><b>Any properties stored by the structure are themselves value types, which would also be expected to be copied rather than referenced.</b></p> 
  <p><b>The structure does not need to inherit properties or behavior from another existing type.</b></p> 
  <p>Examples of good candidates for structures include:</p> 
  <p><b>The size of a geometric shape, perhaps encapsulating a width property and a height property, both of type Double.</b></p> 
  <p><b>A way to refer to ranges within a series, perhaps encapsulating a start property and a length property, both of type Int.</b></p> 
  <p><b>A point in a 3D coordinate system, perhaps encapsulating x, y and z properties, each of type Double.</b></p> 
  <p>In all other cases, define a class, and create instances of that class to be managed and passed by reference. In practice, this means that most custom data constructs should be classes, not structures.</p> 
 </blockquote>
 <h2>What else?</h2>
 <p>Even though the examples shown here are extremely exaggerated, small mistakes can and will add up quick enough to cause you trouble in the future. Remember: People want to have a good time with apps, and most of them won't accept anything less than a silky smooth 60 fps experience. Waits/freezes are so universally hated that <a href="https://www.thinkwithgoogle.com/data-gallery/detail/mobile-site-abandonment-three-second-load/">53% of visits are abandoned if a mobile site takes longer than 3 seconds to load,</a> and you should keep that in mind when your app starts displaying random hiccups/slowdowns, specially when scrolling content.</p>
 <div class="sponsor-article-ad-auto hidden"></div>
 <p>Performance depends on several factors, and choosing between <code>structs</code> and <code>classes</code> are just one of them. If you are interested in this topic, I largely recommend watching the WWDC videos about Method Dispatching and Witness Tables.</p>
 <p>Follow me on my Twitter - <a href="https://twitter.com/rockbruno_">@rockbruno_</a>, and let me know of any suggestions and corrections you want to share.</p>
 <h2>References and Good reads</h2>
 <a href="http://www.cs.albany.edu/~sdc/CSI500/Fal13/OSTEP/">Operating Systems: Three Easy Pieces</a>
 <br>
 <a href="https://developer.apple.com/videos/play/wwdc2016/416/">WWDC: Understanding Swift Performance</a>
 <br>
 <a href="https://developer.apple.com/videos/play/wwdc2015/409/">WWDC: Optimizing Swift Performance</a>
 <br>
 <a href="https://developer.apple.com/videos/play/wwdc2015/414/">WWDC: Building Better Apps with Value Types in Swift</a>
 <br>
 <a href="https://github.com/apple/swift/blob/master/docs/OptimizationTips.rst">Apple: Optimization Tips</a>
 <br>
</div>]]></description>
</item>
<item>
    <title>iOS Security: Reverse Engineering Messenger's Chat Bubbles</title>
    <link>https://swiftrocks.com/reverse-engineering-ios-facebook-messenger-chat</link>
    <guid>https://swiftrocks.com/reverse-engineering-ios-facebook-messenger-chat</guid>
    <pubDate>Mon, 7 Nov 2016 11:42:07 GMT-2</pubDate>
<description><![CDATA[
 
  
  <!--WRITEIT_POST_NAME=iOS Security: Reverse Engineering Messenger's Chat Bubbles--> 
  <!--WRITEIT_POST_HTML_NAME=reverse-engineering-ios-facebook-messenger-chat--> 
  <!--WRITEIT_POST_SITEMAP_DATE_LAST_MOD=2020-04-12T14:00:00+02:00--> 
  <!--WRITEIT_POST_SITEMAP_DATE=2016-11-07T13:42:07+00:00--> 
  <!--Add here the additional properties that you want each page to possess.--> 
  <!--These properties can be used to change content in the template page or in the page itself as shown here.--> 
  <!--Properties must start with 'WRITE_IT_POST'.--> 
  <!--Writeit provides and injects WRITEIT_POST_NAME and WRITEIT_POST_HTML_NAME by default.--> 
  <!--WRITEIT_POST_SHORT_DESCRIPTION=Due do the messaging nature of the Objective-C runtime, a great amount of information about your code can be extracted and manipulated during runtime by external tools.--> 
  <title>iOS Security: Reverse Engineering Messenger's Chat Bubbles</title>  
 

<div class="blog-post"> 
 <div class="post-title-index">  
  <h1>iOS Security: Reverse Engineering Messenger's Chat Bubbles</h1>
 </div> 
 <div class="post-info"> 
  <div class="category category-reverse">Reverse Engineering</div>
  <div class="post-info-text">
   Published on 07 Nov 2016 
  </div> 
 </div>  
 <blockquote class="margin-top-40 margin-bottom-40"> 
  <p>This article is SwiftRocks's slimmed down version of my original <a href="https://medium.com/@brunorochaesilva/how-i-hacked-messengers-ios-app-custom-chat-bubble-colors-12f1ac7f070c">2016 Medium article.</a> The Medium article is badly written and contains mistakes, but it has more information on how to reproduce each step.</p> 
  <div class="sponsor-article-ad-auto hidden"></div> 
  <p>Update: As of May 3, 2018, this sadly doesn't seem to work anymore. My web chats returned to the blue color and the custom changes only apply locally. I guess color changes are validated on the backend now. Damn you Zuckerberg!</p> 
 </blockquote>
 <p>Due do the messaging nature of the Objective-C runtime, a great amount of information about your code can be extracted and manipulated during runtime by external tools. The <b>Selectors</b> you reference everyday are nothing more than exposed strings in your code, despite what Swift's <b>#selector</b> abstraction might imply. With the right tools, any production app can be messed with just like it's Xcode debugging counterpart.</p>
 <p>Facebook's Messenger app is an interesting app to test this kind of concept. It contains many minigames and features that change the app's layout globally - as in, they are not client side changes, everyone can see what you do both in the app and the website. These features contain zero security measures, after all, it's not like you can cause damage with them. That makes them great targets for learning iOS security concepts.</p>
 <div class="post-image margin-top-40 margin-bottom-40"> 
  <img src="https://i.imgur.com/QoQW4zL.jpg" alt=""> 
 </div>
 <p>The feature I'll inspect in this article is the chat bubble color selector. It allows you to change the color of a chat (duh) to a few pre-determined colors. But what if I want to use my own custom color instead?</p>
 <p><a href="http://www.cycript.org/">Cycript</a> is a debugger with a twist: you can easily print, create and call Objective-C methods without any of the complexity or pain you might experience while using <b>gdb or lldb</b>. Combined with a jailbroken iPad with OpenSSH installed, you can treat app like it's source code was available right in front of you.</p>
 <pre class="command-line language-bash" data-host="MyiPad" , data-prompt="cy#" data-output="1-2"><code>ssh root@192.168.1.103
cycript -p Messenger
var root = [UIApplication sharedApplication].keyWindow.rootViewController 
MNModalHostViewController</code></pre>
 <p>The iPad currently has the color selection action sheet opened. If Facebook's engineers are good with naming conventions, this means that following down <b>root</b>'s hierarchy will eventually lead us to a view whose's name might contain some combination of the the words "Color", "Selector", "Chat" and "Bubble". In Cycript, you can see a view's properties by putting a <b>*</b> before it.</p>
 <div class="post-image margin-top-40 margin-bottom-40"> 
  <img src="https://i.imgur.com/u4Ne4KF.png" alt=""> 
  <p>The second item of the <b>childViewControllers</b> array is a <b>MNActionSheetViewController</b>. The color selection screen is the only thing opened on the iPad, so that must be it.</p> 
 </div>
 <div class="post-image margin-top-40 margin-bottom-40"> 
  <img src="https://i.imgur.com/546IYgV.png" alt=""> 
  <p>The actionSheet's (created with <b>var actionSheet = root.childViewControllers[1]</b>) childViewController is a <b>MNThreadCustomizationPickerViewController</b>. No idea what it means, but the name is promising.</p> 
 </div>
 <div class="post-image margin-top-40 margin-bottom-40"> 
  <img src="https://i.imgur.com/x6jr7pT.png" alt=""> 
  <p>The PickerViewController contains an internal <b>pickerView</b>, as expected. There are two here, but (spoilers) the right one is the <b>FBPickerView</b>.</p> 
 </div>
 <div class="post-image margin-top-40 margin-bottom-40"> 
  <img src="https://i.imgur.com/Ww6NlIS.png" alt=""> 
  <p>The pickerView contains a lookup table with 15 elements (we have 15 colors), which is how I suppose they know which colors to show in the action sheet. It also contains a collectionView. In this case, the easier way to manipulate the colors ended up accessing the cells directly.</p> 
 </div>
 <div class="post-image margin-top-40 margin-bottom-40"> 
  <img src="https://i.imgur.com/B1mdxu9.png" alt=""> 
  <p>As expected, the collectionView contains 15 cells.</p> 
 </div>
 <div class="post-image margin-top-40 margin-bottom-40"> 
  <img src="https://i.imgur.com/uNVBUVq.png" alt=""> 
  <p>Here, I picked a random cell (calling it blueCell). It seems that each cell has a <b>button (FBPickerViewButton)</b> property.</p> 
 </div>
 <div class="post-image margin-top-40 margin-bottom-40"> 
  <img src="https://i.imgur.com/iTblMYO.png" alt=""> 
  <p>And each FBPickerViewButton contains an <b>item (FBPickerViewItem)</b></p> 
 </div>
 <p>Unfortunately, it turns out that a FBPickerViewItem's properties don't contain anything useful involving chat colors. The actual color information ended up being in it's <b>init</b> method.</p>
 <p>Let's pretend I didn't know that. To print a class's methods, we can use of the following snippet:</p>
 <pre class="language-js"><code>function printMethods(className) {
    var count = new new Type(‚ÄúI‚Äù);
    var methodsArray = []; 
    for(var i = 0; i &lt; *count; i++) {
        var method = methods[i];
        methodsArray.push({selector:method_getName(method)});
    }
    free(methods);
    return methodsArray;
}</code></pre>
 <div class="post-image margin-top-40 margin-bottom-40"> 
  <img src="https://i.imgur.com/dGGjDkV.png" alt=""> 
  <p>The result of calling <b>printMethods("FBPickerViewItem")</b>. There it is!</p> 
 </div>
 <p>In order to intercept the initialization of this class, we can use <a href="http://nshipster.com/method-swizzling/">Method Swizzling</a>. Cydia Substrate can be installed on a jailbroken device to provide helpers specific for this purpose.</p>
 <pre class="language-js"><code>@import com.saurik.substrate.MS 
var _setColor_pointer = {};
MS.hookMessage(FBPickerItem, @selector(initWithColor:accessibilityTitle:accessibilityHint:isSelected:isSelectable:), function(arg0) { 
    return _setColor_pointer-&gt;call(this,[UIColor blackColor],‚Äùa‚Äù,‚Äùb‚Äù,false,true);
}, _setColor_pointer);</code></pre>
 <p>Basically, our swizzled method calls the original implementation, but with other arguments. In this case, I force the color to be black. If I close the action sheet and open it again, the result is...</p>
 <div class="post-image margin-top-40 margin-bottom-40"> 
  <img src="https://i.imgur.com/IWIRUiy.jpg" alt=""> 
  <p>The colors changed, but will it actually work?</p> 
 </div>
 <div class="post-image margin-top-40 margin-bottom-40"> 
  <img src="https://i.imgur.com/Ow2DDZu.png" alt=""> 
  <p>It works locally, but will it work if I open Messenger somewhere else?</p> 
 </div>
 <div class="post-image margin-top-40 margin-bottom-40"> 
  <img src="https://i.imgur.com/0W3zbIH.png" alt=""> 
  <div class="sponsor-article-ad-auto hidden"></div> 
  <p>Yes! If they have analytic events for these colors, someone at Facebook will be very confused trying to figure out why there's some random guy with a black chat.</p> 
 </div>
 <p>Hopefully this can give you an idea of how easily your app's data can be tampered it. Be careful with what's inside your binary - no matter how hard you try to hide it, someone who tries hard enough will eventually find it - specially if they are being paid to screw you up. Do not try to reinvent the wheel, use actual, market proven security measures.</p>
</div>]]></description>
</item>
</channel></rss>