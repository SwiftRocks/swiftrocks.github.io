<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
    <title>SwiftRocks</title>
    <description>Recent content on SwiftRocks</description>
    <language>en-us</language>
    <copyright>2019 Bruno Rocha</copyright>
    <link>https://swiftrocks.com</link>
    <atom:link href="https://swiftrocks.com/rss.xml" rel="self" type="application/rss+xml"/>
    <item>
        <title>Swift Codable: Decoding/Encoding With Context</title>
        <link>https://swiftrocks.com/swift-codable-decodingencoding-with-context.html</link>
        <guid>https://swiftrocks.com/swift-codable-decodingencoding-with-context.html</guid>
        <pubDate>Wed, 05 Feb 2020 07:25:00 MST</pubDate>
        <description>The Codable protocols are one of the coolest recent additions to Swift. Even though it works similarly to its community counterparts like Unbox, Codable has the advantage of being powered by the compiler. One of my favorite features in Unbox was to give a context to the decoding operation. Let's take a look how we can achieve the same with Codable.</description>
    </item>
    <item>
        <title>Reducing iOS Build Times by using Interface Targets</title>
        <link>https://swiftrocks.com/reducing-ios-build-times-by-using-interface-targets.html</link>
        <guid>https://swiftrocks.com/reducing-ios-build-times-by-using-interface-targets.html</guid>
        <pubDate>Wed, 23 Jan 2020 07:00:00 MST</pubDate>
        <description>While dividing an app into several targets can improve the build time of an iOS app, the result heavily depends on what is being changed. If you're not careful with how your dependency graph is laid out, you can often have results that are worse than non-modularized apps. Let's take a look at a technique used at iFood to have big and consistent improvements to the build times of our app.</description>
    </item>
    <item>
        <title>How Hashable works in Swift</title>
        <link>https://swiftrocks.com/how-hashable-works-in-swift.html</link>
        <guid>https://swiftrocks.com/how-hashable-works-in-swift.html</guid>
        <pubDate>Mon, 13 Jan 2020 05:00:00 MST</pubDate>
        <description>Hashing algorithms are functions that map an arbitrary string to a seemingly "random" output with a fixed length. Commonly associated as a component of Sets and Dictionaries, hashing algorithms are a major component of several branches of computer science, including cryptography. The internal algorithm used to calculate a type's `hashValue` (now `Hasher` in Swift 4.2) and the related compiler features changed several times throughout Swift's releases, ant it was only after Swift 4.2 that a real universal hashing algorithm was added to Swift. To see how this is implemented today, let's take a look at how this looked like throughout the history of Swift.</description>
    </item>
    <item>
        <title>Using Type Erasure to Build a Dependency Injecting Routing Framework in Swift</title>
        <link>https://swiftrocks.com/using-type-erasure-to-build-a-dependency-injector-in-swift.html</link>
        <guid>https://swiftrocks.com/using-type-erasure-to-build-a-dependency-injector-in-swift.html</guid>
        <pubDate>Mon, 02 Jan 2020 05:00:00 MST</pubDate>
        <description>With Swift being a very type-safe and namespaced language, you'll find that certain tasks are really hard to complete if at some point you can't determine the types that are being handled - mostly when generics are involved. Using an automatic dependency injector as an example, let's see how generic arguments and closures can be "erased" to trick the compiler into compiling code that it would otherwise claim to be impossible. (when it's clearly not!)</description>
    </item>
    <item>
        <title>Faster Array Operations With CollectionOfOne in Swift</title>
        <link>https://swiftrocks.com/faster-swift-array-operations-with-collectionofone.html</link>
        <guid>https://swiftrocks.com/faster-swift-array-operations-with-collectionofone.html</guid>
        <pubDate>Mon, 23 Dec 2019 01:42:00 MST</pubDate>
        <description>CollectionOfOne is a type inside the Swift Standard Library that defines a collection of a single element. While this sounds a bit weird, there's a good reason for this to exist. Let's check out why.</description>
    </item>
    <item>
        <title>How OptionSet works inside the Swift Compiler</title>
        <link>https://swiftrocks.com/how-optionset-works-inside-the-swift-compiler.html</link>
        <guid>https://swiftrocks.com/how-optionset-works-inside-the-swift-compiler.html</guid>
        <pubDate>Tue, 03 Dec 2019 01:42:00 MST</pubDate>
        <description>Swift's OptionSet protocol is the bridged version of Objective-C's NS_OPTIONS enum -- a handy tool that allows you to very efficiently define a combination of "options" that can be used for a specific operation. Let's see what this protocol is, why OptionSets are preferred over a regular Set in some cases and finally what compiler magics it possesses.</description>
    </item>
    <item>
        <title>NSCopying uses in Swift</title>
        <link>https://swiftrocks.com/nscopying-nszone-uses-in-swift.html</link>
        <guid>https://swiftrocks.com/nscopying-nszone-uses-in-swift.html</guid>
        <pubDate>Wed, 06 Nov 2019 04:00:00 MST</pubDate>
        <description>Even in apps written in full Swift, interfacing with Objective-C is still a very big part of iOS development. Many types and semantics from Objective-C are hidden underneath the code we write today, and understanding where they come from can help you make better code decisions and just better understand the platform in general. This time, we'll take a look at what NSCopying and its companion class NSZone are and what they can do for Swift apps.</description>
    </item>
    <item>
        <title>Swift's Sequence Inside The Compiler: How for loops work internally</title>
        <link>https://swiftrocks.com/swift-sequence-inside-the-compiler-how-for-loops-work.html</link>
        <guid>https://swiftrocks.com/swift-sequence-inside-the-compiler-how-for-loops-work.html</guid>
        <pubDate>Fri, 25 Oct 2019 17:50:00 MST</pubDate>
        <description>One of my favorite things about Swift is that almost every compiler feature is built on top of actual classes and protocols of the language. This means that if you see a native type that has some special magical property (like SwiftUI's declarative syntax, which was covered in another post here in SwiftRocks), it's likely that you can reproduce that behavior in your custom types. In this article, I'll cover one of my favorite syntax sugars in the language: the protocols and the internal compiler behavior that allow you to write for loops. You might have heard already of the Sequence family of protocols, and here, we'll see how the compiler uses them as the building blocks for "for" loops.</description>
    </item>
    <item>
        <title>Building a Face Detecting Robot with URLSessionWebSocketTask, CoreML, SwiftUI and an Arduino</title>
        <link>https://swiftrocks.com/building-a-face-detecting-sentry-gun-with-urlsessionwebsockettask-coreml-swiftui-and-arduino.html</link>
        <guid>https://swiftrocks.com/building-a-face-detecting-sentry-gun-with-urlsessionwebsockettask-coreml-swiftui-and-arduino.html</guid>
        <pubDate>Tue, 15 Oct 2019 15:37:00 MST</pubDate>
        <description>iOS 13 marks the release of long-waited features like Dark Mode, but it also brought some needed changes on less popular aspects. Prior to iOS 13, creating socket connections required coding very low-level network interactions which made libraries like Starscream and Socket.io the go-to solution for sockets in iOS. Now with iOS 13, a new native URLSessionWebSocketTask class is available to finally make creating and managing socket connections easier for developers. Some time ago I created a little side project that involved an Arduino-powered servo motor that menacingly pointed at people's faces with the help of CoreML, mimicking the Team Fortress 2 Engineer's Sentry Gun. With iOS 13, I decided to re-write that using the new Socket APIs and SwiftUI.</description>
    </item>
    <item>
        <title>Using SIMD Vector Types in Swift</title>
        <link>https://swiftrocks.com/introsort-timsort-swifts-sorting-algorithm.html</link>
        <guid>https://swiftrocks.com/introsort-timsort-swifts-sorting-algorithm.html</guid>
        <pubDate>Sun, 29 Sep 2019 20:50:00 MST</pubDate>
        <description>SIMD Vector Types is a feature added in Swift 5 that exposes Apple's &lt;simd/simd.h> module to Swift, allowing you to calculate multiple results with a single instruction. Let's see how that works.</description>
    </item>
    <item>
        <title>Timsort and Introsort: Swift's Sorting Algorithms</title>
        <link>https://swiftrocks.com/introsort-timsort-swifts-sorting-algorithm.html</link>
        <guid>https://swiftrocks.com/introsort-timsort-swifts-sorting-algorithm.html</guid>
        <pubDate>Wed, 04 Sep 2019 20:50:00 MST</pubDate>
        <description>Have you ever asked yourself which algorithm is used by Swift's sorting method? There are many sorting algorithms out there, and chances are that you'll rarely have to use something other than the language's builtin sort() method. However, knowing the properties of the sorting algorithm built into your language is important if you want to prevent unwanted behaviors and nasty edge cases.</description>
    </item>
    <item>
        <title>Advanced lldb tricks for Swift - Injecting and changing code on the fly</title>
        <link>https://swiftrocks.com/using-lldb-manually-xcode-console-tricks.html</link>
        <guid>https://swiftrocks.com/using-lldb-manually-xcode-console-tricks.html</guid>
        <pubDate>Thu, 08 Aug 2019 20:40:00 MST</pubDate>
        <description>While Xcode provides several visual abstractions for lldb commands like adding breakpoints by clicking the lines of code and running by clicking the play button, lldb provides several useful commands that are not present in Xcode's UI. This can range from creating methods on the fly to even changing the CPU's registers to force a specific flow on the app without having to recompile it, and knowing them can greatly improve your debugging experience.</description>
    </item>
    <item>
        <title>Swift ExpressibleBy protocols: What they are and how they work internally in the compiler</title>
        <link>https://swiftrocks.com/swift-expressibleby-protocols-how-they-work-internally-in-the-compiler.html</link>
        <guid>https://swiftrocks.com/swift-expressibleby-protocols-how-they-work-internally-in-the-compiler.html</guid>
        <pubDate>Wed, 17 Jul 2019 10:30:00 MST</pubDate>
        <description>ExpressibleBy represents a series of protocols in the Swift Standard library that allows you to instantiate objects directly from token literals, like a string, a number, a floating-point and so on, if the object can be "expressed" like that. Let's see how the compiler applies this magic.</description>
    </item>
    <item>
        <title>Useful obscure Foundation types in Swift</title>
        <link>https://swiftrocks.com/useful-obscure-foundation-types-in-swift.html</link>
        <guid>https://swiftrocks.com/useful-obscure-foundation-types-in-swift.html</guid>
        <pubDate>Wed, 26 Jun 2019 17:30:00 MST</pubDate>
        <description>There's a bunch of Foundation types are so situational that people doubt they even existed in first place. In fact, they are so rarely mentioned as the solutions to problems that people end up making code to mimic things that already exist in the language. But they exist, and although they are old most of these types are still very useful. Let's see a few of them.</description>
    </item>
    <item>
        <title>Understanding Opaque Return Types in Swift</title>
        <link>https://swiftrocks.com/understanding-opaque-return-types-in-swift.html</link>
        <guid>https://swiftrocks.com/understanding-opaque-return-types-in-swift.html</guid>
        <pubDate>Tue, 10 Jun 2019 17:30:00 MST</pubDate>
        <description>Opaque Return Types is a feature added in Swift 5.1 that is a big part of the new SwiftUI framework's functionality. It comes to finally fix a fundamental problem of the usage of protocols and the design of Swift APIs, opening new possibilities for the creation and usage of public APIs. Let's see the compiler magic behind it and why SwiftUI uses it to return the "some View" type.</description>
    </item>
    <item>
        <title>Inside SwiftUI's Declarative Syntax's Compiler Magic</title>
        <link>https://swiftrocks.com/inside-swiftui-compiler-magic.html</link>
        <guid>https://swiftrocks.com/inside-swiftui-compiler-magic.html</guid>
        <pubDate>Tue, 04 Jun 2019 11:00:00 MST</pubDate>
        <description>Announced in WWDC 2019, SwiftUI is an incredible UI building framework that might forever change how iOS apps are made. For years we've engaged in the war of writing views via Storyboard or View Code, and SwiftUI seems to finally end this. With its release, not only Storyboards are now pretty much irrelevant, but the old fashioned View Code is also very threatened as SwiftUI mixes the best of both worlds. The thing is, it looks very different from the Swift we're used to, and the reason is because it empowers a few new "unreleased" compiler features. Let's see how this works.</description>
    </item>
    <item>
        <title>@autoreleasepool uses in 2019 Swift</title>
        <link>https://swiftrocks.com/autoreleasepool-in-2019-swift.html</link>
        <guid>https://swiftrocks.com/autoreleasepool-in-2019-swift.html</guid>
        <pubDate>Wed, 22 May 2019 07:30:00 MST</pubDate>
        <description>Foundation's NSAutoreleasePool type, later abstracted to the @autoreleasepool block, is a very old concept in iOS development. During the OBJ-C era of iOS, usage of this type was important to prevent your app's memory from blowing up in specific cases. As ARC and Swift came around and evolved, very few people still have to manually play around with memory, making seeing it become a rare occurrence. Having developed tools that need to allocate enourmous amounts of memory, I asked myself if there's still a case where @autoreleasepool is useful in Swift 5. Here are the answers.</description>
    </item>
    <item>
        <title>Avoiding Release Anxiety 2: On the importance of creating a code Style Guide</title>
        <link>https://swiftrocks.com/code-style-guides-in-swift.html</link>
        <guid>https://swiftrocks.com/code-style-guides-in-swift.html</guid>
        <pubDate>Tue, 07 May 2019 07:30:00 MST</pubDate>
        <description>When teams start to grow, it becomes to difficult to track what everyone is doing. If the team has different ideas on what a specific piece of code should look like, you can very quickly end up with a project where nobody wanders outside the things they coded themselves. Style guides can be seen as an anti-pattern when the subject is speed and there is often resistence from developers that haven't been part of large projects, and indeed having a traditional bureaucratic process in this modern tech world seems very odd, but a strict style guide is critical to have a project scale to the point where you can have hundreds of developers like Uber.</description>
    </item>
    <item>
        <title>Avoiding Release Anxiety 1: Block-based UI Testing in Swift</title>
        <link>https://swiftrocks.com/blockbased-ui-testing-in-swift.html</link>
        <guid>https://swiftrocks.com/blockbased-ui-testing-in-swift.html</guid>
        <pubDate>Sat, 20 Apr 2019 09:57:00 MST</pubDate>
        <description>When deadlines are tight and the product faces considerable changes, it's common for developers to make concessions in the project's quality to make sure it gets shipped in time. This leads to release anxiety - that stressful feeling where you're unsure if you're shipping something that actually works. As a result, teams resort to heavy amounts of manual testing, staying overtime to make sure nothing fell apart and an unhappy environment in general. Avoiding Release Anxiety is a series of posts where I show the things I do to develop durable Swift apps that allow me and my team to sleep worry-free at night. In this edition, I show why I like UI Tests and how I build them to make my projects reliable.</description>
    </item>
    <item>
        <title>iOS Responder Chain: UIResponder, UIEvent, UIControl and uses</title>
        <link>https://swiftrocks.com/understanding-the-ios-responder-chain.html</link>
        <guid>https://swiftrocks.com/understanding-the-ios-responder-chain.html</guid>
        <pubDate>Thu, 28 Feb 2019 09:57:00 MST</pubDate>
        <description>In iOS, the Responder Chain is the name given to an UIKit-generated linked list of UIResponder objects, and is the foundation for everything regarding events (like touch and motion) in iOS. The Responder Chain is something that you constantly deal with in the world of iOS development, and although you rarely have to directly deal with it outside of UITextField keyboard shenanigans, knowledge of how it works allows you to solve event-related problems in very easy/creative ways - you can even build architectures that rely on Responder Chains.</description>
    </item>
    <item>
        <title>Adding iOS Home Shortcuts to Specific Parts of An App in Swift</title>
        <link>https://swiftrocks.com/adding-deeplink-shortcuts-to-the-ios-home-screen.html</link>
        <guid>https://swiftrocks.com/adding-deeplink-shortcuts-to-the-ios-home-screen.html</guid>
        <pubDate>Wed, 20 Feb 2019 11:00:00 MST</pubDate>
        <description>iOS already allows you to add "shortcuts" to an app in the shape of 3D Touch Quick Actions, but they are very limited, hidden from the user, and let's be honest - it's one of these features that nobody remembers. You can also use Siri Extensions, but then you have to deal with Siri, and the regular Siri Shortcuts relies on the Shortcuts app, so it's not something that you can provide to your users. Wouldn't it be great if you could give your users the ability to add shortcuts to things like ordering their favorite coffee in the shape of a home icon - just like the app itself? Well, after reverse engineering Apple's Shortcuts app, it turns out that you can! That's exactly what it does when you add a system shortcut to the home screen, and we're going to replicate it in order to give users the ability to add home icons that directly open a specific part of an app.</description>
    </item>
    <item>
        <title>Avoiding Callback Hell in Swift</title>
        <link>https://swiftrocks.com/avoiding-callback-hell-in-swift.html</link>
        <guid>https://swiftrocks.com/avoiding-callback-hell-in-swift.html</guid>
        <pubDate>Mon, 17 Dec 2018 07:30:00 MST</pubDate>
        <description>Being able to work in projects of the most diverse varieties gave me the chance to be in contact with several types of developers and code bases. Besides their core differences, what stood out to me during this process is that projects with a lower level of maturity will always face similar problems. Perhaps they choose the wrong architecture, or the lack of unit tests caused a nasty bug to sneak into production, but there's a specific problem that always draws my attention - callback hell. If not treated from the very beginning, these awful pyramids of braces you get when chaining callbacks inside other callbacks or conditions plague code bases with an eternity of impossible code-reviews and distant screams of "what the hell is this method supposed to be doing?". I've shared a few tips on how to avoid them.</description>
    </item>
    <item>
        <title>How @dynamicMemberLookup Works Internally in Swift (+ Creating Custom Swift Attributes)</title>
        <link>https://swiftrocks.com/how-dynamicmemberlookup-works-internally-in-swift.html</link>
        <guid>https://swiftrocks.com/how-dynamicmemberlookup-works-internally-in-swift.html</guid>
        <pubDate>Thu, 6 Dec 2018 07:30:00 MST</pubDate>
        <description>The @dynamicMemberLookup attribute was introduced in Swift 4.2 to add a certain degree of dynamism into the language similar to what is seen in languages like Python. I was interested in learning how the attributes worked inside the compiler to know more about how this attribute is able to transform fake expressions into legit ones, so I've once again reverse-engineered the Swift compiler to find these answers - and used this knowledge to create a brand new @swiftRocks attribute.</description>
    </item>
    <item>
        <title>How Never Works Internally in Swift</title>
        <link>https://swiftrocks.com/how-never-works-internally-in-swift.html</link>
        <guid>https://swiftrocks.com/how-never-works-internally-in-swift.html</guid>
        <pubDate>Wed, 14 Nov 2018 07:30:00 MST</pubDate>
        <description>Added in Swift 3, the Never type allows you to define a method that is guaranteed to crash your app. Although we rarely write methods that use this type directly, we do interact with it constantly given that it is the return type of all forced-crash methods like fatalError(). The advantage this type brings is that a method that calls another Never-returning method does not need to provide a return value, after all, a crash is certain to happen. I investigated how that works.</description>
    </item>
    <item>
        <title>What's .self, .Type and .Protocol? Understanding Swift Metatypes</title>
        <link>https://swiftrocks.com/whats-type-and-self-swift-metatypes.html</link>
        <guid>https://swiftrocks.com/whats-type-and-self-swift-metatypes.html</guid>
        <pubDate>Mon, 29 Oct 2018 08:00:00 MST</pubDate>
        <description>Metatypes are pretty useful in Swift, and you have certainly used it in multiple occasions. Unfortunately they look pretty weird in code, which can cause some confusion when trying to understand what they really are. I for one know how these weird suffixes can confuse you, but don't worry, they are actually pretty straightforward once you get to know the differences between each of them.</description>
    </item>
    <item>
        <title>Running Other Apps' Siri Shortcuts Through Deeplinks in Swift</title>
        <link>https://swiftrocks.com/running-other-apps-siri-shortcuts-through-deep-links-in-swift.html</link>
        <guid>https://swiftrocks.com/running-other-apps-siri-shortcuts-through-deep-links-in-swift.html</guid>
        <pubDate>Thu, 18 Oct 2018 07:30:00 MST</pubDate>
        <description>Siri Shortcuts are definitely my favorite iOS 12 feature. Ever since SiriKit first came out I was very disappointed that you couldn't use it for your own custom commands, but the new Shortcuts app solves this problem. Not only it allows you to create your custom commands, but it also provides a very intuitive UI to allow even non-devs to automate tons of kinds of workflows in their iPhones. We've all seen how to create a workflow and make your app expose custom actions, but one thing that I haven't seen people mention is that the Shortcuts app exposes several deeplinks for opening and running shortcuts - meaning that you can make an app that runs other apps' Siri Shortcuts. I used this to make an app run my "Take Picture" shortcut every time I tapped my AirPods.</description>
    </item>
    <item>
        <title>How CaseIterable Works Internally in Swift</title>
        <link>https://swiftrocks.com/how-caseiterable-works-internally-in-swift.html</link>
        <guid>https://swiftrocks.com/how-caseiterable-works-internally-in-swift.html</guid>
        <pubDate>Fri, 21 Sep 2018 00:00:00 MST</pubDate>
        <description>CaseIterable is one of my favorite features in Swift 4.2. Despite being a simple protocol, it solves the common problem (that I personally faced many times) of needing access to an array containing all the cases of a certain enum. But this protocol is special: The requirements are automatically filled by the compiler. I investigated how that works - and as a bonus, modified it to also provide a "first" property.</description>
    </item>
    <item>
        <title>Swift Associated Types With Default Values</title>
        <link>https://swiftrocks.com/swift-associated-types-with-default-values.html</link>
        <guid>https://swiftrocks.com/swift-associated-types-with-default-values.html</guid>
        <pubDate>Sun, 16 Sep 2018 00:00:00 MST</pubDate>
        <description>I was browsing the Swift forums when I stumbled across a discussion regarding an undocumented feature of Swift (as of this post's date): the ability to give associated types a default value. Here's how they can improve your objects.</description>
    </item>
    <item>
        <title>Lazy Sequences in Swift And How They Work</title>
        <link>https://swiftrocks.com/lazy-sequences-in-swift-and-how-they-work.html</link>
        <guid>https://swiftrocks.com/lazy-sequences-in-swift-and-how-they-work.html</guid>
        <pubDate>Mon, 27 Aug 2018 00:00:00 MST</pubDate>
        <description>Usage of high-order functions like map and filter are very common in Swift projects, as they are simple algorithms that allow you to convert extensive ideas into simple one-liners. Unfortunately, they don't solve every issue - at least not in their default implementations. High-order functions are eager: they use the closure immediately and return a new array, regardless if you need an early return or only going to use specific elements.</description>
    </item>
    <item>
        <title>Writing Custom Pattern Matching in Swift</title>
        <link>https://swiftrocks.com/writing-custom-pattern-matching-rules-in-swift.html</link>
        <guid>https://swiftrocks.com/writing-custom-pattern-matching-rules-in-swift.html</guid>
        <pubDate>Wed, 8 Aug 2018 00:00:00 MST</pubDate>
        <description>Pattern matching is available everywhere in Swift, and you have likely used it tons of times to deconstruct and bind values in things like switch cases. While regular switch cases are the most common use for patterns, Swift has several types of patterns which can be mixed and even used outside of switches to result in really cool and short lines of code.</description>
    </item>
    <item>
        <title>Writing Cleaner View Code in Swift By Overriding loadView()</title>
        <link>https://swiftrocks.com/writing-cleaner-view-code-by-overriding-loadview.html</link>
        <guid>https://swiftrocks.com/writing-cleaner-view-code-by-overriding-loadview.html</guid>
        <pubDate>Mon, 23 Jul 2018 00:00:00 MST</pubDate>
        <description>The choice between using Storyboards and writing views programatically is very subjetive. Having dealt with both in the past, I personally vouch for writing projects entirely through view code as it allows multiple people to work in the same class without nasty conflicts, and easier code reviews. When starting with the practice of writing views programatically, a common problem people face is where to put the code in the first place. If you follow the regular storyboard approach of putting everything view related in your view controller, it's very easy to end up with gigantic classes. However, there's also a very easy way to overcome this problem.</description>
    </item>
    <item>
        <title>The Forbidden @inline Attribute in Swift</title>
        <link>https://swiftrocks.com/the-forbidden-inline-attribute-in-swift.html</link>
        <guid>https://swiftrocks.com/the-forbidden-inline-attribute-in-swift.html</guid>
        <pubDate>Sat, 26 May 2018 00:00:00 MST</pubDate>
        <description>The @inline attribute is one of those obscure things in Swift - it's nowhere to be found in Apple's docs, doesn't help you write cleaner code and has no purpose but to help the compiler make optimization decisions, but it's related to a pretty important aspect of your app's performance.</description>
    </item>
    <item>
        <title>Competitive Programming With Swift</title>
        <link>https://swiftrocks.com/competitive-programming-with-swift.html</link>
        <guid>https://swiftrocks.com/competitive-programming-with-swift.html</guid>
        <pubDate>Mon, 21 May 2018 00:00:00 MST</pubDate>
        <description>Competitive programming is a great way to master a specific programming language. Even if you're not interested in competing in world events like the Facebook Hacker Cup, tackling difficult algorithm problems using nothing but the language's bread and butter will expose you to aspects/shortcuts of the language you would otherwise never see, such as how efficient certain methods/operations are and how to code better alternatives.</description>
    </item>
    <item>
        <title>Unowned Properties in Swift</title>
        <link>https://swiftrocks.com/unowned-properties-in-swift.html</link>
        <guid>https://swiftrocks.com/unowned-properties-in-swift.html</guid>
        <pubDate>Wed, 2 May 2018 00:00:00 MST</pubDate>
        <description>It's very common to use the weak keyword in order to prevent reference cycles in properties like delegates. Unfortunately, since it protects you from references being lost, it forces the usage of var and an optional type, which can be quite jarring if you're building something like an UIView that is not supposed to be used without a delegate - much less change delegates suddenly. The unowned keyword allows you to overcome these issues.</description>
    </item>
    <item>
        <title>Memory Management and Performance of Value Types</title>
        <link>https://swiftrocks.com/memory-management-and-performance-of-value-types.html</link>
        <guid>https://swiftrocks.com/memory-management-and-performance-of-value-types.html</guid>
        <pubDate>Fri, 13 Apr 2018 00:00:00 MST</pubDate>
        <description>It's very likely that you asked yourself at least once in your iOS career what's the difference between a struct and a class. While realistically the choice between using one or another always boils down to value semantics versus reference semantics, the performance differences between the two are expressive and can heavily favor one or another depending on the contents of your object, specially when dealing with value types.</description>
    </item>
  	<item>
		<title>Understanding DispatchQueues</title>
		<link>https://swiftrocks.com/understanding-dispatchqueues.html</link>
		<guid>https://swiftrocks.com/understanding-dispatchqueues.html</guid>
        <pubDate>Wed, 14 Feb 2018 00:00:00 MST</pubDate>
        <description>Understanding how threads operate on the CPU level is the key to writing good concurrent code. This article explains how the CPU executes multithreaded processes, what exactly are iOS's DispatchQueues, what's the point of their "Quality of Services", and why do you have to process UI code in the so called Main Thread.</description>
	</item>
</channel>
</rss>
